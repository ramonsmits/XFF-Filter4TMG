/*++

Copyright (c) Microsoft Corporation. All rights reserved.
THIS CODE IS MADE AVAILABLE AS IS, WITHOUT WARRANTY OF ANY KIND.
THE ENTIRE RISK OF THE USE OR THE RESULTS FROM THE USE OF THIS CODE REMAINS WITH THE USER.
USE AND REDISTRIBUTION OF THIS CODE, WITH OR WITHOUT MODIFICATION, IS HEREBY PERMITTED.

--*/

// msfpccom.idl : IDL source for msfpccom.dll
//

// This file will be processed by the MIDL tool to
// produce the type library (msfpccom.tlb) and marshalling code.
//
// This file defines all non-generated interfaces and co-classes
// and includes generated parts


#include <FpcSdkHelpIds.h>
import "oaidl.idl";
import "FpcImports.idl";

#define DISPID_REFRESH                  100
#define DISPID_SAVE                     101
#define DISPID_ADD                      102
#define DISPID_REMOVE                   103
#define DISPID_COUNT                    104
#define DISPID_VENDOR_SETS              105
#define DISPID_EXPORT                   106
#define DISPID_IMPORT                   107
#define DISPID_LOADDOCPROPERTIES        108
#define DISPID_ENCRYPTION_PWD           109
#define DISPID_OPTIONAL_DATA            110
#define DISPID_WAIT_FOR_CHANGES         111
#define DISPID_CANCEL_WAIT_FOR_CHANGES  112
#define DISPID_CANIMPORT                113
#define DISPID_PERSISTENTNAME           114
#define DISPID_GET_RESTART_MASK         115
#define DISPID_GET_DIRTY_FEATURES       116
#define DISPID_IMPORT_AS_NEW            117
#define DISPID_IMPORT_FILE              118
#define DISPID_EXPORT_FILE              119

typedef long FpcUrlCategoryT;

interface IFPCItemInternal;
interface IFPCCollectionInternal;
interface IFPCRefInternal;
interface IFPCDistributionStatusInternal;
interface IFPCIPSConfiguration;
interface IFPCUpdateSchedule;
interface IFPCSoftwareUpdatesSettings;

#ifndef VARIANT_FALSE
    #define VARIANT_FALSE ((VARIANT_BOOL)0)
    #define VARIANT_TRUE  ((VARIANT_BOOL)-1)
#endif

#define ACCESS_MASK          DWORD

[
    hidden,
    object,
    uuid(1622c653-7c60-4a79-bcb1-7bf1595f2186),
    helpstring("IFPCDistributionStatusInternal Interface"),
    pointer_default(unique),
    oleautomation
]
interface IFPCDistributionStatusInternal : IUnknown
{
    [propput, id(9), helpstring("Gets or sets a Boolean value that indicates whether to skip the configuration storage servers synchronization check"), hidden]
    HRESULT SkipConfigurationStorageServersSynchronizationCheck ([in, defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fSkipConfigurationStorageServersSyncCheck);
    [propget, id(9), helpstring("Gets or sets a Boolean value that indicates whether to skip the configuration storage servers synchronization check"), hidden]
    HRESULT SkipConfigurationStorageServersSynchronizationCheck ([out, retval] VARIANT_BOOL *pfSkipConfigurationStorageServersSyncCheck);
};

[
object,
uuid(CF378B21-4646-4ECC-8669-D61A8F0BCB5C),
dual,
helpstring("A log entry"),
pointer_default(unique)
]
interface IFPCLogEntry : IDispatch
{
    [propget, id(1), helpstring("Gets the client IP")]
    HRESULT ClientIP([out,retval] BSTR *pVal);

    [propget, id(2), helpstring("Gets the Client UserName")]
    HRESULT ClientUserName([out,retval] BSTR *pVal);

    [propget, id(3), helpstring("Gets the ClientAgent")]
    HRESULT ClientAgent([out,retval] BSTR *pVal);

    [propget, id(4), helpstring("Gets the ClientAuthenticate")]
    HRESULT ClientAuthenticate([out,retval] FpcClientAuthenticatedValues *pVal);

    [propget, id(5), helpstring("Gets the Service")]
    HRESULT Service([out,retval] FpcLogServiceType *pVal);

    [propget, id(6), helpstring("Gets the Server name")]
    HRESULT Servername([out,retval] BSTR *pVal);

    [propget, id(7), helpstring("Gets the ReferredServer")]
    HRESULT ReferredServer([out,retval] BSTR *pVal);

    [propget, id(8), helpstring("Gets the Destination Host")]
    HRESULT DestHost([out,retval] BSTR *pVal);

    [propget, id(9), helpstring("Gets the Destination Host IP")]
    HRESULT DestHostIP([out,retval] BSTR *pVal);

    [propget, id(10), helpstring("Gets the Protocol")]
    HRESULT Protocol([out,retval] BSTR *pVal);

    [propget, id(11), helpstring("Gets the Transport")]
    HRESULT Transport([out,retval] BSTR *pVal);

    [propget, id(12), helpstring("Gets the Operation")]
    HRESULT Operation([out,retval] BSTR *pVal);

    [propget, id(13), helpstring("Gets the Url")]
    HRESULT Url([out,retval] BSTR *pVal);

    [propget, id(16), helpstring("Gets the MimeType")]
    HRESULT MimeType([out,retval] BSTR *pVal);

    [propget, id(17), helpstring("Gets the ObjectSource")]
    HRESULT ObjectSource([out,retval] FpcProxyObjSources *pVal);

    [propget, id(18), helpstring("Gets the SourceNetwork")]
    HRESULT SourceNetwork([out,retval] BSTR *pVal);

    [propget, id(19), helpstring("Gets the DestinationNetwork")]
    HRESULT DestinationNetwork([out,retval] BSTR *pVal);

    [propget, id(20), helpstring("Gets the SourceProxy")]
    HRESULT SourceProxy([out,retval] BSTR *pVal);

    [propget, id(21), helpstring("Gets the DestinationProxy")]
    HRESULT DestinationProxy([out,retval] BSTR *pVal);

    [propget, id(22), helpstring("Gets the Action")]
    HRESULT FWAction([out,retval] FpcAction *pVal);

    [propget, id(23), helpstring("Gets the SourceHost")]
    HRESULT SourceHost([out,retval] BSTR *pVal);

    [propget, id(24), helpstring("Gets the Rule")]
    HRESULT Rule([out,retval] BSTR *pVal);

    [propget, id(25), helpstring("Gets the Interface")]
    HRESULT Interface([out,retval] BSTR *pVal);

    [propget, id(26), helpstring("Gets the RawIPHeader")]
    HRESULT RawIPHeader([out,retval] BSTR *pVal);

    [propget, id(27), helpstring("Gets the RawPayload")]
    HRESULT RawPayload([out,retval] BSTR *pVal);

    [propget, id(28), helpstring("Gets the Log Time")]
    HRESULT LogTime([out,retval] DATE *pVal);

    [propget, id(29), helpstring("Gets the Destination Host Port")]
    HRESULT DestHostPort([out,retval] long *pVal);

    [propget, id(30), helpstring("Gets the SrcPort")]
    HRESULT SrcPort([out,retval] long *pVal);

    [propget, id(31), helpstring("Gets the processingtime")]
    HRESULT ProcessingTime([out,retval] long *pVal);

    [propget, id(32), helpstring("Gets the bytessent")]
    HRESULT BytesSent([out,retval] __int64 *pVal);

    [propget, id(33), helpstring("Gets the BytesReceived")]
    HRESULT BytesReceived([out,retval] __int64 *pVal);

    [propget, id(34), helpstring("Gets the resultcode")]
    HRESULT ResultCode([out,retval] long *pVal);

    [propget, id(35), helpstring("Gets the CacheInfo")]
    HRESULT CacheInfo([out,retval] long *pVal);

    [propget, id(36), helpstring("Gets the ErrorInfo")]
    HRESULT ErrorInfo([out,retval] long *pVal);

    [propget, id(37), helpstring("Gets the Bidirectional")]
    HRESULT Bidirectional([out,retval] FpcBidirectional *pVal);

    [propget, id(38), helpstring("Gets the Filter Information")]
    HRESULT FilterInformation([out,retval] BSTR *pVal);

    [propget, id(39), helpstring("Gets the LogType")]
    HRESULT LogType([out,retval] FpcLoggingComponents *pVal);

    [propget, id(40), helpstring("Gets the Original Client IP")]
    HRESULT OriginalClientIP([out,retval] BSTR *pVal);

};

[
object,
uuid(0742CC59-001A-4149-92E5-15EC1FDBAD28),
dual,
helpstring("A log entry"),
pointer_default(unique)
]
interface IFPCEELogEntry : IFPCLogEntry
{
    [propget, id(41), helpstring("Gets the GMT based log time")]
    HRESULT GmtLogTime([out,retval] DATE *pVal);

};

[
object,
uuid(A0D02B00-059C-4f2b-B964-121B591DE311),
dual,
helpstring("A log entry"),
pointer_default(unique)
]
interface IFPCLogEntry2 : IFPCEELogEntry
{
    [propget, id(42), helpstring("Gets the Authentication Server name")]
    HRESULT AuthenticationServer([out,retval] BSTR *pVal);

};

[
object,
uuid(39E06FA3-16CB-408a-8AD5-5EDAD521F752),
dual,
helpstring("A log entry"),
pointer_default(unique)
]
interface IFPCLogEntry3 : IFPCLogEntry2
{
    [propget, id(43), helpstring("Gets the NIS Scan Result")]
    HRESULT IpsScanResult([out,retval] FpcIpsScanResult *pVal);

    [propget, id(44), helpstring("Gets the NIS Signature")]
    HRESULT IpsSignature([out,retval] BSTR *pVal);

    [propget, id(45), helpstring("Gets the name of the threat found by malware inspection")]
    HRESULT ThreatName([out,retval] BSTR *pVal);

    [propget, id(46), helpstring("Gets the MalwareInspectionAction")]
    HRESULT MalwareInspectionAction([out,retval] FpcMalwareInspectionAction *pVal);

    [propget, id(47), helpstring("Gets the MalwareInspectionActionReason")]
    HRESULT MalwareInspectionActionReason([out,retval] FpcMalwareInspectionActionReason *pVal);

    [propget, id(48), helpstring("Gets the URL Category")]
    HRESULT URLCategory([out,retval] FpcUrlCategoryT *pVal);

    [propget, id(49), helpstring("Gets the MalwareInspectionContentDeliveryMethod")]
    HRESULT MalwareInspectionContentDeliveryMethod([out,retval] FpcMalwareInspectionContentDeliveryMethod *pVal);

    [propget, id(50), helpstring("")]
    HRESULT UagArrayId([out,retval] BSTR *pVal);

    [propget, id(51), helpstring("")]
    HRESULT UagVersion([out,retval] long *pVal);

    [propget, id(52), helpstring("")]
    HRESULT UagModuleId([out,retval] BSTR *pVal);

    [propget, id(53), helpstring("")]
    HRESULT UagId([out,retval] long *pVal);

    [propget, id(54), helpstring("")]
    HRESULT UagSeverity([out,retval] BSTR *pVal);

    [propget, id(55), helpstring("")]
    HRESULT UagType([out,retval] BSTR *pVal);

    [propget, id(56), helpstring("")]
    HRESULT UagEventName([out,retval] BSTR *pVal);

    [propget, id(57), helpstring("")]
    HRESULT UagSessionId([out,retval] BSTR *pVal);

    [propget, id(58), helpstring("")]
    HRESULT UagTrunkName([out,retval] BSTR *pVal);

    [propget, id(59), helpstring("")]
    HRESULT UagServiceName([out,retval] BSTR *pVal);

    [propget, id(60), helpstring("")]
    HRESULT UagErrorCode([out,retval] long *pVal);

    [propget, id(61), helpstring("Gets the time needed to inspect the content of a request for malware, in milliseconds")]
    HRESULT MalwareInspectionDuration([out,retval] long *pVal);

    [propget, id(62), helpstring("Gets a value from the MalwareInspectionThreatLevel enumerated type")]
    HRESULT MalwareInspectionThreatLevel([out,retval] FpcMalwareInspectionThreatLevel *pVal);

};

[
object,
uuid(54a4f33d-ca23-457b-9219-c966b26accd5),
dual,
nonextensible,
helpstring("A log entry"),
pointer_default(unique)
]
interface IFPCLogEntry4 : IFPCLogEntry3
{
    [propget, id(63), helpstring("Gets the NAT Address")]
    HRESULT NATAddress([out,retval] BSTR *pVal);

    [propget, id(64), helpstring("Gets a bitwise combination of values that represents information generated by internal services")]
    HRESULT InternalServiceInfo([out,retval] long *pVal);

    [propget, id(65), helpstring("Gets the full path of the client application for a Forefront TMG Client connection")]
    HRESULT FwcAppPath([out,retval] BSTR *pVal);

    [propget, id(66), helpstring("Gets the SHA1 hash value that is calculated for the executable file of the client application and used by Forefront TMG Client to request a network connection")]
    HRESULT FwcAppSHA1([out,retval] BSTR *pVal);

    [propget, id(67), helpstring("Gets a value from the FpcFwcClientApplicationTrustState enumerated type that indicates whether the client application is trusted by the operating system running on the client computer")]
    HRESULT FwcAppTrustState([out,retval] FpcFwcClientApplicationTrustState *pVal);

    [propget, id(68), helpstring("Gets the internal name of the client application")]
    HRESULT FwcAppInternalName([out,retval] BSTR *pVal);

    [propget, id(69), helpstring("Gets the product name of the client application")]
    HRESULT FwcAppProductName([out,retval] BSTR *pVal);

    [propget, id(70), helpstring("Gets the product verison of the client application")]
    HRESULT FwcAppProductVersion([out,retval] BSTR *pVal);

    [propget, id(71), helpstring("Gets the file version of the client application")]
    HRESULT FwcAppFileVersion([out,retval] BSTR *pVal);

    [propget, id(72), helpstring("Gets the original name of the client application")]
    HRESULT FwcAppOrgFile([out,retval] BSTR *pVal);

    [propget, id(73), helpstring("Gets the FQDN of the client computer for a Forefront TMG Client connection")]
    HRESULT FwcClientFQDN([out,retval] BSTR *pVal);

    [propget, id(74), helpstring("Gets the NIS Application Protocol")]
    HRESULT IpsApplicationProtocol([out,retval] BSTR *pVal);

    [propget, id(75), helpstring("Gets a value from the FpcUrlCategorizationReason enumerated type")]
    HRESULT URLCategorizationReason([out,retval] FpcUrlCategorizationReason *pVal);

    [propget, id(76), helpstring("Gets a value from the FpcSessionType enumerated type that indicates request type - web proxy, NAT of Firecall Client")]
    HRESULT SessionType([out,retval] FpcSessionType *pVal);

    [propget, id(77), helpstring("Gets the version of the Forefront TMG Client")]
    HRESULT FwcVersion([out,retval] BSTR *pVal);

    [propget, id(78), helpstring("Gets the URL Destination Host")]
    HRESULT UrlDestHost([out,retval] BSTR *pVal);


};

/////////////////////////////////////////////////////////////////////////
// Enter generated interfaces

interface IFPC;
interface IFPCEE;
interface IFPC2;
interface IFPC3;
interface IFPCEEEnterprise;
interface IFPCEnterprise2;
interface IFPCEnterprise3;
interface IFPCEEPolicies;
interface IFPCEEPolicy;
interface IFPCPolicy2;
interface IFPCConnectionLimit;
interface IFPCConnectionLimit2;
interface IFPCConnectionLimit3;
interface IFPCConnectionLimitPolicy;
interface IFPCConnectionLimitPolicy2;
interface IFPCArray;
interface IFPCEEArray;
interface IFPCArray2;
interface IFPCArray3;
interface IFPCArray4;
interface IFPCArrays;
interface IFPCEEArrays;
interface IFPCArrays2;
interface IFPCCrossArraySettings;
interface IFPCCrossArray;
interface IFPCCrossArrayImplicitMappings;
interface IFPCCrossArrayImplicitMapping;
interface IFPCEEPolicyAssignment;
interface IFPCPolicyAssignment2;
interface IFPCEEConfigurationStorageServerConnection;
interface IFPCConfigurationStorageServerConnection2;
interface IFPCCache;
interface IFPCExtensions;
interface IFPCRuleElements;
interface IFPCRuleElements2;
interface IFPCRuleElements3;
interface IFPCRuleElements4;
interface IFPCNetworkConfiguration;
interface IFPCEENetworkConfiguration;
interface IFPCServers;
interface IFPCEEServers;
interface IFPCCertificates;
interface IFPCCertificates2;
interface IFPCCertificate;
interface IFPCCertificate2;
interface IFPCCertificate3;
interface IFPCServer;
interface IFPCEEServer;
interface IFPCServer2;
interface IFPCServer3;
interface IFPCServer4;
interface IFPCExternalComponents;
interface IFPCExternalComponent;
interface IFPCEEDistributionStatus;
interface IFPCDistributionStatus2;
interface IFPCSchedule;
interface IFPCSchedules;
interface IFPCAlert;
interface IFPCAlerts;
interface IFPCAlertAction;
interface IFPCAlertActions;
interface IFPCEventDefinition;
interface IFPCEventDefinitions;
interface IFPCVendorParametersSets;
interface IFPCVendorParametersSet;
interface IFPCLdapMatchingPattern;
interface IFPCLdapMatchingPatterns;
interface IFPCLdapServer;
interface IFPCLdapServersSet;
interface IFPCLdapServersSets;
interface IFPCRadiusServers;
interface IFPCRadiusServer;
interface IFPCRadiusServer2;
interface IFPCUserSets;
interface IFPCUserSet;
interface IFPCAccounts;
interface IFPCNonWindowsUsers;
interface IFPCNonWindowsUsers2;
interface IFPCAccount;
interface IFPCNonWindowsUser;
interface IFPCNonWindowsUser2;
interface IFPCCredentials;
interface IFPCLogs;
interface IFPCLogs2;
interface IFPCLogs3;
interface IFPCLog;
interface IFPCEELog;
interface IFPCLog2;
interface IFPCSessionsMonitorEntry;
interface IFPCSessionsMonitor;
interface IFPCSessionsMonitors;
interface IFPCLogViewer;
interface IFPCLogViewer2;
interface IFPCLogContent;
interface IFPCEELogContent;
interface IFPCArrayPolicy;
interface IFPCArrayPolicy2;
interface IFPCArrayPolicy3;
interface IFPCNetworkInspectionSystem;
interface IFPCNisSignatureConfigurations;
interface IFPCNisSignatureConfiguration;
interface IFPCNisSignatureSet;
interface IFPCNisSignatures;
interface IFPCNisSignature;
interface IFPCNisAvailableSignatureSets;
interface IFPCNisAvailableSignatureSet;
interface IFPCSystemPolicy;
interface IFPCSystemPolicyConfigGroup;
interface IFPCUserAgentMapping;
interface IFPCUserAgentMappings;
interface IFPCCacheConfiguration;
interface IFPCCacheRules;
interface IFPCCacheRule;
interface IFPCCacheRule2;
interface IFPCHTTPCacheConfiguration;
interface IFPCFTPCacheConfiguration;
interface IFPCActiveCacheConfiguration;
interface IFPCProtocolDefinition;
interface IFPCProtocolDefinition2;
interface IFPCProtocolConnection;
interface IFPCProtocolConnection2;
interface IFPCIpOptions;
interface IFPCProtocolConnections;
interface IFPCProtocolConnections2;
interface IFPCProtocolDefinitions;
interface IFPCAdapters;
interface IFPCAllAdapters;
interface IFPCAllAdapters2;
interface IFPCAdapter;
interface IFPCAdapter2;
interface IFPCRefs;
interface IFPCEERefs;
interface IFPCRef;
interface IFPCEERef;
interface IFPCApplicationFilter;
interface IFPCApplicationFilter2;
interface IFPCApplicationFilters;
interface IFPCRoutingRules;
interface IFPCRoutingRule;
interface IFPCPrimaryRoute;
interface IFPCPrimaryRoute2;
interface IFPCBackupRoute;
interface IFPCBackupRoute2;
interface IFPCDialupNetworkConnections;
interface IFPCCacheContents;
interface IFPCAttackDetection;
interface IFPCCacheDrive;
interface IFPCCacheDrives;
interface IFPCDiskDrive;
interface IFPCDiskDrives;
interface IFPCClientConfig;
interface IFPCFirewallClientConfig;
interface IFPCWebBrowserClientConfig;
interface IFPCClientAutoScript;
interface IFPCClientAutoScript2;
interface IFPCClientAutoScript3;
interface IFPCClientBackupRoute;
interface IFPCLDT;
interface IFPCLDTEntry;
interface IFPCScheduledContentDownload;
interface IFPCScheduledContentDownloadConfig;
interface IFPCPublicNames;
interface IFPCLinkTranslationPatterns;
interface IFPCLinkTranslationRedirection;
interface IFPCPathMappings;
interface IFPCPathMapping;
interface IFPCFilterExpression;
interface IFPCFilterExpressions;
interface IFPCFilterExpressions2;
interface IFPCUserAgents;
interface IFPCHTTPHeaders;
interface IFPCFirewallChaining;
interface IFPCDialingConfiguration;
interface IFPCWebProxy;
interface IFPCEEWebProxy;
interface IFPCWebProxy2;
interface IFPCWebProxy3;
interface IFPCCookieCryptoConfiguration;
interface IFPCUserMapping;
interface IFPCAuthenticationScheme;
interface IFPCAuthenticationSchemes;
interface IFPCWebFilter;
interface IFPCWebFilter2;
interface IFPCWebFilters;
interface IFPCTunnelPortRanges;
interface IFPCHTTPCompressionConfiguration;
interface IFPCHTTPCompressionConfiguration2;
interface IFPCTunnelPortRange;
interface IFPCContentTypeSets;
interface IFPCContentTypeSet;
interface IFPCContentTypeSet2;
interface IFPCConnectivityResults;
interface IFPCConnectivityResult;
interface IFPCConnectivityResult2;
interface IFPCSignaledAlerts;
interface IFPCSignaledAlert;
interface IFPCSignaledAlertInstance;
interface IFPCScheduledContentDownloadJobStatus;
interface IFPCScheduledContentDownloadJobStatuses;
interface IFPCClientConfigSettings;
interface IFPCClientSettingsSection;
interface IFPCNetworks;
interface IFPCNetwork;
interface IFPCEENetwork;
interface IFPCNetwork2;
interface IFPCEEEnterpriseNetworks;
interface IFPCEEEnterpriseNetwork;
interface IFPCEEEnterpriseNetwork2;
interface IFPCNetworkTemplates;
interface IFPCNetworkTemplate;
interface IFPCNetworksInTemplate;
interface IFPCNetworkInTemplate;
interface IFPCPoliciesInTemplate;
interface IFPCPolicyInTemplate;
interface IFPCNetworkSets;
interface IFPCNetworkSet;
interface IFPCEENetworkSet;
interface IFPCNetworkRule;
interface IFPCNetworkRule2;
interface IFPCReadOnlyIpRangeEntry;
interface IFPCReadOnlyIpRangeSet;
interface IFPCEEReadOnlyIpRangeSet;
interface IFPCNetworkRules;
interface IFPCVpnConfiguration;
interface IFPCEEVpnConfiguration;
interface IFPCVpnConfiguration2;
interface IFPCVpnQuarantineSettings;
interface IFPCVpnPPPSettings;
interface IFPCVpnNetworkConfiguration;
interface IFPCEEVpnNetworkConfiguration;
interface IFPCVpnNetworkL2tpPptpSettings;
interface IFPCVpnNetworkIPSecSettings;
interface IFPCIpRangeEntry;
interface IFPCIpRangeSet;
interface IFPCWebListenerProperties;
interface IFPCWebListenerProperties2;
interface IFPCWebListenerProperties3;
interface IFPCFormsBasedAuthenticationProperties;
interface IFPCSecurIDAuthenticationProperties;
interface IFPCWebListener;
interface IFPCWebListeners;
interface IFPCSSLClientCertificateRestriction;
interface IFPCSSLClientCertificateRestrictions;
interface IFPCIPsOnNetworks;
interface IFPCIPAddresses;
interface IFPCIPOnNetwork;
interface IFPCAppliedSSLCertificates;
interface IFPCAppliedSSLCertificate;
interface IFPCAppliedSSLCertificate2;
interface IFPCReportJobs;
interface IFPCReportJobs2;
interface IFPCReportJob;
interface IFPCEEReportJob;
interface IFPCEEReportJob2;
interface IFPCReports;
interface IFPCReports2;
interface IFPCLogSummaryConfiguration;
interface IFPCReportingServicesProperties;
interface IFPCReadyReport;
interface IFPCReadyReports;
interface IFPCReportSummaryDefinition;
interface IFPCReportSummaryDefinition2;
interface IFPCReportSummaryDefinitions;
interface IFPCRdlReportDefinition;
interface IFPCRdlReportDefinitions;
interface IFPCRdlReportParameterInstance;
interface IFPCRdlReportParameterInstances;
interface IFPCRdlReportParameterPermittedValue;
interface IFPCRdlReportParameterPermittedValues;
interface IFPCRdlReportParameter;
interface IFPCRdlReportParameters;
interface IFPCRdlReportCategory;
interface IFPCRdlReportCategories;
interface IFPCRdlReportRef;
interface IFPCRdlReportRefs;
interface IFPCReportsProperties;
interface IFPCEEReportsProperties;
interface IFPCSummaryReports;
interface IFPCWebUsageReports;
interface IFPCApplicationUsageReports;
interface IFPCTrafficReports;
interface IFPCSecurityReports;
interface IFPCComputer;
interface IFPCComputers;
interface IFPCAddressRange;
interface IFPCAddressRange2;
interface IFPCAddressRanges;
interface IFPCSubnet;
interface IFPCSubnets;
interface IFPCISPs;
interface IFPCISP;
interface IFPCISPRedundancyConfig;
interface IFPCComputerSet;
interface IFPCComputerSet2;
interface IFPCComputerSets;
interface IFPCComputerSets2;
interface IFPCUrlCategory;
interface IFPCUrlCategories;
interface IFPCUrlCategorySet;
interface IFPCUrlCategorySets;
interface IFPCURLSet;
interface IFPCURLSets;
interface IFPCDomainNameSet;
interface IFPCPublishedServer;
interface IFPCLoadBalancingConfig;
interface IFPCServerFarm;
interface IFPCServerFarms;
interface IFPCPublishedServers;
interface IFPCDomainNameSets;
interface IFPCSelectionIPs;
interface IFPCEESelectionIPs;
interface IFPCExplicitLinkTranslationMappings;
interface IFPCExplicitLinkTranslationMapping;
interface IFPCCodePages;
interface IFPCCodePage;
interface IFPCAccessProperties;
interface IFPCAccessProperties2;
interface IFPCServerPublishingProperties;
interface IFPCEEServerPublishingProperties;
interface IFPCWebPublishingProperties;
interface IFPCWebPublishingProperties2;
interface IFPCWebPublishingProperties3;
interface IFPCWebPublishingProperties4;
interface IFPCPolicyGroups;
interface IFPCPolicyGroup;
interface IFPCPolicyRules;
interface IFPCEEPolicyRules;
interface IFPCSystemPolicyRules;
interface IFPCSystemPolicyRules2;
interface IFPCPolicyRule;
interface IFPCEEPolicyRule;
interface IFPCPolicyRule2;
interface IFPCPolicyRule3;
interface IFPCPolicyRule4;
interface IFPCAdminSecurity;
interface IFPCSecurityRoles;
interface IFPCSecurityRole;
interface IFPCDelegatedAdmins;
interface IFPCEEDelegatedAdmins;
interface IFPCDelegatedAdmin;
interface IFPCEEDelegatedAdmin;
interface IFPCConnectivityVerifiers;
interface IFPCConnectivityVerifiers2;
interface IFPCConnectivityVerifier;
interface IFPCConnectivityVerifier2;
interface IFPCLowLevelSettings;
interface IFPCLowLevelSettings2;
interface IFPCLowLevelSettings3;
interface IFPCEENLBCluster;
interface IFPCNLBCluster2;
interface IFPCEENLBConfiguration;
interface IFPCNLBConfiguration2;
interface IFPCEEDomainMapping;
interface IFPCEEDomainMappings;
interface IFPCContentDeliverySettings;
interface IFPCContentDeliverySettings2;
interface IFPCOutboundHTTPSInspectionConfiguration;
interface IFPCOutboundHTTPSInspectionConfiguration2;
interface IFPCCACertificate;
interface IFPCUrlToCategoryMapping;
interface IFPCUrlToCategoryMappings;
interface IFPCMalwareInspectionSettings;
interface IFPCMalwareInspectionSettings2;
interface IFPCTemporaryStorageSettings;
interface IFPCMalwareInspectionScannerSettings;
interface IFPCRoutingTable;
interface IFPCRoute;
interface IFPCStaticRoutes;
interface IFPCStaticRoute;
interface IFPCUpdateCenter;
interface IFPCUpdateCenter2;
interface IFPCUpdateServices;
interface IFPCUpdateService;
interface IFPCUpdateService2;
interface IFPCLicenses;
interface IFPCLicense;
interface IFPCServiceUpdatesStates;
interface IFPCServiceUpdatesState;
interface IFPCServiceUpdatesState2;
interface IFPCMalwareInspectionProperties;
interface IFPCMalwareInspectionProperties2;
interface IFPCDestinations;
interface IFPCDestinations2;
interface IFPCSources;
interface IFPCProtocolMessageDefinitionParameter;
interface IFPCProtocolMessageDefinition;
interface IFPCProtocolMessageDefinitions;
interface IFPCUrlFilteringSettings;
interface IFPCPerfCounterSettings;
interface IFPCRequestRateAverageBytesPerSec;
interface IFPCActivityStatisticsEntry;
interface IFPCPerformanceCounterEntry;
interface IFPCActivityStatistics;
interface IFPCDashboardPerformanceCounters;
interface IFPCSipSettings;
interface IFPCSmtpProtectionConfiguration;
interface IFPCMailAntivirusSettings;
interface IFPCMailAntiSpamSettings;
interface IFPCSmtpProtectionStatus;
interface IFPCIpListRanges;
interface IFPCIpListRange;
interface IFPCIpListProviders;
interface IFPCIpListProvider;
interface IFPCEMailAddress;
interface IFPCPhrase;
interface IFPCEMailAddresses;
interface IFPCPhrases;
interface IFPCBlockedSenders;
interface IFPCBlockedSender;
interface IFPCAddressSpace;
interface IFPCAddressSpaces;
interface IFPCSmtpAuthenticationSettings;
interface IFPCSmtpRouteAuthenticationSettings;
interface IFPCSmtpRoute;
interface IFPCSmtpRoutes;
interface IFPCMailAntispamFilterLists;
interface IFPCMailAntispamFilterList;
interface IFPCSecurityAssessmentSharing;
interface IFPCMailAntispamFilterStrings;
interface IFPCMailAntispamFilterFileTypes;
interface IFPCRestrictedPorts;
interface IFPCRestrictedPortsRange;
interface IFPCChangeTracking;
interface IFPCIPv6Settings;
[
object,
uuid(77C180DA-AF0D-4314-8FA7-BA0C5B8C9E94),
dual,
helpstring("The root FPC object"),
pointer_default(unique)
]
interface IFPC : IDispatch
{
	[propget, id(1), helpstring("Gets the collection of FPC arrays within the root object")]
    HRESULT Arrays([out, retval] IFPCArrays **pVal);
	
	[id(2), helpstring("Returns the array that contains the current computer")]
          HRESULT GetContainingArray([out,retval] IFPCArray** pItem);
        
    
	[id(3), helpstring("Returns the server containing the current computer")]
          HRESULT GetContainingServer([out,retval] IFPCServer** pItem);
        
    
};
	
[
object,
uuid(fceac2b8-b72a-4636-a820-a5563fe5933a),
dual,
helpstring("The root FPC object"),
pointer_default(unique)
]
interface IFPCEE : IFPC
{
	[propget, id(4), helpstring("Gets the item of FPC Enterprise within the root object")]
    HRESULT Enterprise([out, retval] IFPCEEEnterprise **pVal);
	
	[id(5), helpstring("Connect to an enterprise using the specified configuration storage server")]
          HRESULT ConnectToConfigurationStorageServer([in,defaultvalue("")] BSTR ConfigurationStorageServer,
              [in,defaultvalue("")] BSTR StorageUserName,
              [in,defaultvalue("")] BSTR StorageUserDomain,
              [in,defaultvalue("")] BSTR StorageUserPassword,
              [in,defaultvalue("")] BSTR MonitoringUserName,
              [in,defaultvalue("")] BSTR MonitoringUserDomain,
              [in,defaultvalue("")] BSTR MonitoringUserPassword);
        
    
	[id(6), helpstring("Disconnects from the enterprise represented by the configuration storage server")]
          HRESULT DisconnectFromConfigurationStorageServer();
        
    
	[propget, id(7), helpstring("Gets the name of the configuration storage server used for connecting to enterprise")]
    HRESULT ConfigurationStorageServer([out, retval] BSTR *pVal);
	
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh([in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL ArrayInfoOnly);
        
    
	[id(DISPID_EXPORT), helpstring("Writes the stored values of all of the object's properties to the specified XML document.")]
          HRESULT Export([in] IUnknown* pDocument,
              [in] long OptionalData,
              [in,defaultvalue(NULL)] BSTR EncryptionPassword,
              [in,defaultvalue(NULL)] BSTR Comment);
        
    
	[id(DISPID_IMPORT), helpstring("Copies the values of all of the object's properties from the specified XML document to persistent storage.")]
          HRESULT Import([in] IUnknown* pDocument,
              [in] long OptionalData,
              [in,defaultvalue(NULL)] BSTR EncryptionPassword,
              [in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL CleanCollections,
              [in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_EXPORT_FILE), helpstring("Writes the stored values of all of the object's properties to the specified XML file.")]
          HRESULT ExportToFile([in] BSTR XmlFileName,
              [in] long OptionalData,
              [in,defaultvalue(NULL)] BSTR EncryptionPassword,
              [in,defaultvalue(NULL)] BSTR Comment);
        
    
	[id(DISPID_IMPORT_FILE), helpstring("Copies the values of all of the object's properties from the specified XML file to persistent storage.")]
          HRESULT ImportFromFile([in] BSTR XmlFileName,
              [in] long OptionalData,
              [in,defaultvalue(NULL)] BSTR EncryptionPassword,
              [in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL CleanCollections,
              [in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_CANIMPORT), helpstring("Returns a Boolean value that indicates whether the object's properties can be imported from the specified XML document.")]
          HRESULT CanImport([in] IUnknown* pDocument,
              [in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL bValidateSchema,
              [out,retval] VARIANT_BOOL* pbRetVal);
        
    
	[id(DISPID_LOADDOCPROPERTIES), helpstring("Provides the XML document's properties so that you can know what information can be imported from the document.")]
          HRESULT LoadDocProperties([in] IUnknown* pDocument,
              [out,defaultvalue(NULL)] BSTR* ItemType,
              [out,defaultvalue(NULL)] long* OptionalData,
              [out,defaultvalue(NULL)] BSTR* Comment);
        
    
	[id(8), helpstring("Connect to the local storage"), hidden]
          HRESULT ConnectToLocalStorage();
        
    
	[id(9), helpstring("Disconnect from the local storage"), hidden]
          HRESULT DisconnectFromLocalStorage();
        
    
	[propget, id(10), helpstring("Gets or sets whether the ApplyChanges method is required"), hidden]
    HRESULT RequireApplyChanges([out, retval] VARIANT_BOOL *pVal);
    [propput, id(10), helpstring("Gets or sets whether the ApplyChanges method is required"), hidden]
    HRESULT RequireApplyChanges([in] VARIANT_BOOL newVal);
	
	[propget, id(11), helpstring("Gets whether changes have been made that would require the ApplyChanges method"), hidden]
    HRESULT ChangesMade([out, retval] VARIANT_BOOL *pVal);
	
	[id(12), helpstring("Apply changes"), hidden]
          HRESULT ApplyChanges([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(13), helpstring("Discard changes"), hidden]
          HRESULT DiscardChanges();
        
    
	[propget, id(14), helpstring("Gets the last sequential change number of the stored data"), hidden]
    HRESULT StorageChangeNumber([out, retval] __int64 *pVal);
	
};
	
[
object,
uuid(A08152ED-E18D-42B8-B133-FB1F20744D6C),
dual,
helpstring("The root FPC object"),
pointer_default(unique)
]
interface IFPC2 : IFPCEE
{
	[propget, id(15), helpstring("Gets ISA edition type")]
    HRESULT IsaEdition([out, retval] FpcIsaEditionType *pVal);
	
	[propget, id(16), helpstring("Gets or sets a Boolean value that indicates whether the system policy configuration is in vendor mode"), hidden]
    HRESULT VendorMode([out, retval] VARIANT_BOOL *pVal);
    [propput, id(16), helpstring("Gets or sets a Boolean value that indicates whether the system policy configuration is in vendor mode"), hidden]
    HRESULT VendorMode([in] VARIANT_BOOL newVal);
	
	[id(17), helpstring("Connect to an enterprise using the specified configuration storage server on aspecific port")]
          HRESULT ConnectToConfigServerPort([in,defaultvalue("")] BSTR ConfigurationStorageServer,
              [in,defaultvalue("")] BSTR StorageUserName,
              [in,defaultvalue("")] BSTR StorageUserDomain,
              [in,defaultvalue("")] BSTR StorageUserPassword,
              [in,defaultvalue("")] BSTR MonitoringUserName,
              [in,defaultvalue("")] BSTR MonitoringUserDomain,
              [in,defaultvalue("")] BSTR MonitoringUserPassword,
              [in,defaultvalue(fpcRegularStorageConnection)] FpcStorageServerConnectionType eConnectionType,
              [in,defaultvalue(0)] long Port);
        
    
};
	
[
object,
uuid(8BF0AEFA-B4FD-4d81-8046-A069D948D673),
dual,
nonextensible,
helpstring("The root FPC object"),
pointer_default(unique)
]
interface IFPC3 : IFPC2
{
	[propget, id(18), helpstring("Gets a value from the FpcConfigurationMode enumerated type that indicates whether the Forefront TMG configuration defines a standalone server, a single array, or an enterprise with centrally managed arrays")]
    HRESULT ConfigurationMode([out, retval] FpcConfigurationMode *pVal);
	
	[id(19), helpstring("Joins an Array. The target COM Array must be connected with Array Administrator permissions.")]
          HRESULT JoinArray([in] IFPCArray3* pTargetArray);
        
    
	[id(20), helpstring("Leaves containing Array and becomes Standalone Server")]
          HRESULT LeaveArray([in] VARIANT_BOOL bResetArrayConfiguration);
        
    
	[id(21), helpstring("Sets the local computer as the new array manager")]
          HRESULT SetAsManager();
        
    
	[id(22), helpstring("Installs a server certificate for accessing the stored configuration on the local computer")]
          HRESULT ChangeManager([in] BSTR newVal);
        
    
	[id(23), helpstring("Installs a server certificate for accessing the stored configuration on the local computer")]
          HRESULT InstallManagementServerCertificate([in] BSTR ServerCertificatePath,
              [in] BSTR ServerCertificateExportPassword);
        
    
	[id(24), helpstring("Installs a root certification authority (CA) certificate on the local computer")]
          HRESULT InstallRootCaCertificate([in] BSTR RootCACertificatePath);
        
    
	[id(25), helpstring("Restore machine to standalone server"), hidden]
          HRESULT RestoreToStandalone();
        
    
	[id(26), helpstring("Apply changes"), hidden]
          HRESULT ApplyChangesWithDescription([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration,
              [in,defaultvalue(NULL)] BSTR ChangeDescription);
        
    
	[id(27), helpstring("Apply changes"), hidden]
          HRESULT SaveWithDescription([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration,
              [in,defaultvalue(NULL)] BSTR ChangeDescription);
        
    
};
	
[
object,
uuid(77798aae-6d48-455d-9ae6-825f8c0ef609),
dual,
helpstring("An enterprise object"),
pointer_default(unique)
]
interface IFPCEEEnterprise : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the enterprise")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the enterprise")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the description of the enterprise")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the description of the enterprise")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets the time the enterprise was created")]
    HRESULT CreatedTime([out, retval] DATE *pVal);
	
	[propget, id(3), helpstring("Gets the last time the enterprise was modified")]
    HRESULT LastModifiedTime([out, retval] DATE *pVal);
	
	[propget, id(4), helpstring("Gets the collection of policies within the enterprise object")]
    HRESULT Policies([out, retval] IFPCEEPolicies **pVal);
	
	[propget, id(5), helpstring("Gets an object that holds all rule elements for the enterprise")]
    HRESULT RuleElements([out, retval] IFPCRuleElements **pVal);
	
	[propget, id(6), helpstring("Gets an FPCExtensions object that represents application filters and Web filters")]
    HRESULT Extensions([out, retval] IFPCExtensions **pVal);
	
	[propget, id(7), helpstring("Gets an object that holds all network configuration settings for the enterprise")]
    HRESULT NetworkConfiguration([out, retval] IFPCNetworkConfiguration **pVal);
	
	[propget, id(8), helpstring("Get the security settings for the enterprise")]
    HRESULT AdminSecurity([out, retval] IFPCAdminSecurity **pVal);
	
};
	
[
object,
uuid(7889d23a-72b3-4caa-8b17-3f37b1085a05),
dual,
helpstring("An enterprise object"),
pointer_default(unique)
]
interface IFPCEnterprise2 : IFPCEEEnterprise
{
	[propget, id(9), helpstring("Gets or sets a Boolean value that indicates whether cross-array link translation is enabled in the enterprise")]
    HRESULT CrossArrayLinkTranslationEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(9), helpstring("Gets or sets a Boolean value that indicates whether cross-array link translation is enabled in the enterprise")]
    HRESULT CrossArrayLinkTranslationEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(10), helpstring("Gets or sets the version of Forefront TMG currently installed on the configuration storage server")]
    HRESULT ConfigurationStorageServerVersion([out, retval] FpcCompatibilityVersion *pVal);
    [propput, id(10), helpstring("Gets or sets the version of Forefront TMG currently installed on the configuration storage server")]
    HRESULT ConfigurationStorageServerVersion([in] FpcCompatibilityVersion newVal);
	
	[propget, id(11), helpstring("Gets or sets the lowest compatibility version of an array in the enterprise")]
    HRESULT MinArrayVersion([out, retval] FpcCompatibilityVersion *pVal);
    [propput, id(11), helpstring("Gets or sets the lowest compatibility version of an array in the enterprise")]
    HRESULT MinArrayVersion([in] FpcCompatibilityVersion newVal);
	
};
	
[
object,
uuid(79981f6c-69a7-47d4-930a-441e0fa5d14b),
dual,
nonextensible,
helpstring("An enterprise object"),
pointer_default(unique)
]
interface IFPCEnterprise3 : IFPCEnterprise2
{
	[propget, id(12), helpstring("Gets an FPCChangeTracking object that provides access to the change tracking settings and log for the enterprise")]
    HRESULT ChangeTracking([out, retval] IFPCChangeTracking **pVal);
	
};
	
[
object,
uuid(757df0fc-28e5-42bf-b9b6-b6ff1600acf1),
dual,
nonextensible,
helpstring("Collection of policies"),
pointer_default(unique)
]
interface IFPCEEPolicies : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCEEPolicy** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_REMOVE), helpstring("Removes a policy from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_ADD), helpstring("Adds a policy to the collection")]
          HRESULT Add( BSTR Name,
              [out,retval] IFPCEEPolicy** ppNewPolicy);
        
    
};
	
[
object,
uuid(1195daf2-3f12-4037-9b12-8ddcaacf0a3f),
dual,
helpstring("A policy object"),
pointer_default(unique)
]
interface IFPCEEPolicy : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the policy")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the policy")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the description of the policy")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the description of the policy")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets whether the policy is a preinstalled that cannot be deleted")]
    HRESULT Predefined([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(3), helpstring("Gets the time the enterprise was created")]
    HRESULT CreatedTime([out, retval] DATE *pVal);
	
	[propget, id(4), helpstring("Gets the last time the enterprise was modified")]
    HRESULT LastModifiedTime([out, retval] DATE *pVal);
	
	[propget, id(5), helpstring("Gets a collection of all policy rules in this policy")]
    HRESULT PolicyRules([out, retval] IFPCPolicyRules **pVal);
	
	[propget, id(6), helpstring("Get the security settings for the policy")]
    HRESULT AdminSecurity([out, retval] IFPCAdminSecurity **pVal);
	
};
	
[
object,
uuid(70c96803-f5d1-4b9d-9860-5fd4f5980452),
dual,
nonextensible,
helpstring("A policy object"),
pointer_default(unique)
]
interface IFPCPolicy2 : IFPCEEPolicy
{
	[propget, id(7), helpstring("Gets an FPCChangeTracking object that provides access to the change tracking settings and log for the enterprise")]
    HRESULT ChangeTracking([out, retval] IFPCChangeTracking **pVal);
	
};
	
[
object,
uuid(4556D105-AF67-481A-96B0-97549BCE5D64),
dual,
helpstring("Limits imposed on the number of transport-layer protocol connections allowed at one time for a user"),
pointer_default(unique)
]
interface IFPCConnectionLimit : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets the number of UDP connection mappings that are allowed for a user")]
    HRESULT UdpLimit([out, retval] long *pVal);
    [propput, id(1), helpstring("Gets or sets the number of UDP connection mappings that are allowed for a user")]
    HRESULT UdpLimit([in] long newVal);
	
	[propget, id(2), helpstring("Gets or sets the number of TCP connections that are allowed for a user")]
    HRESULT TcpLimit([out, retval] long *pVal);
    [propput, id(2), helpstring("Gets or sets the number of TCP connections that are allowed for a user")]
    HRESULT TcpLimit([in] long newVal);
	
	[propget, id(3), helpstring("Gets or sets the number of connections using transport-layer protocols other than TCP or UDP that are allowed for a user")]
    HRESULT OtherLimit([out, retval] long *pVal);
    [propput, id(3), helpstring("Gets or sets the number of connections using transport-layer protocols other than TCP or UDP that are allowed for a user")]
    HRESULT OtherLimit([in] long newVal);
	
};
	
[
object,
uuid(94A6E147-D423-4523-9147-B3D8874DCB97),
dual,
helpstring("Limits imposed on the number of connections or requests allowed per minute for a user"),
pointer_default(unique)
]
interface IFPCConnectionLimit2 : IFPCConnectionLimit
{
	[propget, id(4), helpstring("Gets or sets the number of TCP connections per minute that are allowed for a user")]
    HRESULT TcpLimitPerMinute([out, retval] long *pVal);
    [propput, id(4), helpstring("Gets or sets the number of TCP connections per minute that are allowed for a user")]
    HRESULT TcpLimitPerMinute([in] long newVal);
	
	[propget, id(5), helpstring("Gets or sets the number of HTTP requests per minute that are allowed for a user")]
    HRESULT HttpLimitPerMinute([out, retval] long *pVal);
    [propput, id(5), helpstring("Gets or sets the number of HTTP requests per minute that are allowed for a user")]
    HRESULT HttpLimitPerMinute([in] long newVal);
	
};
	
[
object,
uuid(dba17be8-b478-4bd2-9176-f4796bb98d71),
dual,
nonextensible,
helpstring("Limits imposed on the disk space that may be allocated for temporary storage for a session"),
pointer_default(unique)
]
interface IFPCConnectionLimit3 : IFPCConnectionLimit2
{
	[propget, id(6), helpstring("Gets or sets the maximum disk space, in megabytes, that may be allocated for temporary storage for a single client")]
    HRESULT ClientStorageLimitInMegs([out, retval] long *pVal);
    [propput, id(6), helpstring("Gets or sets the maximum disk space, in megabytes, that may be allocated for temporary storage for a single client")]
    HRESULT ClientStorageLimitInMegs([in] long newVal);
	
	[propget, id(7), helpstring("Gets or sets the maximum disk space, in megabytes, that may be allocated for temporary storage for a single client that has been granted the extended disk space storage limit")]
    HRESULT ClientExtendedStorageLimitInMegs([out, retval] long *pVal);
    [propput, id(7), helpstring("Gets or sets the maximum disk space, in megabytes, that may be allocated for temporary storage for a single client that has been granted the extended disk space storage limit")]
    HRESULT ClientExtendedStorageLimitInMegs([in] long newVal);
	
	[propget, id(8), helpstring("Gets or sets the maximum number of clients that may be granted the extended disk space storage limit concurrently")]
    HRESULT ClientExtendedStorageLimitPoolSize([out, retval] long *pVal);
    [propput, id(8), helpstring("Gets or sets the maximum number of clients that may be granted the extended disk space storage limit concurrently")]
    HRESULT ClientExtendedStorageLimitPoolSize([in] long newVal);
	
};
	
[
object,
uuid(0815E809-2878-4AD2-98E7-680D9236B8AE),
dual,
helpstring("Connection limit policy configuration"),
pointer_default(unique)
]
interface IFPCConnectionLimitPolicy : IFPCPersist
{
	[propget, id(1), helpstring("Gets an FPCConnectionLimit object that specifies the connection limits for a default user")]
    HRESULT DefaultLimit([out, retval] IFPCConnectionLimit **pVal);
	
	[propget, id(2), helpstring("Gets an FPCConnectionLimit object that specifies the connection limits for a special user")]
    HRESULT SpecialLimit([out, retval] IFPCConnectionLimit **pVal);
	
	[propget, id(3), helpstring("Gets the collection of computer sets to which the special limits apply")]
    HRESULT SpecialComputerSets([out, retval] IFPCRefs **pVal);
	
	[propget, id(4), helpstring("Gets or sets a Boolean value that indicates whether the connection limit policy is enabled")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(4), helpstring("Gets or sets a Boolean value that indicates whether the connection limit policy is enabled")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(5), helpstring("Gets or sets the maximum number of connections that can be created for a rule during one second")]
    HRESULT RulePerSecondLimit([out, retval] long *pVal);
    [propput, id(5), helpstring("Gets or sets the maximum number of connections that can be created for a rule during one second")]
    HRESULT RulePerSecondLimit([in] long newVal);
	
};
	
[
object,
uuid(ac7a5661-9768-448a-aa6a-fb1bd697cc37),
dual,
nonextensible,
helpstring("Connection limit policy configuration"),
pointer_default(unique)
]
interface IFPCConnectionLimitPolicy2 : IFPCConnectionLimitPolicy
{
	[propget, id(6), helpstring("Gets or sets a Boolean value that indicates whether traffic that exceeds a quota is logged")]
    HRESULT LogQuotaRejectedTraffic([out, retval] VARIANT_BOOL *pVal);
    [propput, id(6), helpstring("Gets or sets a Boolean value that indicates whether traffic that exceeds a quota is logged")]
    HRESULT LogQuotaRejectedTraffic([in] VARIANT_BOOL newVal);
	
	[propget, id(7), helpstring("Gets or sets the maximum value of packets from a specific IP address logged in a minute")]
    HRESULT LoggedDeniedPerMinute([out, retval] long *pVal);
    [propput, id(7), helpstring("Gets or sets the maximum value of packets from a specific IP address logged in a minute")]
    HRESULT LoggedDeniedPerMinute([in] long newVal);
	
	[propget, id(8), helpstring("Gets or sets the maximum value of deny log records per second")]
    HRESULT DenyLogPerSecondLimit([out, retval] long *pVal);
    [propput, id(8), helpstring("Gets or sets the maximum value of deny log records per second")]
    HRESULT DenyLogPerSecondLimit([in] long newVal);
	
};
	
[
object,
uuid(CFCEEC97-7BC5-4890-AA02-35E4E48304A6),
dual,
helpstring("An array object"),
pointer_default(unique)
]
interface IFPCArray : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the array")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the array")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the description of the array")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the description of the array")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets a set of flags that indicate the components that are installed in the array")]
    HRESULT Components([out, retval] long *pVal);
	
	[propget, id(3), helpstring("Gets the array's type, either array or stand-alone server")]
    HRESULT Type([out, retval] FpcArrayType *pVal);
	
	[propget, id(4), helpstring("Gets a major schema version of the array")]
    HRESULT AdminVersionMajor([out, retval] long *pVal);
	
	[propget, id(5), helpstring("Gets a minor schema version of the array")]
    HRESULT AdminVersionMinor([out, retval] long *pVal);
	
	[propget, id(6), helpstring("Gets the time the array was created")]
    HRESULT CreatedTime([out, retval] DATE *pVal);
	
	[propget, id(7), helpstring("Gets the last time the array was modified")]
    HRESULT LastModifiedTime([out, retval] DATE *pVal);
	
	[propget, id(8), helpstring("Gets a collection of all the alerts in the array")]
    HRESULT Alerts([out, retval] IFPCAlerts **pVal);
	
	[propget, id(9), helpstring("Gets a collection of all the connectivity verifiers in the array")]
    HRESULT ConnectivityVerifiers([out, retval] IFPCConnectivityVerifiers **pVal);
	
	[propget, id(10), helpstring("Gets an FPCServers collection that contains objects representing all the Forefront TMG computers in the array")]
    HRESULT Servers([out, retval] IFPCServers **pVal);
	
	[propget, id(11), helpstring("Gets an object that holds the array policy information for the array")]
    HRESULT ArrayPolicy([out, retval] IFPCArrayPolicy **pVal);
	
	[propget, id(12), helpstring("Gets an object that holds the system policy information for the array")]
    HRESULT SystemPolicy([out, retval] IFPCSystemPolicy **pVal);
	
	[propget, id(13), helpstring("Gets an object that holds all rule elements for the array")]
    HRESULT RuleElements([out, retval] IFPCRuleElements **pVal);
	
	[propget, id(14), helpstring("Gets an object that holds all cache configuration data for the array")]
    HRESULT Cache([out, retval] IFPCCache **pVal);
	
	[propget, id(15), helpstring("Gets an object that holds all log configurations for the array")]
    HRESULT Logging([out, retval] IFPCLogs **pVal);
	
	[propget, id(16), helpstring("Gets an object that holds all report jobs configuration and dailysum config for the array")]
    HRESULT Reports([out, retval] IFPCReports **pVal);
	
	[propget, id(17), helpstring("Gets an FPCExtensions object that represents application filters and Web filters")]
    HRESULT Extensions([out, retval] IFPCExtensions **pVal);
	
	[propget, id(18), helpstring("Gets an object that holds all network configuration settings for the array")]
    HRESULT NetworkConfiguration([out, retval] IFPCNetworkConfiguration **pVal);
	
	[propget, id(19), helpstring("Gets the Forefront TMG Client settings in an FPCClientConfigSettings collection")]
    HRESULT FWClientConfigSettings([out, retval] IFPCClientConfigSettings **pVal);
	
	[propget, id(20), helpstring("Get the security settings for the array")]
    HRESULT AdminSecurity([out, retval] IFPCAdminSecurity **pVal);
	
	[id(21), helpstring("Gets a list of services that must be restarted, and restart them under each server")]
          HRESULT RestartServices([in] FpcServices Services);
        
    
	[id(22), helpstring("Selects a network template and a default policy")]
          HRESULT SelectNetworkTemplateAndPolicy([in] BSTR networkTemplate,
              [in] BSTR defaultPolicy);
        
    
	[propget, id(23), helpstring("Gets a reference to the network template used by the firewall")]
    HRESULT NetworkTemplateUsed([out, retval] IFPCRef **pVal);
	
	[propget, id(24), helpstring("Gets or sets whether the ApplyChanges method is required"), hidden]
    HRESULT RequireApplyChanges([out, retval] VARIANT_BOOL *pVal);
    [propput, id(24), helpstring("Gets or sets whether the ApplyChanges method is required"), hidden]
    HRESULT RequireApplyChanges([in] VARIANT_BOOL newVal);
	
	[propget, id(25), helpstring("Gets whether changes have been made that would require the ApplyChanges method"), hidden]
    HRESULT ChangesMade([out, retval] VARIANT_BOOL *pVal);
	
	[id(26), helpstring("Apply changes"), hidden]
          HRESULT ApplyChanges([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(27), helpstring("Discard changes"), hidden]
          HRESULT DiscardChanges();
        
    
	[propget, id(28), helpstring("Gets the log viewer object")]
    HRESULT LogViewer([out, retval] IFPCLogViewer **pVal);
	
	[propget, id(29), helpstring("Gets the sessions viewer object")]
    HRESULT SessionsMonitors([out, retval] IFPCSessionsMonitors **pVal);
	
	[propget, id(30), helpstring("Gets or sets the mail code page of the array")]
    HRESULT MailCodePage([out, retval] long *pVal);
    [propput, id(30), helpstring("Gets or sets the mail code page of the array")]
    HRESULT MailCodePage([in] long newVal);
	
	[propget, id(31), helpstring("Gets the last sequential change number of the stored data"), hidden]
    HRESULT StorageChangeNumber([out, retval] __int64 *pVal);
	
};
	
[
object,
uuid(c8f368b7-a1cd-4681-9b71-7933cff0e5f5),
dual,
helpstring("An array object"),
pointer_default(unique)
]
interface IFPCEEArray : IFPCArray
{
	[propget, id(32), helpstring("Gets the policy assigment object")]
    HRESULT PolicyAssignment([out, retval] IFPCEEPolicyAssignment **pVal);
	
	[propget, id(33), helpstring("Gets the configuration storage server connection object")]
    HRESULT ConfigurationStorageServerConnection([out, retval] IFPCEEConfigurationStorageServerConnection **pVal);
	
	[id(34), helpstring("Wait until all servers reload the new configuration or failed to reload (must be called within same configuration storage server of the array)."), hidden]
          HRESULT WaitForReload();
        
    
	[propget, id(35), helpstring("Gets or sets whether use Forefront TMG computer account for intra array authentication")]
    HRESULT UseComputerAccountForIntraArrayAuthentication([out, retval] VARIANT_BOOL *pVal);
    [propput, id(35), helpstring("Gets or sets whether use Forefront TMG computer account for intra array authentication")]
    HRESULT UseComputerAccountForIntraArrayAuthentication([in] VARIANT_BOOL newVal);
	
	[propget, id(36), helpstring("Gets an FPCCredentials object used by the Forefront TMG computer to authenticate a connection to an array member server")]
    HRESULT IntraArrayCredentials([out, retval] IFPCCredentials **pVal);
	
	[propget, id(37), helpstring("Gets or sets the DNS name of the array")]
    HRESULT DNSName([out, retval] BSTR *pVal);
    [propput, id(37), helpstring("Gets or sets the DNS name of the array")]
    HRESULT DNSName([in] BSTR newVal);
	
	[propget, id(38), helpstring("Gets or sets the hidden flag for the array"), hidden]
    HRESULT Hidden([out, retval] VARIANT_BOOL *pVal);
    [propput, id(38), helpstring("Gets or sets the hidden flag for the array"), hidden]
    HRESULT Hidden([in] VARIANT_BOOL newVal);
	
	[id(39), helpstring("Copies specified array rule elements into the Enterprise")]
          HRESULT CopyElementsIntoEnterprise([in] long Elements);
        
    
};
	
[
object,
uuid(ec16ccf5-9da9-434b-be94-c2eb35a8828b),
dual,
helpstring("An array object"),
pointer_default(unique)
]
interface IFPCArray2 : IFPCEEArray
{
	[propget, id(40), helpstring("Gets the collection of cross-array settings objects for the array"), hidden]
    HRESULT CrossArraySettings([out, retval] IFPCCrossArraySettings **pVal);
	
	[propget, id(41), helpstring("Gets the globally unique identifier (GUID) of the current cross-array explicit link translation mappings"), hidden]
    HRESULT CrossArraySettingsChangeGuid([out, retval] BSTR *pVal);
	
	[propget, id(42), helpstring("Gets or sets the minimum version of an object or Forefront TMG Management that may access this array object")]
    HRESULT CompatibilityVersion([out, retval] FpcCompatibilityVersion *pVal);
    [propput, id(42), helpstring("Gets or sets the minimum version of an object or Forefront TMG Management that may access this array object")]
    HRESULT CompatibilityVersion([in] FpcCompatibilityVersion newVal);
	
};
	
[
object,
uuid(31077cf9-2189-4bff-b1e5-50cc8e2c7a93),
dual,
helpstring("An array object"),
pointer_default(unique)
]
interface IFPCArray3 : IFPCArray2
{
	[propget, id(43), helpstring("Gets an FPCMalwareInspectionSettings object that holds the malware inspection settings for the array")]
    HRESULT MalwareInspectionSettings([out, retval] IFPCMalwareInspectionSettings **pVal);
	
	[propget, id(45), helpstring("Gets an FPCUpdateCenter object that represents the update center for the array")]
    HRESULT UpdateCenter([out, retval] IFPCUpdateCenter **pVal);
	
	[id(46), helpstring("Gets an FPCActivityStatistics object that contains statistics concerning the activity of a Forefront TMG array")]
          HRESULT GetActivityStatistics([in] FpcActivityStatisticsPeriodType PeriodType,
              [in] DATE PeriodStart,
              [in] DATE PeriodEnd,
              [out,retval] IFPCActivityStatistics** pVal);
        
    
	[propget, id(47), helpstring("Gets an FPCStaticRoutes collection that holds the static routes for the array"), hidden]
    HRESULT StaticRoutes([out, retval] IFPCStaticRoutes **pVal);
	
	[propget, id(49), helpstring("Gets or sets a value from the FpcSpyNetLevel enumerated type that indicates the level at which SpyNet integration is enabled")]
    HRESULT SpyNetLevel([out, retval] FpcSpyNetLevel *pVal);
    [propput, id(49), helpstring("Gets or sets a value from the FpcSpyNetLevel enumerated type that indicates the level at which SpyNet integration is enabled")]
    HRESULT SpyNetLevel([in] FpcSpyNetLevel newVal);
	
	[propget, id(50), helpstring("Gets a Boolean value that indicates whether the array is joined to an enterprise")]
    HRESULT IsJoinedToEnterprise([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(51), helpstring("Gets or sets a Boolean value that indicates whether a separate thread will be created for each connectivity verifier that sends HTTP GET requests to check connectivity")]
    HRESULT CreateThreadPerHttpVerifier([out, retval] VARIANT_BOOL *pVal);
    [propput, id(51), helpstring("Gets or sets a Boolean value that indicates whether a separate thread will be created for each connectivity verifier that sends HTTP GET requests to check connectivity")]
    HRESULT CreateThreadPerHttpVerifier([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(21cf437a-1476-46b7-b6e1-502c30b856f3),
dual,
nonextensible,
helpstring("An array object"),
pointer_default(unique)
]
interface IFPCArray4 : IFPCArray3
{
	[propget, id(52), helpstring("Gets an FPCSmtpProtectionConfiguration object that holds the SMTP protection settings for the array")]
    HRESULT SmtpProtectionConfiguration([out, retval] IFPCSmtpProtectionConfiguration **pVal);
	
	[propget, id(53), helpstring("Gets an FPCSecurityAssessmentSharing object that holds the security assessment sharing settings for the array")]
    HRESULT SecurityAssessmentSharing([out, retval] IFPCSecurityAssessmentSharing **pVal);
	
	[propget, id(54), helpstring("Gets an FPCNetworkInspectionSystem object that represents the network inspection system configuration")]
    HRESULT NetworkInspectionSystem([out, retval] IFPCNetworkInspectionSystem **pVal);
	
	[propget, id(55), helpstring("Gets an FPCChangeTracking object that provides access to the change tracking settings and log for the array")]
    HRESULT ChangeTracking([out, retval] IFPCChangeTracking **pVal);
	
	[id(56), helpstring("Apply changes"), hidden]
          HRESULT ApplyChangesWithDescription([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration,
              [in,defaultvalue(NULL)] BSTR ChangeDescription);
        
    
	[id(57), helpstring("Apply changes"), hidden]
          HRESULT SaveWithDescription([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration,
              [in,defaultvalue(NULL)] BSTR ChangeDescription);
        
    
	[id(58), helpstring("Update Array Type property to Enterprise"), hidden]
          HRESULT UpdateArrayType([in] FpcArrayType ArrayType);
        
    
	[id(59), helpstring("Gets an FPCDashboardPerformanceCounters object that contains statistics concerning the activity of a Forefront TMG array")]
          HRESULT GetProtectionCounters([out,retval] IFPCDashboardPerformanceCounters** pVal);
        
    
	[id(60), helpstring("Checks if SecurityAssessmentSharing is supported"), hidden]
          HRESULT IsSecurityAssessmentSharingSupported([out,retval] VARIANT_BOOL* pbRetVal);
        
    
	[id(61), helpstring("Checks if specified external component is installed on all servers in the Forefront TMG array")]
          HRESULT IsExternalComponentInstalled([in] BSTR ExternalComponentGuid,
              [out,retval] VARIANT_BOOL* pbRetVal);
        
    
};
	
[
object,
uuid(9257DD24-2EC5-48DC-8F16-A21AD9CEC272),
dual,
helpstring("Collection of arrays"),
pointer_default(unique)
]
interface IFPCArrays : IDispatch
{
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCArray** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Connect to an array of the specified server and add it to the collection")]
          HRESULT Connect( BSTR ServerName,
              [in,defaultvalue("")] BSTR bstrUserName,
              [in,defaultvalue("")] BSTR bstrDomain,
              [in,defaultvalue("")] BSTR bstrPassword,
              [out,retval] IFPCArray** pItem);
        
    
	[id(DISPID_REMOVE), helpstring("Disconnects from the array")]
          HRESULT Disconnect([in] IFPCArray* pItem);
        
    
};
	
[
object,
uuid(68bdd6c8-369a-47fb-a54d-61ec706221cd),
dual,
helpstring("Collection of arrays"),
pointer_default(unique)
]
interface IFPCEEArrays : IFPCArrays
{
	[id(1), helpstring("Adds an array to the enterprise")]
          HRESULT Add([in] BSTR Name,
              [in,defaultvalue("")] BSTR Guid,
              [in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL SaveImmediately,
              [out,retval] IFPCArray** ppNewArray);
        
    
	[id(2), helpstring("Removes an array from the enterprise")]
          HRESULT Remove([in] VARIANT v);
        
    
	[id(3), helpstring("Adds an array to the enterprise"), hidden, local]
          HRESULT AddInternal([in] BSTR Name,
              [in,defaultvalue("")] BSTR Guid,
              [in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL SaveImmediately,
              [in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL UpgradeContext,
              [in,defaultvalue(0)] HANDLE_PTR Progress,
              [out,retval] IFPCArray** ppNewArray);
        
    
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh([in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL ArrayInfoOnly);
        
    
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
};
	
[
object,
uuid(8657AAA9-6C9B-4cea-8DE4-7CF8EB29CA47),
dual,
nonextensible,
helpstring("Collection of arrays"),
pointer_default(unique)
]
interface IFPCArrays2 : IFPCEEArrays
{
	[id(DISPID_EXPORT), helpstring("Writes the stored values of all of the object's properties to the specified XML document.")]
          HRESULT Export([in] IUnknown* pDocument,
              [in] long OptionalData,
              [in,defaultvalue(NULL)] BSTR EncryptionPassword,
              [in,defaultvalue(NULL)] BSTR Comment);
        
    
	[id(DISPID_IMPORT), helpstring("Copies the values of all of the object's properties from the specified XML document to persistent storage.")]
          HRESULT Import([in] IUnknown* pDocument,
              [in] long OptionalData,
              [in,defaultvalue(NULL)] BSTR EncryptionPassword,
              [in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL CleanCollections,
              [in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_EXPORT_FILE), helpstring("Writes the stored values of all of the object's properties to the specified XML file.")]
          HRESULT ExportToFile([in] BSTR XmlFileName,
              [in] long OptionalData,
              [in,defaultvalue(NULL)] BSTR EncryptionPassword,
              [in,defaultvalue(NULL)] BSTR Comment);
        
    
	[id(DISPID_IMPORT_FILE), helpstring("Copies the values of all of the object's properties from the specified XML file to persistent storage.")]
          HRESULT ImportFromFile([in] BSTR XmlFileName,
              [in] long OptionalData,
              [in,defaultvalue(NULL)] BSTR EncryptionPassword,
              [in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL CleanCollections,
              [in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_CANIMPORT), helpstring("Returns a Boolean value that indicates whether the object's properties can be imported from the specified XML document.")]
          HRESULT CanImport([in] IUnknown* pDocument,
              [in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL bValidateSchema,
              [out,retval] VARIANT_BOOL* pbRetVal);
        
    
};
	
[
hidden,
object,
uuid(a96526bf-fddb-4941-8e16-44900e1fb751),
dual,
nonextensible,
helpstring("A collection of cross-array settings objects"),
pointer_default(unique)
]
interface IFPCCrossArraySettings : IDispatch
{
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Retrieves a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCCrossArray** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[propget, id(1), helpstring("Gets a Boolean value that indicates whether cross-array link translation is enabled for both the enterprise and the containing array")]
    HRESULT CrossArrayLinkTranslationEnabled([out, retval] VARIANT_BOOL *pVal);
	
};
	
[
hidden,
object,
uuid(d286ce25-99fa-4640-b199-916651859942),
dual,
nonextensible,
helpstring("An cross-array settings object for another array in the enterprise"),
pointer_default(unique)
]
interface IFPCCrossArray : IDispatch
{
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[propget, id(DISPID_VALUE), helpstring("Gets the name of the array")]
    HRESULT Name([out, retval] BSTR *pVal);
	
	[propget, id(DISPID_PERSISTENTNAME), helpstring("Gets the persistent name of the object. The persistent name of an object is a name that is unique for the object at the respective level of the COM object hierarchy.")]
    HRESULT PersistentName([out, retval] BSTR *pVal);
	
	[propget, id(1), helpstring("Gets a Boolean value that indicates whether cross-array link translation is enabled for the array")]
    HRESULT CrossArrayLinkTranslationEnabled([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(2), helpstring("Gets the cross-array link translation priority")]
    HRESULT CrossArrayLinkTranslationPriority([out, retval] long *pVal);
	
	[propget, id(3), helpstring("Gets the globally unique identifier (GUID) of the current cross-array link translation mappings")]
    HRESULT CrossArraySettingsChangeGuid([out, retval] BSTR *pVal);
	
	[propget, id(4), helpstring("Gets the implicit mappings collection for the cross-array")]
    HRESULT CrossArrayImplicitMappings([out, retval] IFPCCrossArrayImplicitMappings **pVal);
	
	[propget, id(5), helpstring("Gets a collection of explicit link translation mappings")]
    HRESULT ExplicitLinkTranslationMappings([out, retval] IFPCExplicitLinkTranslationMappings **pVal);
	
};
	
[
hidden,
object,
uuid(ccc3346e-ef67-498e-81e6-d5f7cd6382dd),
dual,
nonextensible,
helpstring("Implicit mappings collection for a cross cross-array"),
pointer_default(unique)
]
interface IFPCCrossArrayImplicitMappings : IDispatch
{
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Retrieves a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCCrossArrayImplicitMapping** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

};
	
[
hidden,
object,
uuid(f85b2764-5267-4e55-b2cd-5f4fb29bd94d),
dual,
nonextensible,
helpstring("An implicit mapping object"),
pointer_default(unique)
]
interface IFPCCrossArrayImplicitMapping : IDispatch
{
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[propget, id(DISPID_VALUE), helpstring("Gets the name of the rule")]
    HRESULT Name([out, retval] BSTR *pVal);
	
	[propget, id(1), helpstring("Gets the ordinal position of the rule in the order of execution")]
    HRESULT Order([out, retval] long *pVal);
	
	[propget, id(2), helpstring("Gets the GUID of the Web listener used for the rule")]
    HRESULT WebListenerGuid([out, retval] BSTR *pVal);
	
	[propget, id(3), helpstring("Gets the TCP port")]
    HRESULT TCPPort([out, retval] long *pVal);
	
	[propget, id(4), helpstring("Gets the SSL port")]
    HRESULT SSLPort([out, retval] long *pVal);
	
	[propget, id(5), helpstring("Gets the SSL accelerator port")]
    HRESULT SSLAcceleratorPort([out, retval] long *pVal);
	
	[propget, id(6), helpstring("Gets the internal name of a web server")]
    HRESULT InternalName([out, retval] BSTR *pVal);
	
	[propget, id(7), helpstring("Gets the type of published server to which the rule applies")]
    HRESULT PublishedServerType([out, retval] FpcPublishedServerType *pVal);
	
	[propget, id(8), helpstring("Gets the port for redirecting requests that are redirected as HTTP requests")]
    HRESULT HTTPRedirectPort([out, retval] long *pVal);
	
	[propget, id(9), helpstring("Gets the port for redirecting requests that are redirected as SSL requests")]
    HRESULT SSLRedirectPort([out, retval] long *pVal);
	
	[propget, id(10), helpstring("Gets or sets a value from the FpcRedirectHTTPAsHTTPS enumerated type that specifies whether the Web proxy should redirect HTTP requests to HTTPS")]
    HRESULT RedirectHTTPAsHTTPS([out, retval] FpcRedirectHTTPAsHTTPS *pVal);
	
	[propget, id(11), helpstring("Gets a Boolean value that indicates whether Forefront TMG sends the original host header")]
    HRESULT SendOriginalHostHeader([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(12), helpstring("Gets a Boolean value that indicates whether links are translated to the public names recognized by the rule")]
    HRESULT TranslateLinks([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(13), helpstring("Gets a Boolean value that indicates whether any public name that resolves to the IP address of the internal Web site will be accepted in incoming requests")]
    HRESULT AllPublicNames([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(14), helpstring("Gets an FPCPublicNames collection that contains the public DNS names and IP addresses that are mapped by the rule to the name or IP address of the published Web server")]
    HRESULT PublicNames([out, retval] IFPCPublicNames **pVal);
	
	[propget, id(15), helpstring("Gets the collection that maps published Web site names to the internal path of the Web site")]
    HRESULT PathMappings([out, retval] IFPCPathMappings **pVal);
	
	[propget, id(16), helpstring("Gets a Boolean value that indicates whether a secure channel is required")]
    HRESULT SSLRequireSecureChannel([out, retval] FpcSSLRequireSecureChannelMode *pVal);
	
};
	
[
object,
uuid(852e0e54-b06c-4424-943c-32fdba02af91),
dual,
helpstring("Policy assignment configuration object"),
pointer_default(unique)
]
interface IFPCEEPolicyAssignment : IFPCPersist
{
	[id(1), helpstring("Sets the enterprise policy to which the array applies")]
          HRESULT SetEnterprisePolicy([in] BSTR EnterprisePolicyName);
        
    
	[propget, id(2), helpstring("Gets a reference to the enterprise policy used by the array")]
    HRESULT EnterprisePolicyUsed([out, retval] IFPCRef **pVal);
	
	[propget, id(3), helpstring("Gets or sets whether deny rules are enabled for the array policy")]
    HRESULT EnableDenyRules([out, retval] VARIANT_BOOL *pVal);
    [propput, id(3), helpstring("Gets or sets whether deny rules are enabled for the array policy")]
    HRESULT EnableDenyRules([in] VARIANT_BOOL newVal);
	
	[propget, id(4), helpstring("Gets or sets whether allow rules are enabled for the array policy")]
    HRESULT EnableAllowRules([out, retval] VARIANT_BOOL *pVal);
    [propput, id(4), helpstring("Gets or sets whether allow rules are enabled for the array policy")]
    HRESULT EnableAllowRules([in] VARIANT_BOOL newVal);
	
	[propget, id(5), helpstring("Gets or sets whether publishing rules are enabled for the array policy")]
    HRESULT EnablePublishingRules([out, retval] VARIANT_BOOL *pVal);
    [propput, id(5), helpstring("Gets or sets whether publishing rules are enabled for the array policy")]
    HRESULT EnablePublishingRules([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(7de6f15c-17a0-40e8-aabd-5f409f0efe9c),
dual,
nonextensible,
helpstring("Policy assignment configuration object"),
pointer_default(unique)
]
interface IFPCPolicyAssignment2 : IFPCEEPolicyAssignment
{
	[propget, id(6), helpstring("Gets or sets a Boolean value that indicates whether cross-array link translation is enabled for this array")]
    HRESULT CrossArrayLinkTranslationEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(6), helpstring("Gets or sets a Boolean value that indicates whether cross-array link translation is enabled for this array")]
    HRESULT CrossArrayLinkTranslationEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(7), helpstring("Gets or sets the cross-array link translation priority"), hidden]
    HRESULT CrossArrayLinkTranslationPriority([out, retval] long *pVal);
    [propput, id(7), helpstring("Gets or sets the cross-array link translation priority"), hidden]
    HRESULT CrossArrayLinkTranslationPriority([in] long newVal);
	
};
	
[
object,
uuid(ba93027c-bd1d-45ee-a56e-c67fe62f06ff),
dual,
helpstring("Enterprise configuration storage server connection object"),
pointer_default(unique)
]
interface IFPCEEConfigurationStorageServerConnection : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets the primary configuration storage server for the array")]
    HRESULT PrimaryConfigurationStorageServer([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the primary configuration storage server for the array")]
    HRESULT PrimaryConfigurationStorageServer([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets the alternate configuration storage server for the array")]
    HRESULT AlternateConfigurationStorageServer([out, retval] BSTR *pVal);
    [propput, id(2), helpstring("Gets or sets the alternate configuration storage server for the array")]
    HRESULT AlternateConfigurationStorageServer([in] BSTR newVal);
	
	[propget, id(3), helpstring("Gets or sets the time (in minutes) after which the array will start using the other configuration storage server when the current Configuration Server is unavailable")]
    HRESULT FallbackDelay([out, retval] long *pVal);
    [propput, id(3), helpstring("Gets or sets the time (in minutes) after which the array will start using the other configuration storage server when the current Configuration Server is unavailable")]
    HRESULT FallbackDelay([in] long newVal);
	
	[propget, id(4), helpstring("Gets or sets the time (in minutes) after which the array will start testing connectivity with the primary configuration storage server when using the alternate configuration storage server")]
    HRESULT PrimaryTestingDelay([out, retval] long *pVal);
    [propput, id(4), helpstring("Gets or sets the time (in minutes) after which the array will start testing connectivity with the primary configuration storage server when using the alternate configuration storage server")]
    HRESULT PrimaryTestingDelay([in] long newVal);
	
	[propget, id(5), helpstring("Gets or sets the time (in minutes) during which the primary configuration storage server must be continuously available before the array will return to it")]
    HRESULT PrimaryStabilizationDelay([out, retval] long *pVal);
    [propput, id(5), helpstring("Gets or sets the time (in minutes) during which the primary configuration storage server must be continuously available before the array will return to it")]
    HRESULT PrimaryStabilizationDelay([in] long newVal);
	
	[propget, id(6), helpstring("Gets or sets the configuration storage server connection type of the array")]
    HRESULT ConfigurationStorageServerConnectionType([out, retval] FpcConfigurationStorageServerConnectionType *pVal);
    [propput, id(6), helpstring("Gets or sets the configuration storage server connection type of the array")]
    HRESULT ConfigurationStorageServerConnectionType([in] FpcConfigurationStorageServerConnectionType newVal);
	
	[propget, id(7), helpstring("Gets or sets the time interval (in seconds) that each array member will wait before checking the configuration storage server for configuration changes again")]
    HRESULT ChangePollRate([out, retval] long *pVal);
    [propput, id(7), helpstring("Gets or sets the time interval (in seconds) that each array member will wait before checking the configuration storage server for configuration changes again")]
    HRESULT ChangePollRate([in] long newVal);
	
	[propget, id(8), helpstring("Gets or sets the time interval (in seconds) that each array member will wait before checking the configuration storage server for configuration changes again after detecting a change"), hidden]
    HRESULT QuietPollRate([out, retval] long *pVal);
    [propput, id(8), helpstring("Gets or sets the time interval (in seconds) that each array member will wait before checking the configuration storage server for configuration changes again after detecting a change"), hidden]
    HRESULT QuietPollRate([in] long newVal);
	
	[propget, id(9), helpstring("Gets or sets the time interval (in seconds) that each array member will wait before checking again for connectivity with the configuration storage server after being disconnected from it"), hidden]
    HRESULT ReconnectPollRate([out, retval] long *pVal);
    [propput, id(9), helpstring("Gets or sets the time interval (in seconds) that each array member will wait before checking again for connectivity with the configuration storage server after being disconnected from it"), hidden]
    HRESULT ReconnectPollRate([in] long newVal);
	
	[propget, id(10), helpstring("Gets or sets the time interval (in seconds) that each array member will wait before checking the configuration storage server for configuration changes again after an error occurs"), hidden]
    HRESULT ErrorRecoveryPollRate([out, retval] long *pVal);
    [propput, id(10), helpstring("Gets or sets the time interval (in seconds) that each array member will wait before checking the configuration storage server for configuration changes again after an error occurs"), hidden]
    HRESULT ErrorRecoveryPollRate([in] long newVal);
	
	[propget, id(11), helpstring("Gets or sets the minimum time interval (in seconds) that each array member will wait after each change in the configuration storage server before applying the new configuration if no additional changes occur"), hidden]
    HRESULT QuietThreshold([out, retval] long *pVal);
    [propput, id(11), helpstring("Gets or sets the minimum time interval (in seconds) that each array member will wait after each change in the configuration storage server before applying the new configuration if no additional changes occur"), hidden]
    HRESULT QuietThreshold([in] long newVal);
	
	[propget, id(12), helpstring("Gets or sets the maximum time interval (in seconds) that each array member will wait after each change in the configuration storage server before applying the new configuration if additional changes occur"), hidden]
    HRESULT NoiseThreshold([out, retval] long *pVal);
    [propput, id(12), helpstring("Gets or sets the maximum time interval (in seconds) that each array member will wait after each change in the configuration storage server before applying the new configuration if additional changes occur"), hidden]
    HRESULT NoiseThreshold([in] long newVal);
	
};
	
[
object,
uuid(dd04f2cd-7f12-4848-ad60-7150d62488c1),
dual,
nonextensible,
helpstring("Enterprise configuration storage server connection object"),
pointer_default(unique)
]
interface IFPCConfigurationStorageServerConnection2 : IFPCEEConfigurationStorageServerConnection
{
	[propget, id(13), helpstring("Gets or sets the backup configuration storage server for recovering from VPN tunnel issues")]
    HRESULT VpnBackupStorageServer([out, retval] BSTR *pVal);
    [propput, id(13), helpstring("Gets or sets the backup configuration storage server for recovering from VPN tunnel issues")]
    HRESULT VpnBackupStorageServer([in] BSTR newVal);
	
	[propget, id(14), helpstring("Gets or sets whether the primary configuration storage server connection is over a vpn tunnel")]
    HRESULT ConnectionOverVPNTunnel([out, retval] VARIANT_BOOL *pVal);
    [propput, id(14), helpstring("Gets or sets whether the primary configuration storage server connection is over a vpn tunnel")]
    HRESULT ConnectionOverVPNTunnel([in] VARIANT_BOOL newVal);
	
	[propget, id(15), helpstring("Gets or sets the time interval (in seconds) that each array member will wait between attempts to reload a configuration when the connection is over VPN"), hidden]
    HRESULT VpnConnectionReloadRate([out, retval] long *pVal);
    [propput, id(15), helpstring("Gets or sets the time interval (in seconds) that each array member will wait between attempts to reload a configuration when the connection is over VPN"), hidden]
    HRESULT VpnConnectionReloadRate([in] long newVal);
	
};
	
[
object,
uuid(D724D58E-C894-4306-8DB2-10CED660C7D2),
dual,
nonextensible,
helpstring("Cache configuration settings object"),
pointer_default(unique)
]
interface IFPCCache : IFPCPersist
{
	[propget, id(1), helpstring("Gets an object that provides access to the cache configuration")]
    HRESULT CacheConfiguration([out, retval] IFPCCacheConfiguration **pVal);
	
	[propget, id(2), helpstring("Gets an object for reading the contents of the cache")]
    HRESULT CacheContents([out, retval] IFPCCacheContents **pVal);
	
	[propget, id(3), helpstring("Gets a scheduled content download collection")]
    HRESULT ScheduledContentDownload([out, retval] IFPCScheduledContentDownload **pVal);
	
};
	
[
object,
uuid(7CF68D01-7EBB-40E6-9431-2B7D09C2DE8F),
dual,
nonextensible,
helpstring("Collection of extensions"),
pointer_default(unique)
]
interface IFPCExtensions : IFPCPersist
{
	[propget, id(1), helpstring("Gets an FPCApplicationFilters collection of application filters")]
    HRESULT ApplicationFilters([out, retval] IFPCApplicationFilters **pVal);
	
	[propget, id(2), helpstring("Gets an FPCWebFilters collection of Web filters")]
    HRESULT WebFilters([out, retval] IFPCWebFilters **pVal);
	
};
	
[
object,
uuid(46DCEB90-D8C7-46A9-9400-64D28328A2D2),
dual,
helpstring("Collection of policy elements"),
pointer_default(unique)
]
interface IFPCRuleElements : IFPCPersist
{
	[propget, id(1), helpstring("Gets a collection of all schedules in the array")]
    HRESULT Schedules([out, retval] IFPCSchedules **pVal);
	
	[propget, id(2), helpstring("Gets a collection of computers in the array")]
    HRESULT Computers([out, retval] IFPCComputers **pVal);
	
	[propget, id(3), helpstring("Gets a collection of address ranges in the array")]
    HRESULT AddressRanges([out, retval] IFPCAddressRanges **pVal);
	
	[propget, id(4), helpstring("Gets a collection of subnets in the array")]
    HRESULT Subnets([out, retval] IFPCSubnets **pVal);
	
	[propget, id(5), helpstring("Gets a collection of computer sets in the array")]
    HRESULT ComputerSets([out, retval] IFPCComputerSets **pVal);
	
	[propget, id(6), helpstring("Gets a collection of URL sets in the array")]
    HRESULT URLSets([out, retval] IFPCURLSets **pVal);
	
	[propget, id(7), helpstring("Gets a collection of domain name sets in the array")]
    HRESULT DomainNameSets([out, retval] IFPCDomainNameSets **pVal);
	
	[propget, id(8), helpstring("Gets a collection of Firewall service protocols")]
    HRESULT ProtocolDefinitions([out, retval] IFPCProtocolDefinitions **pVal);
	
	[propget, id(9), helpstring("Gets a collection of events")]
    HRESULT EventDefinitions([out, retval] IFPCEventDefinitions **pVal);
	
	[propget, id(11), helpstring("Gets a collection of WebListeners in the array")]
    HRESULT WebListeners([out, retval] IFPCWebListeners **pVal);
	
	[propget, id(12), helpstring("Gets a collection of all content type sets in the array")]
    HRESULT ContentTypeSets([out, retval] IFPCContentTypeSets **pVal);
	
	[propget, id(13), helpstring("Gets a collection of user sets in the array")]
    HRESULT UserSets([out, retval] IFPCUserSets **pVal);
	
	[propget, id(14), helpstring("Gets a collection of authentication schemes in the array")]
    HRESULT AuthenticationSchemes([out, retval] IFPCAuthenticationSchemes **pVal);
	
	[propget, id(15), helpstring("Gets a collection of RADIUS servers in the array")]
    HRESULT RadiusServers([out, retval] IFPCRadiusServers **pVal);
	
};
	
[
object,
uuid(A240E9AA-331A-49d1-BC94-70FCBAB75D71),
dual,
helpstring("Collection of policy elements"),
pointer_default(unique)
]
interface IFPCRuleElements2 : IFPCRuleElements
{
	[propget, id(16), helpstring("Gets a collection of server farms")]
    HRESULT ServerFarms([out, retval] IFPCServerFarms **pVal);
	
	[propget, id(17), helpstring("Gets the collection of mappings between User-Agent headers and sets of forms for forms-based authentication"), hidden]
    HRESULT UserAgentMappings([out, retval] IFPCUserAgentMappings **pVal);
	
	[propget, id(18), helpstring("Gets a collection of LDAP servers lists in the array")]
    HRESULT LdapServersSets([out, retval] IFPCLdapServersSets **pVal);
	
	[propget, id(19), helpstring("Gets a collection of LDAP matching patterns in the array")]
    HRESULT LdapMatchingPatterns([out, retval] IFPCLdapMatchingPatterns **pVal);
	
};
	
[
object,
uuid(EDE22DDB-39BB-47F4-BD68-01663982BE30),
dual,
helpstring("Collection of policy elements"),
pointer_default(unique)
]
interface IFPCRuleElements3 : IFPCRuleElements2
{
	[propget, id(20), helpstring("Gets an FPCUrlCategories collection that contains the URL categories defined in the array")]
    HRESULT UrlCategories([out, retval] IFPCUrlCategories **pVal);
	
	[propget, id(21), helpstring("Gets an IFPCUrlCategorySets collection that contains the URL category sets defined in the array")]
    HRESULT UrlCategorySets([out, retval] IFPCUrlCategorySets **pVal);
	
};
	
[
object,
uuid(37638A73-DC37-47A1-BC05-9F61A7E72A29),
dual,
nonextensible,
helpstring("Collection of policy elements"),
pointer_default(unique)
]
interface IFPCRuleElements4 : IFPCRuleElements3
{
	[propget, id(22), helpstring("Gets an FPCPolicyGroups collection that contains the policy groups defined in the array")]
    HRESULT PolicyGroups([out, retval] IFPCPolicyGroups **pVal);
	
	[id(23), helpstring("Finds matched elements")]
          HRESULT FindMatchedElements([in] BSTR searchCriteria, [out, retval] BSTR *pMatchedElements);
        
    
};
	
[
object,
uuid(A1BD31EB-CFA5-4B0C-B412-390D35236169),
dual,
helpstring("Network configuration"),
pointer_default(unique)
]
interface IFPCNetworkConfiguration : IFPCPersist
{
	[propget, id(1), helpstring("Gets an object that defines Firewall service chaining")]
    HRESULT FirewallChaining([out, retval] IFPCFirewallChaining **pVal);
	
	[propget, id(3), helpstring("Gets a collection of routing rules")]
    HRESULT RoutingRules([out, retval] IFPCRoutingRules **pVal);
	
	[propget, id(4), helpstring("Gets a collection of networks")]
    HRESULT Networks([out, retval] IFPCNetworks **pVal);
	
	[propget, id(5), helpstring("Gets a collection of network rules")]
    HRESULT NetworkRules([out, retval] IFPCNetworkRules **pVal);
	
	[propget, id(6), helpstring("Gets a reference to a FPCVpnConfiguration object that defines VPN tunnel settings")]
    HRESULT VpnConfiguration([out, retval] IFPCVpnConfiguration **pVal);
	
	[propget, id(7), helpstring("Gets a collection of network sets")]
    HRESULT NetworkSets([out, retval] IFPCNetworkSets **pVal);
	
	[propget, id(8), helpstring("Gets a collection of network templates")]
    HRESULT NetworkTemplates([out, retval] IFPCNetworkTemplates **pVal);
	
	[propget, id(9), helpstring("Gets an object that defines Firewall service dialing")]
    HRESULT DialingConfiguration([out, retval] IFPCDialingConfiguration **pVal);
	
};
	
[
object,
uuid(ae8e372a-0cd8-468a-9639-f45c26d7edab),
dual,
nonextensible,
helpstring("Network configuration"),
pointer_default(unique)
]
interface IFPCEENetworkConfiguration : IFPCNetworkConfiguration
{
	[propget, id(10), helpstring("Gets a reference to a FPCNLBConfiguration object that stores all NLB related configuration")]
    HRESULT NLBConfiguration([out, retval] IFPCEENLBConfiguration **pVal);
	
	[propget, id(11), helpstring("Gets a collection of enterprise networks")]
    HRESULT EnterpriseNetworks([out, retval] IFPCEEEnterpriseNetworks **pVal);
	
};
	
[
object,
uuid(36AC4511-2E71-42CF-905B-FD5F65A262FE),
dual,
helpstring("Collection of servers"),
pointer_default(unique)
]
interface IFPCServers : IFPCPersist
{
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCServer** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

};
	
[
object,
uuid(c554470f-4390-4357-8ce6-d147911f07bc),
dual,
nonextensible,
helpstring("Collection of servers"),
pointer_default(unique)
]
interface IFPCEEServers : IFPCServers
{
	[id(1), helpstring("Removes a server from the array")]
          HRESULT Remove( VARIANT v);
        
    
	[id(2), helpstring("Deletes the last server object without removing the array."), hidden]
          HRESULT RemoveInternal( VARIANT v);
        
    
};
	
[
object,
uuid(5680AF42-605F-4A39-8DFA-6E43FD8F581A),
dual,
helpstring("Collection of certificates stored on the Forefront TMG computer"),
pointer_default(unique)
]
interface IFPCCertificates : IDispatch
{
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( long Index,
              [out,retval] IFPCCertificate** ppCertificate);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

};
	
[
object,
uuid(7c379d22-9592-45b8-9c99-8349d92386b9),
dual,
nonextensible,
helpstring("Collection of certificates stored on the Forefront TMG computer"),
pointer_default(unique)
]
interface IFPCCertificates2 : IFPCCertificates
{
	[propget, id(1), helpstring("Gets a value from the FpcCertificatesCollectionStatus enumerated type that specifies the status of the certificates collection")]
    HRESULT Status([out, retval] FpcCollectionStatus *pVal);
	
};
	
[
object,
uuid(4D69DE0C-9221-48DB-8ACC-8C0086C23F92),
dual,
helpstring("A certificate stored on the Forefront TMG computer"),
pointer_default(unique)
]
interface IFPCCertificate : IDispatch
{
	[propget, id(1), helpstring("Gets the hash value of the certificate")]
    HRESULT Hash([out, retval] VARIANT *pVal);
	
	[propget, id(2), helpstring("Gets the friendly name of the certificate")]
    HRESULT FriendlyName([out, retval] BSTR *pVal);
	
	[propget, id(3), helpstring("Gets the name of the entity to whom the certificate was issued")]
    HRESULT IssuedTo([out, retval] BSTR *pVal);
	
	[propget, id(4), helpstring("Gets the name of the entity that issued the certificate")]
    HRESULT IssuedBy([out, retval] BSTR *pVal);
	
	[propget, id(5), helpstring("Gets the expiration date of the certificate")]
    HRESULT ExpirationDate([out, retval] DATE *pVal);
	
	[propget, id(6), helpstring("Gets the subject of the certificate")]
    HRESULT Subject([out, retval] BSTR *pVal);
	
};
	
[
object,
uuid(BDA45E1D-FBE7-4FC8-9CDE-51D42880DB88),
dual,
helpstring("A certificate stored on the Forefront TMG computer"),
pointer_default(unique)
]
interface IFPCCertificate2 : IFPCCertificate
{
	[propget, id(7), helpstring("Gets a Boolean value that indicates whether the private key of the certificate is valid")]
    HRESULT IsPrivateKeyValid([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(8), helpstring("Gets a value from the FpcPrivateKeyFailure enumerated type that specifies the problem in the private key")]
    HRESULT PrivateKeyFailure([out, retval] FpcPrivateKeyFailure *pVal);
	
	[propget, id(9), helpstring("Gets a value from the FpcCertificateStore enumerated type that specifies the store in which the certificate resides")]
    HRESULT CertificateStore([out, retval] FpcCertificateStore *pVal);
	
	[propget, id(10), helpstring("Gets the date on which the certificate became valid")]
    HRESULT ValidFromDate([out, retval] DATE *pVal);
	
	[propget, id(11), helpstring("Gets a Boolean value that indicates whether the certificate expired")]
    HRESULT IsExpired([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(12), helpstring("Gets a Boolean value that indicates whether the certificate is not yet valid")]
    HRESULT IsNotValidYet([out, retval] VARIANT_BOOL *pVal);
	
};
	
[
object,
uuid(F79AAA91-A7E5-42F2-B16A-5A9A1ACB8A9A),
dual,
nonextensible,
helpstring("A certificate stored on the Forefront TMG computer"),
pointer_default(unique)
]
interface IFPCCertificate3 : IFPCCertificate2
{
	[propget, id(13), helpstring("Gets a Boolean value that indicates whether the certificate is valid to use as an SSTP certificate")]
    HRESULT IsValidForSSTP([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(14), helpstring("Gets the alternative names of the entity to whom the certificate was issued")]
    HRESULT SubjectAlternativeName([out, retval] BSTR *pVal);
	
};
	
[
object,
uuid(A4CE7060-75BC-48E2-AB9A-BBA15A82D8AB),
dual,
helpstring("A server object"),
pointer_default(unique)
]
interface IFPCServer : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets the name of the server")]
    HRESULT Name([out, retval] BSTR *pVal);
	
	[propget, id(2), helpstring("Gets the version of the server")]
    HRESULT ProductVersion([out, retval] BSTR *pVal);
	
	[propget, id(3), helpstring("Gets the identifier of the product installed on this server")]
    HRESULT ProductId([out, retval] BSTR *pVal);
	
	[propget, id(4), helpstring("Gets or sets the description of the server")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(4), helpstring("Gets or sets the description of the server")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(5), helpstring("Gets a collection of cache drive objects in this server")]
    HRESULT CacheDrives([out, retval] IFPCCacheDrives **pVal);
	
	[propget, id(6), helpstring("Gets a collection of disk-drive objects in this server")]
    HRESULT DiskDrives([out, retval] IFPCDiskDrives **pVal);
	
	[propget, id(7), helpstring("Gets a collection of objects representing the available network adapter cards")]
    HRESULT Adapters([out, retval] IFPCAdapters **pVal);
	
	[propget, id(8), helpstring("Gets whether the server is functioning")]
    HRESULT ServerStatus([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(9), helpstring("Gets whether the firewall service is running")]
    HRESULT FirewallServiceStatus([out, retval] VARIANT_BOOL *pVal);
	
	[id(10), helpstring("Stops the firewall service")]
          HRESULT StopFirewallService([in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fWaitUntilComplete);
        
    
	[id(11), helpstring("Starts the firewall service")]
          HRESULT StartFirewallService([in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fWaitUntilComplete);
        
    
	[propget, id(12), helpstring("Gets the time the server object was created")]
    HRESULT CreatedTime([out, retval] DATE *pVal);
	
	[propget, id(13), helpstring("Gets the time the Forefront TMG object was last modified")]
    HRESULT LastModifiedTime([out, retval] DATE *pVal);
	
	[propget, id(14), helpstring("Gets the collection of connectivity check results for the server")]
    HRESULT ConnectivityResults([out, retval] IFPCConnectivityResults **pVal);
	
	[propget, id(15), helpstring(""), hidden]
    HRESULT PublicKey([out, retval] VARIANT *pVal);
	
	[propget, id(17), helpstring("Gets whether the Microsoft Forefront TMG Job Scheduler Service is running")]
    HRESULT JobSchedulerServiceStatus([out, retval] VARIANT_BOOL *pVal);
	
	[id(18), helpstring("Stops the Microsoft Forefront TMG Job Scheduler Service")]
          HRESULT StopJobSchedulerService([in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fWaitUntilComplete);
        
    
	[id(19), helpstring("Starts the Microsoft Forefront TMG Job Scheduler Service")]
          HRESULT StartJobSchedulerService([in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fWaitUntilComplete);
        
    
	[propget, id(20), helpstring("Gets the number of seconds that the Firewall service has worked properly")]
    HRESULT FirewallServiceUpTime([out, retval] long *pVal);
	
	[propget, id(21), helpstring("Gets a reference to the FPCSignaledAlerts collection")]
    HRESULT SignaledAlerts([out, retval] IFPCSignaledAlerts **pVal);
	
	[propget, id(22), helpstring("Gets a collection of dial-up network connections in this server")]
    HRESULT DialupNetworkConnections([out, retval] IFPCDialupNetworkConnections **pVal);
	
	[propget, id(23), helpstring("Gets the collection of valid SSL client certificates available on the server")]
    HRESULT SSLClientCertificates([out, retval] IFPCCertificates **pVal);
	
	[propget, id(24), helpstring("Gets the collection of valid SSL server certificates available on the server")]
    HRESULT SSLServerCertificates([out, retval] IFPCCertificates **pVal);
	
	[propget, id(25), helpstring("Gets the Fully Qualified Domain Name of the server")]
    HRESULT FQDN([out, retval] BSTR *pVal);
	
	[propget, id(26), helpstring("Gets or sets the load factor, which assigns more traffic to servers that are able to handle more requests")]
    HRESULT LoadFactor([out, retval] long *pVal);
    [propput, id(26), helpstring("Gets or sets the load factor, which assigns more traffic to servers that are able to handle more requests")]
    HRESULT LoadFactor([in] long newVal);
	
	[propget, id(27), helpstring("Gets the number of Web proxy sessions running on this server")]
    HRESULT WebProxySessionsCount([out, retval] long *pVal);
	
	[propget, id(28), helpstring("Gets the number of Forefront TMG Client sessions running on this server")]
    HRESULT FirewallClientSessionsCount([out, retval] long *pVal);
	
	[propget, id(29), helpstring("Gets the number of SecureNAT sessions running on this server")]
    HRESULT SecureNATSessionsCount([out, retval] long *pVal);
	
	[propget, id(30), helpstring("Gets the number of VPN connections running on this server")]
    HRESULT VPNConnectionsCount([out, retval] long *pVal);
	
	[propget, id(31), helpstring("Gets the number of quarantined VPN connections running on this server")]
    HRESULT QuarantinedVPNConnectionsCount([out, retval] long *pVal);
	
	[propget, id(32), helpstring("Gets the number of site to site VPN connections running on this server")]
    HRESULT SiteToSiteVPNConnectionsCount([out, retval] long *pVal);
	
	[propget, id(33), helpstring("Gets the Forefront TMG installation directory")]
    HRESULT InstallationDirectory([out, retval] BSTR *pVal);
	
	[propget, id(35), helpstring("Gets the static address pool for VPN clients connected to the server")]
    HRESULT VpnStaticAddressPool([out, retval] IFPCReadOnlyIpRangeSet **pVal);
	
	[propget, id(36), helpstring("Gets whether the Remote Access service is running")]
    HRESULT RemoteAccessServiceStatus([out, retval] VARIANT_BOOL *pVal);
	
	[id(37), helpstring("Stops the Remote Access service")]
          HRESULT StopRemoteAccessService([in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fWaitUntilComplete);
        
    
	[id(38), helpstring("Starts the Remote Access service")]
          HRESULT StartRemoteAccessService([in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fWaitUntilComplete);
        
    
	[id(39), helpstring("Disconnect a VPN connection")]
          HRESULT VPNDisconnect([in] BSTR RemoteIPAddress);
        
    
	[propget, id(40), helpstring("Gets the major version number of the operating system installed on the server")]
    HRESULT OperatingSystemMajorVersion([out, retval] long *pVal);
	
	[propget, id(41), helpstring("Gets the minor version number of the operating system installed on the server")]
    HRESULT OperatingSystemMinorVersion([out, retval] long *pVal);
	
	[propget, id(42), helpstring("Gets the bitmask that specifies the product suites available on the server")]
    HRESULT OperatingSystemSuiteMask([out, retval] long *pVal);
	
	[propget, id(43), helpstring("Gets the major version number of the latest Service Pack installed on the server")]
    HRESULT ServicePackMajorVersion([out, retval] long *pVal);
	
	[propget, id(44), helpstring("Gets the minor version number of the latest Service Pack installed on the server")]
    HRESULT ServicePackMinorVersion([out, retval] long *pVal);
	
	[propget, id(45), helpstring("Gets the number of seconds that the Microsoft Forefront TMG Job Scheduler Service has worked properly")]
    HRESULT JobSchedulerServiceUpTime([out, retval] long *pVal);
	
	[propget, id(46), helpstring("Deprecated - use IFPCServer3::IsaDatabaseLogServiceStatus instead")]
    HRESULT MSDEServiceStatus([out, retval] VARIANT_BOOL *pVal);
	
	[id(47), helpstring("Deprecated - use IFPCServer3::StopIsaDatabaseLogService instead")]
          HRESULT StopMSDEService([in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fWaitUntilComplete);
        
    
	[id(48), helpstring("Deprecated - use IFPCServer3::StartIsaDatabaseLogService instead")]
          HRESULT StartMSDEService([in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fWaitUntilComplete);
        
    
	[propget, id(49), helpstring("Gets the collection of Trusted Root Certificates available on the server")]
    HRESULT TrustedRootCertificates([out, retval] IFPCCertificates **pVal);
	
	[propget, id(50), helpstring("Detects if IPSecPol.exe is installed on Windows 2000"), hidden]
    HRESULT IPSecPolInstalled([out, retval] VARIANT_BOOL *pVal);
	
	[id(51), helpstring("Add or remove the server from the RAS and IAS Servers groups on the domain controller")]
          HRESULT ActivateRASServerOnDomain([in] VARIANT_BOOL fActivate);
        
    
	[propget, id(52), helpstring("Detects if MSDE is installed on the server"), hidden]
    HRESULT IsMSDEInstalled([out, retval] VARIANT_BOOL *pVal);
	
};
	
[
object,
uuid(87ec966b-04e2-4ca3-9300-1f533f8e537c),
dual,
helpstring("A server object"),
pointer_default(unique)
]
interface IFPCEEServer : IFPCServer
{
	[id(53), helpstring("Stops NLB on the server")]
          HRESULT StopNLB();
        
    
	[id(54), helpstring("Starts NLB on the server")]
          HRESULT StartNLB();
        
    
	[propget, id(55), helpstring("Gets the status of NLB on the server")]
    HRESULT NLBStatus([out, retval] FpcNLBStatus *pVal);
	
	[id(56), helpstring("Send restart notification for specific services")]
          HRESULT SendRestartNotification([in] long Services);
        
    
	[propget, id(57), helpstring("Gets or sets the intra-array address")]
    HRESULT IntraArrayAddress([out, retval] BSTR *pVal);
    [propput, id(57), helpstring("Gets or sets the intra-array address")]
    HRESULT IntraArrayAddress([in] BSTR newVal);
	
	[propget, id(58), helpstring("Gets or sets whether the management IP or name is enabled")]
    HRESULT UseManagementIpOrName([out, retval] VARIANT_BOOL *pVal);
    [propput, id(58), helpstring("Gets or sets whether the management IP or name is enabled")]
    HRESULT UseManagementIpOrName([in] VARIANT_BOOL newVal);
	
	[propget, id(59), helpstring("Gets or sets the management ip or name")]
    HRESULT ManagementIpOrName([out, retval] BSTR *pVal);
    [propput, id(59), helpstring("Gets or sets the management ip or name")]
    HRESULT ManagementIpOrName([in] BSTR newVal);
	
	[propget, id(60), helpstring("Gets the Domain Name of the server")]
    HRESULT ServerDomain([out, retval] BSTR *pVal);
	
	[propget, id(61), helpstring("Gets an FPCRefs collection that contains references to the application filters installed on the server.")]
    HRESULT InstalledApplicationFilters([out, retval] IFPCRefs **pVal);
	
	[propget, id(62), helpstring("Gets an FPCRefs collection that contains references to the Web filters installed on the server.")]
    HRESULT InstalledWebFilters([out, retval] IFPCRefs **pVal);
	
	[propget, id(63), helpstring("Gets the distribution status of the server")]
    HRESULT DistributionStatus([out, retval] IFPCEEDistributionStatus **pVal);
	
	[propget, id(64), helpstring("Gets the static address pool for VPN clients connected to the server")]
    HRESULT VpnStaticAddressPoolEx([out, retval] IFPCIpRangeSet **pVal);
	
	[id(65), helpstring("Switches NLB to drain-stop mode")]
          HRESULT DrainstopNLB();
        
    
	[id(66), helpstring("Suspends NLB")]
          HRESULT SuspendNLB();
        
    
	[id(67), helpstring("Resumes NLB")]
          HRESULT ResumeNLB();
        
    
	[propget, id(68), helpstring("Gets or sets the host ID")]
    HRESULT HostID([out, retval] long *pVal);
    [propput, id(68), helpstring("Gets or sets the host ID")]
    HRESULT HostID([in] long newVal);
	
};
	
[
object,
uuid(c40554a9-0217-4251-b85e-54801f04b571),
dual,
helpstring("A server object"),
pointer_default(unique)
]
interface IFPCServer2 : IFPCEEServer
{
	[propget, id(69), helpstring("Gets the collection of all SSL server certificates available on the server")]
    HRESULT SSLAllServerCertificates([out, retval] IFPCCertificates2 **pVal);
	
	[propget, id(70), helpstring("Gets the collection of Intermediate Certification Authorities available on the server")]
    HRESULT IntermediateCertificates([out, retval] IFPCCertificates **pVal);
	
	[id(71), helpstring("Sets upgrade paramaters - for internal use only!!!"), hidden]
          HRESULT SetServerUpgradeProperties([in] BSTR bstrProductId,
              [in] BSTR bstrVersion,
              [in] BSTR bstrInstDir);
        
    
	[id(72), helpstring("Gets all effective link translation mappings of the given rule"), hidden]
          HRESULT GetAllRuleMappings([in] BSTR bstrRuleGuid,
              [out,retval] BSTR* pbstrXmlDoc);
        
    
};
	
[
object,
uuid(46D69BC4-4D91-4926-A3DF-C6E5194E9112),
dual,
helpstring("A server object"),
pointer_default(unique)
]
interface IFPCServer3 : IFPCServer2
{
	[propget, id(73), helpstring("Gets whether the ISA Log Database service is running")]
    HRESULT IsaDatabaseLogServiceStatus([out, retval] VARIANT_BOOL *pVal);
	
	[id(74), helpstring("Stops the ISA Log Database service")]
          HRESULT StopIsaDatabaseLogService([in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fWaitUntilComplete);
        
    
	[id(75), helpstring("Starts the ISA Log Database service")]
          HRESULT StartIsaDatabaseLogService([in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fWaitUntilComplete);
        
    
	[id(76), helpstring("Shuts down the operating system running on the server")]
          HRESULT ShutdownOS();
        
    
	[id(77), helpstring("Restarts the operating system running on the server")]
          HRESULT RestartOS();
        
    
	[propget, id(78), helpstring("Gets the server IP routing table")]
    HRESULT RoutingTable([out, retval] IFPCRoutingTable **pVal);
	
	[id(79), helpstring("Gets current NIS policy in XML format"), hidden]
          HRESULT GetIpsPolicy([out,retval] BSTR* pbstrXmlDoc);
        
    
	[id(80), helpstring("Retrieves an FPCReadOnlyIpRangeSet collection that contains the set of routable IP address ranges for the specified network adapter on the server")]
          HRESULT GetAdapterRoutableIpRangeSet([in] BSTR AdapterNameOrIpAddress,
              [out,retval] IFPCReadOnlyIpRangeSet** pVal);
        
    
	[id(81), helpstring("Joins the specified domain. You must restart the computer to apply the domain change")]
          HRESULT JoinDomain([in] BSTR Domain,
              [in] BSTR DomainUserName,
              [in] BSTR DomainUserPassword,
              [in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL RestartNow);
        
    
	[id(82), helpstring("Joins the specified workgroup. To leave the current domain specify user name and password. You must restart the computer to apply the workgroup change")]
          HRESULT JoinWorkgroup([in] BSTR Workgroup,
              [in] BSTR CurrentDomainUserName,
              [in] BSTR CurrentDomainUserPassword,
              [in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL RestartNow);
        
    
	[propget, id(83), helpstring("Gets the server current domain or workgroup")]
    HRESULT DomainOrWorkgroupName([out, retval] BSTR *pVal);
	
	[propget, id(84), helpstring("Gets the domain membership indicator, TRUE if in a domain FALSE if in a workgroup")]
    HRESULT IsJoinedToDomain([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(85), helpstring("Gets the server current loged-in user")]
    HRESULT CurrentUserName([out, retval] BSTR *pVal);
	
	[id(86), helpstring("Sets the server current user name and password")]
          HRESULT SetUserNameAndPassword([in] BSTR NewUserName,
              [in] BSTR CurrentPassword,
              [in] BSTR NewPassword);
        
    
	[id(87), helpstring("Sets the server computer name. You must restart the computer to apply the name change. If server is member of domain and if DomainUserName is not specified, current user credentials are used")]
          HRESULT SetServerName([in] BSTR Name,
              [in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL RestartNow,
              [in,defaultvalue(NULL)] BSTR DomainUserName,
              [in,defaultvalue(NULL)] BSTR DomainUserPassword);
        
    
	[propget, id(88), helpstring("Gets a collection of objects representing all the network adapter cards")]
    HRESULT AllAdapters([out, retval] IFPCAllAdapters **pVal);
	
	[propget, id(89), helpstring("Gets the collection of update service states on the server")]
    HRESULT ServiceUpdatesStates([out, retval] IFPCServiceUpdatesStates **pVal);
	
	[propget, id(90), helpstring("Gets the static IPv6 address pool for VPN clients connected to the server"), hidden]
    HRESULT VpnStaticIPv6AddressPoolEx([out, retval] IFPCIpRangeSet **pVal);
	
	[id(120), helpstring("method that perform immediate save of currrent instance adapetrs settings and array level static routes"), hidden]
          HRESULT UpdateAdaptersAndStaticRoutes();
        
    
	[propget, id(121), helpstring("Gets the primary DNS suffix of the computer")]
    HRESULT PrimaryDNSSuffix([out, retval] BSTR *pVal);
	
	[id(122), helpstring("Sets the primary DNS suffix of the computer")]
          HRESULT SetPrimaryDNSSuffix([in] BSTR DNSsuffix);
        
    
	[id(123), helpstring("Adds persistent routes in the server to the array static routes collection")]
          HRESULT PopulateArrayStaticRoutes();
        
    
	[propget, id(124), helpstring("Gets or sets a value from the FpcMicrosoftUpdateSetting enumerated type that specifies whether the server uses Microsoft Update")]
    HRESULT MicrosoftUpdateSetting([out, retval] FpcMicrosoftUpdateSetting *pVal);
    [propput, id(124), helpstring("Gets or sets a value from the FpcMicrosoftUpdateSetting enumerated type that specifies whether the server uses Microsoft Update")]
    HRESULT MicrosoftUpdateSetting([in] FpcMicrosoftUpdateSetting newVal);
	
	[propget, id(125), helpstring("Gets a Boolean value that indicates whether the server is configured to receive downloads from Microsoft Update through a WSUS server")]
    HRESULT WSUSConfigured([out, retval] VARIANT_BOOL *pVal);
	
};
	
[
object,
uuid(B103741A-A639-4ed7-A19C-2915F3C3B236),
dual,
nonextensible,
helpstring("A server object"),
pointer_default(unique)
]
interface IFPCServer4 : IFPCServer3
{
	[propget, id(126), helpstring("Gets a Boolean value that indicates whether the SQL Server (ISARS) service is running")]
    HRESULT SqlServerServiceStatus([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(127), helpstring("Gets a Boolean value that indicates whether the SQL Server Reporting Services (ISARS) service is running")]
    HRESULT SqlServerReportingServicesServiceStatus([out, retval] VARIANT_BOOL *pVal);
	
	[id(128), helpstring("Performs an unscheduled update operation")]
          HRESULT ExecuteUnscheduledUpdate([in] FpcProtectionMechanisms UpdateServices,
              [in] FpcUpdateAction UpdateAction);
        
    
	[propget, id(129), helpstring("Gets the status of SMTP protection on the server")]
    HRESULT SmtpProtectionStatus([out, retval] IFPCSmtpProtectionStatus **pVal);
	
	[propget, id(132), helpstring("Gets whether the Exchange Edge service is running")]
    HRESULT ExchangeEdgeServiceStatus([out, retval] VARIANT_BOOL *pVal);
	
	[id(133), helpstring("Stops the Exchange Edge service")]
          HRESULT StopExchangeEdgeService([in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fWaitUntilComplete);
        
    
	[id(134), helpstring("Starts the Exchange Edge service")]
          HRESULT StartExchangeEdgeService([in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fWaitUntilComplete);
        
    
	[propget, id(135), helpstring("Gets whether the Forefront Server Security for Exchange  service is running")]
    HRESULT ForefrontServerSecurityServiceStatus([out, retval] VARIANT_BOOL *pVal);
	
	[id(136), helpstring("Stops the Forefront Server Security for Exchange  service")]
          HRESULT StopForefrontServerSecurityService([in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fWaitUntilComplete);
        
    
	[id(137), helpstring("Starts the Forefront Server Security for Exchange  service")]
          HRESULT StartForefrontServerSecurityService([in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fWaitUntilComplete);
        
    
	[id(138), helpstring("Wait until server reloads the new configuration or failed to reload (must be called within same configuration storage server of the array)."), hidden]
          HRESULT WaitForReload();
        
    
	[propget, id(139), helpstring("Gets a Boolean value that indicates whether the Microsoft Forefront TMG Managed Control service is running")]
    HRESULT ManagedControlServiceStatus([out, retval] VARIANT_BOOL *pVal);
	
	[id(140), helpstring("Starts the Microsoft Forefront TMG Managed Control service")]
          HRESULT StartManagedControlService([in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fWaitUntilComplete);
        
    
	[id(141), helpstring("Stops the Microsoft Forefront TMG Managed Control service")]
          HRESULT StopManagedControlService([in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fWaitUntilComplete);
        
    
	[propget, id(143), helpstring("Gets FPCNisSignatureSet object that specify the network inspection system signature set of the server"), hidden]
    HRESULT NisSignatureSet([out, retval] IFPCNisSignatureSet **pVal);
	
	[propget, id(144), helpstring("Gets the machine account of the server")]
    HRESULT MachineAccount([out, retval] BSTR *pVal);
	
	[id(145), helpstring("Start Diagnostic Logging")]
          HRESULT StartDiagnosticLogging([in] DWORD dwComponentId);
        
    
	[id(146), helpstring("Stop Diagnostic Logging")]
          HRESULT StopDiagnosticLogging();
        
    
	[id(147), helpstring("Clear Diagnostic Logging")]
          HRESULT ClearDiagnosticLogging();
        
    
	[id(148), helpstring("Returns Diagnostic Logging Status")]
          HRESULT GetDiagnosticLoggingStatus([out] BOOL* pfStarted,
              [out] DWORD* pdwNumberOfRecords,
              [out] DWORD* pdwComponentId);
        
    
	[id(149), helpstring("Get Diagnostic Logging result")]
          HRESULT GetDiagnosticLogging([in,out] DWORD* pdwStartIndex,
              [in,out] DWORD* pdwBufferSize,
              [out] BYTE** ppBuffer);
        
    
	[id(150), helpstring("Validate Program ID during SKU UPGRADE and sets apropritate properties in the storage")]
          HRESULT UpgradeArrayTypeByProgramID([in] BSTR ProgramId);
        
    
	[id(151), helpstring("Stops the Security Assessment Sharing agent service")]
          HRESULT StopSecurityAssessmentSharingAgentService([in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fWaitUntilComplete);
        
    
	[id(152), helpstring("Starts the Security Assessment Sharing agent service")]
          HRESULT StartSecurityAssessmentSharingAgentService([in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fWaitUntilComplete);
        
    
	[propget, id(153), helpstring("Gets whether the Security Assessment Sharing agent service is running")]
    HRESULT SecurityAssessmentSharingAgentStatus([out, retval] VARIANT_BOOL *pVal);
	
	[id(154), helpstring("Stops the Forefront Protection Manager Monitoring agent service")]
          HRESULT StopForefrontSystemMonitoringAgentService([in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fWaitUntilComplete);
        
    
	[id(155), helpstring("Starts the Forefront Protection Manager Monitoring agent service")]
          HRESULT StartForefrontSystemMonitoringAgentService([in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fWaitUntilComplete);
        
    
	[propget, id(156), helpstring("Gets whether the Forefront Protection Manager Monitoring agent service is running")]
    HRESULT ForefrontSystemMonitoringAgentStatus([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(157), helpstring("Gets an FPCExternalComponents collection that contains objects representing all the Forefront TMG external components")]
    HRESULT ExternalComponents([out, retval] IFPCExternalComponents **pVal);
	
	[propget, id(158), helpstring("Gets whether the Security Assessment Sharing agent service is connected")]
    HRESULT SecurityAssessmentSharingAgentHealth([out, retval] VARIANT_BOOL *pVal);
	
};
	
[
object,
uuid(EB52794F-92AA-4a4a-AE67-78935910F055),
dual,
nonextensible,
helpstring("Collection of external components"),
pointer_default(unique)
]
interface IFPCExternalComponents : IFPCPersist
{
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Retrieves the specified FPCExternalComponent object from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCExternalComponent** pItem);
        
    
};
	
[
object,
uuid(3C74035A-D02A-420e-B377-5AF24EAD830A),
dual,
nonextensible,
helpstring("External component object"),
pointer_default(unique)
]
interface IFPCExternalComponent : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets the name of the external component")]
    HRESULT Name([out, retval] BSTR *pVal);
	
	[propget, id(1), helpstring("Gets or sets a Boolean value that indicates whether the external component is installed on the server")]
    HRESULT IsInstalled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets a Boolean value that indicates whether the external component is installed on the server")]
    HRESULT IsInstalled([in] VARIANT_BOOL newVal);
	
	[propget, id(2), helpstring("Gets or sets the version of the external component that is installed on the server")]
    HRESULT Version([out, retval] BSTR *pVal);
    [propput, id(2), helpstring("Gets or sets the version of the external component that is installed on the server")]
    HRESULT Version([in] BSTR newVal);
	
};
	
[
object,
uuid(D598D610-C1CE-40aa-88B4-1EFB50DFBA03),
dual,
helpstring("Distribution Status"),
pointer_default(unique)
]
interface IFPCEEDistributionStatus : IDispatch
{
	[propget, id(1), helpstring("Gets the configuration storage server name")]
    HRESULT ConfigurationStorageServer([out, retval] BSTR *pVal);
	
	[propget, id(2), helpstring("Gets the server distribution status")]
    HRESULT Status([out, retval] FpcConfigurationStatus *pVal);
	
	[propget, id(3), helpstring("Gets the Configuration Agent Error")]
    HRESULT ConfigurationAgentError([out, retval] long *pVal);
	
	[propget, id(4), helpstring("Gets the Reload Configuration Error")]
    HRESULT ReloadConfigurationError([out, retval] long *pVal);
	
	[propget, id(5), helpstring("Gets the last time the configuration was updated from the storage server")]
    HRESULT LastConfigurationUpdateTime([out, retval] DATE *pVal);
	
	[propget, id(7), helpstring("Gets the Console Error")]
    HRESULT ConsoleError([out, retval] long *pVal);
	
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
};
	
[
object,
uuid(27c94e23-b9b7-48ea-95db-9170f0d96712),
dual,
nonextensible,
helpstring("Distribution Status"),
pointer_default(unique)
]
interface IFPCDistributionStatus2 : IFPCEEDistributionStatus
{
	[propget, id(8), helpstring("Gets the percentage of operations completed by the Microsoft Forefront TMG Control service during synchronization of the cache and effective configuration")]
    HRESULT CompletedOperationsPercent([out, retval] long *pVal);
	
	[propget, id(9), helpstring("Gets the name of the remote configuration storage server from which the Forefront TMG computer downloads the configuration")]
    HRESULT NewConfigurationStorageServer([out, retval] BSTR *pVal);
	
};
	
[
object,
uuid(7E9EBEAD-61EF-4528-A766-785F50E97C4D),
dual,
nonextensible,
helpstring("A schedule"),
pointer_default(unique)
]
interface IFPCSchedule : IFPCPersist
{
	[id(1), helpstring("Adds a set of hours to the schedule")]
          HRESULT Set( FpcScheduleDays Day,
               FpcScheduleHours Hour);
        
    
	[id(2), helpstring("Removes a set of hours from the schedule")]
          HRESULT UnSet( FpcScheduleDays Day,
               FpcScheduleHours Hour);
        
    
	[id(3), helpstring("Returns whether every hour in the given set is part of the schedule")]
          HRESULT IsSet( FpcScheduleDays Day,
               FpcScheduleHours Hour,
              [out,retval] VARIANT_BOOL* pSetVal);
        
    
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the schedule")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the schedule")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(5), helpstring("Gets or sets the description of the schedule")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(5), helpstring("Gets or sets the description of the schedule")]
    HRESULT Description([in] BSTR newVal);
	
};
	
[
object,
uuid(18D3FFB3-12CB-4F41-8C31-13B7050145DC),
dual,
nonextensible,
helpstring("Collection of schedules"),
pointer_default(unique)
]
interface IFPCSchedules : IFPCPersist
{
	[id(DISPID_REMOVE), helpstring("Removes a schedule from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_ADD), helpstring("Adds a schedule to the collection")]
          HRESULT Add( BSTR Name,
              [out,retval] IFPCSchedule** ppNewTemplate);
        
    
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCSchedule** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

};
	
[
object,
uuid(74E258A8-EFA3-4581-A715-A485022AE253),
dual,
nonextensible,
helpstring("An alert"),
pointer_default(unique)
]
interface IFPCAlert : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the alert")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the alert")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(3), helpstring("Gets or sets whether the alert is enabled")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(3), helpstring("Gets or sets whether the alert is enabled")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(4), helpstring("Gets the GUID of the event type on which the alert is based")]
    HRESULT EventGUID([out, retval] BSTR *pVal);
	
	[propget, id(5), helpstring("Gets or sets the description of the alert")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(5), helpstring("Gets or sets the description of the alert")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(6), helpstring("Gets the name of the server that is allowed to signal this alert")]
    HRESULT ServerName([out, retval] BSTR *pVal);
	
	[propget, id(7), helpstring("Gets the index to the additional-key table of the event associated with this alert")]
    HRESULT AdditionalKey([out, retval] long *pVal);
	
	[propget, id(8), helpstring("Gets or sets a minimal frequency of events that trigger the alert before the alert's actions can be executed")]
    HRESULT MinEventsPerSecond([out, retval] long *pVal);
    [propput, id(8), helpstring("Gets or sets a minimal frequency of events that trigger the alert before the alert's actions can be executed")]
    HRESULT MinEventsPerSecond([in] long newVal);
	
	[propget, id(9), helpstring("Gets or sets a time interval to wait before alert's actions can be executed again")]
    HRESULT MinutesBeforeReRaise([out, retval] long *pVal);
    [propput, id(9), helpstring("Gets or sets a time interval to wait before alert's actions can be executed again")]
    HRESULT MinutesBeforeReRaise([in] long newVal);
	
	[propget, id(10), helpstring("Gets or sets a minimal number of events that trigger the alert before the alert's actions can be executed")]
    HRESULT EventsBeforeRaise([out, retval] long *pVal);
    [propput, id(10), helpstring("Gets or sets a minimal number of events that trigger the alert before the alert's actions can be executed")]
    HRESULT EventsBeforeRaise([in] long newVal);
	
	[propget, id(11), helpstring("Gets a reference to a collection of alert actions")]
    HRESULT Actions([out, retval] IFPCAlertActions **pVal);
	
	[id(13), helpstring("Sets definitions of the alert")]
          HRESULT SetDefinitions([in] BSTR EventGUID,
              [defaultvalue("")] BSTR ServerName,
              [defaultvalue(-1)] long AdditionalKey);
        
    
	[propget, id(14), helpstring("Gets or sets the user name for the credentials of the command-line action")]
    HRESULT UserName([out, retval] BSTR *pVal);
    [propput, id(14), helpstring("Gets or sets the user name for the credentials of the command-line action")]
    HRESULT UserName([in] BSTR newVal);
	
	
    [propput, id(15), helpstring("Sets the password for the credentials of the command-line action")]
    HRESULT Password([in] BSTR newVal);
	
	[propget, id(16), helpstring("Gets or sets category of alert")]
    HRESULT Category([out, retval] FpcAlertCategory *pVal);
    [propput, id(16), helpstring("Gets or sets category of alert")]
    HRESULT Category([in] FpcAlertCategory newVal);
	
	[propget, id(17), helpstring("Gets or sets severity of alert")]
    HRESULT Severity([out, retval] FpcAlertSeverity *pVal);
    [propput, id(17), helpstring("Gets or sets severity of alert")]
    HRESULT Severity([in] FpcAlertSeverity newVal);
	
};
	
[
object,
uuid(0E8991DF-9C7E-4596-A471-735FB3D54A04),
dual,
nonextensible,
helpstring("Collection of alerts"),
pointer_default(unique)
]
interface IFPCAlerts : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCAlert** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_ADD), helpstring("Adds an alert to the collection")]
          HRESULT Add([in] BSTR Name,
              [in] BSTR EventGUID,
              [defaultvalue("")] BSTR ServerName,
              [defaultvalue(-1)] long AdditionalKey,
              [out,retval] IFPCAlert** ppNewAlert);
        
    
	[id(1), helpstring("Adds an alert to the collection, with a specified storage name")]
          HRESULT AddWithStorageName([in] BSTR Name,
              [in] BSTR EventGUID,
              [defaultvalue("")] BSTR ServerName,
              [defaultvalue("")] BSTR StorageName,
              [defaultvalue(-1)] long AdditionalKey,
              [out,retval] IFPCAlert** ppNewAlert);
        
    
	[id(DISPID_REMOVE), helpstring("Removes an alert from the collection")]
          HRESULT Remove( VARIANT v);
        
    
};
	
[
object,
uuid(519B7C50-A099-4B2E-9615-BA8C7ED6BB9C),
dual,
nonextensible,
helpstring("An alert action"),
pointer_default(unique)
]
interface IFPCAlertAction : IDispatch
{
	[propget, id(3), helpstring("Gets an array of strings that specify optional parameters for an action")]
    HRESULT Parameters([out, retval] VARIANT *pVal);
	
	[propget, id(4), helpstring("Gets or sets the name of the alert action")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(4), helpstring("Gets or sets the name of the alert action")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(5), helpstring("Gets the type identifier (ID) of the alert action")]
    HRESULT Type([out, retval] FpcAlertActionTypes *pVal);
	
	[propget, id(7), helpstring("Gets or sets whether the alert action is enabled")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(7), helpstring("Gets or sets whether the alert action is enabled")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
};
	
[
object,
uuid(BA2C5224-2A7A-46DC-8E56-E12DB0154B6B),
dual,
nonextensible,
helpstring("Collection of alert actions"),
pointer_default(unique)
]
interface IFPCAlertActions : IDispatch
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCAlertAction** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(4), helpstring("Creates a new log-event action in the collection, or updates the log-event action if it already exists")]
          HRESULT SetLogEvent([in] BSTR ActionName,
              [out,retval] IFPCAlertAction** ppNewAction);
        
    
	[id(5), helpstring("Creates a new send-mail action in the collection, or updates the send-mail action if it already exists")]
          HRESULT SetSendMail([in] BSTR ActionName,
              [in] BSTR Server,
              [in] BSTR FromField,
              [in] BSTR ToField,
              [in,defaultvalue("")] BSTR CcField,
              [out,retval] IFPCAlertAction** ppNewAction);
        
    
	[id(6), helpstring("Creates a new command-line action in the collection, or updates the command-line action if it already exists")]
          HRESULT SetCommand([in] BSTR ActionName,
              [in] BSTR Command,
              [out,retval] IFPCAlertAction** ppNewAction);
        
    
	[id(7), helpstring("Creates a new stop-services action in the collection, or updates the stop-services action if it already exists")]
          HRESULT SetStopServices([in] BSTR ActionName,
              [in] FpcServices Services,
              [out,retval] IFPCAlertAction** ppNewAction);
        
    
	[id(8), helpstring("Creates a new start-services action in the collection, or updates the start-services action if it already exists")]
          HRESULT SetStartServices([in] BSTR ActionName,
              [in] FpcServices Services,
              [out,retval] IFPCAlertAction** ppNewAction);
        
    
	[id(9), helpstring("Sets the specified action to a disabled state")]
          HRESULT Unset( FpcAlertActionTypes ActionType);
        
    
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
};
	
[
object,
uuid(91D5D26C-85C0-4589-B812-F656CC4827F6),
dual,
nonextensible,
helpstring("An event definition"),
pointer_default(unique)
]
interface IFPCEventDefinition : IFPCPersist
{
	[propget, id(3), helpstring("Gets the GUID of the event")]
    HRESULT EventGUID([out, retval] BSTR *pVal);
	
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the event")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the event")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(5), helpstring("Gets the additional keys for the event")]
    HRESULT AdditionalKeys([out, retval] VARIANT *pVal);
	
	[propget, id(6), helpstring("Gets the number of additional keys for the event")]
    HRESULT AdditionalKeysCount([out, retval] long *pVal);
	
	[propget, id(8), helpstring("Gets or sets the default count of events per second that signals another event")]
    HRESULT MinEventsPerSecond([out, retval] long *pVal);
    [propput, id(8), helpstring("Gets or sets the default count of events per second that signals another event")]
    HRESULT MinEventsPerSecond([in] long newVal);
	
	[propget, id(9), helpstring("Gets or sets the interval between invocations of the default count of minutes that signals another event")]
    HRESULT MinutesBeforeReRaise([out, retval] long *pVal);
    [propput, id(9), helpstring("Gets or sets the interval between invocations of the default count of minutes that signals another event")]
    HRESULT MinutesBeforeReRaise([in] long newVal);
	
	[propget, id(10), helpstring("Gets or sets the default count of events that signals another event")]
    HRESULT EventsBeforeRaise([out, retval] long *pVal);
    [propput, id(10), helpstring("Gets or sets the default count of events that signals another event")]
    HRESULT EventsBeforeRaise([in] long newVal);
	
	[propget, id(11), helpstring("Gets or sets the description of the event")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(11), helpstring("Gets or sets the description of the event")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(12), helpstring("Gets whether the event is a preinstalled element that cannot be deleted")]
    HRESULT Predefined([out, retval] VARIANT_BOOL *pVal);
	
	[id(13), helpstring("Signals this event on the server")]
          HRESULT Signal([in,defaultvalue(1)] long SignalCount,
              [in,defaultvalue(-1)] long AdditionalKey,
              [in,defaultvalue("")] BSTR ShortDesc,
              [in,defaultvalue("")] BSTR LongDesc,
              [in,defaultvalue(0)] long EventID,
              [in,defaultvalue("")] BSTR EventSource,
              [in,optional] VARIANT EventStrings,
              [in,optional] VARIANT EventData,
              [in,defaultvalue(0)] short EventCategory,
              [in,defaultvalue(0)] short EventType);
        
    
};
	
[
object,
uuid(82F8DAC8-EBF0-45BA-87E8-165990637691),
dual,
nonextensible,
helpstring("Collection of event definitions"),
pointer_default(unique)
]
interface IFPCEventDefinitions : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCEventDefinition** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_ADD), helpstring("Adds a new event to the collection")]
          HRESULT Add([in] BSTR Name,
              [in] BSTR EventGUID,
              [in,defaultvalue(NULL)] VARIANT* pAdditionalKeys,
              [out,retval] IFPCEventDefinition** ppNewEvent);
        
    
	[id(DISPID_REMOVE), helpstring("Removes an event from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[id(1), helpstring("Returns a specific item from the collection by its EventGuid")]
          HRESULT ItemByGuid([in] BSTR EventGuid,
              [out,retval] IFPCEventDefinition** pItem);
        
    
};
	
[
object,
uuid(640818A1-C379-4B54-8A5C-AE68E5A61ED6),
dual,
nonextensible,
helpstring("Gets an FPCVendorParametersSets object that can hold sets of custom data for extending the object."),
pointer_default(unique)
]
interface IFPCVendorParametersSets : IDispatch
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCVendorParametersSet** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[id(DISPID_ADD), helpstring("Adds a vendor parameters set to the collection")]
          HRESULT Add([in] BSTR Id,
              [in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL Encrypted,
              [in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL EncryptionReadable,
              [out,retval] IFPCVendorParametersSet** ppNewSet);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a vendor parameters set from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[id(DISPID_WAIT_FOR_CHANGES), helpstring("Registers to wait for an event indicating that the contents of the object have changed (for use in C and C++ programming only)."), restricted, local]
          HRESULT WaitForChanges([in] INT64 hEvent);
        
    
	[id(DISPID_CANCEL_WAIT_FOR_CHANGES), helpstring("Cancels the registration established by the WaitForChanges method (for use in C and C++ programming only)."), restricted]
          HRESULT CancelWaitForChanges();
        
    
};
	
[
object,
uuid(A7D5F33F-F27D-4FD6-BDBE-A7590B1E0C03),
dual,
nonextensible,
helpstring("Vendor-specific information"),
pointer_default(unique)
]
interface IFPCVendorParametersSet : IDispatch
{
	[id(DISPID_VALUE), helpstring("Gets or sets the value associated with the given name"), propget]
          HRESULT Value([in] BSTR Name,
              [out,retval] VARIANT* pVal);
        
    
	[id(DISPID_VALUE), helpstring("Gets or sets the value associated with the given name"), propput]
          HRESULT Value([in] BSTR Name,
              [in] VARIANT newVal);
        
    
	[propget, id(1), helpstring("Gets or sets the name of the parameters set")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the name of the parameters set")]
    HRESULT Name([in] BSTR newVal);
	
	[id(2), helpstring("Removes the given value from the set")]
          HRESULT RemoveValue([in] BSTR Name);
        
    
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[id(DISPID_WAIT_FOR_CHANGES), helpstring("Registers to wait for an event indicating that the contents of the object have changed (for use in C and C++ programming only)."), restricted, local]
          HRESULT WaitForChanges([in] INT64 hEvent);
        
    
	[propget, id(4), helpstring("Gets all the names of the parameters set")]
    HRESULT AllNames([out, retval] VARIANT *pVal);
	
	[id(DISPID_CANCEL_WAIT_FOR_CHANGES), helpstring("Cancels the registration established by the WaitForChanges method (for use in C and C++ programming only)."), restricted]
          HRESULT CancelWaitForChanges();
        
    
};
	
[
object,
uuid(e0a87acb-59a1-48c0-bb7b-802622745d15),
dual,
nonextensible,
helpstring("A pattern used to select LDAP servers list according to username"),
pointer_default(unique)
]
interface IFPCLdapMatchingPattern : IFPCPersist
{
	[propget, id(1), helpstring("Gets the ordinal position of the pattern  in the collection of patterns")]
    HRESULT Order([out, retval] long *pVal);
	
	[propget, id(2), helpstring("Gets or sets the pattern string")]
    HRESULT PatternString([out, retval] BSTR *pVal);
    [propput, id(2), helpstring("Gets or sets the pattern string")]
    HRESULT PatternString([in] BSTR newVal);
	
	[id(3), helpstring("Sets the corresponding LDAP Servers set by name")]
          HRESULT SetLDAPServersSet( BSTR LDAPServersSetName);
        
    
	[propget, id(4), helpstring("Gets a reference to the corresponding LDAP servers set")]
    HRESULT LDAPServersSet([out, retval] IFPCRef **pVal);
	
};
	
[
object,
uuid(7ddcdafd-ce10-4ae4-ad17-1465239ff3da),
dual,
nonextensible,
helpstring("Collection of LDAP patterns"),
pointer_default(unique)
]
interface IFPCLdapMatchingPatterns : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCLdapMatchingPattern** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_ADD), helpstring("Adds a pattern and servers list  to the collection")]
          HRESULT Add( BSTR Name,
              [out,retval] IFPCLdapMatchingPattern** ppLdapPattern);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a pattern from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[id(1), helpstring("Moves the given entry one step up in the order")]
          HRESULT MoveUp( long index);
        
    
	[id(2), helpstring("Moves the given entry one step down in the order")]
          HRESULT MoveDown( long index);
        
    
};
	
[
object,
uuid(1620da03-a9f6-4ab4-a0fa-8e9fb67cc9b6),
dual,
nonextensible,
helpstring("An LDAP server"),
pointer_default(unique)
]
interface IFPCLdapServer : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the LDAP server")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the LDAP server")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets the description of the LDAP server")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(2), helpstring("Gets or sets the description of the LDAP server")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(3), helpstring("Gets or sets the amount of time allowed for a connection to be established with the server")]
    HRESULT ConnectionTimeout([out, retval] long *pVal);
    [propput, id(3), helpstring("Gets or sets the amount of time allowed for a connection to be established with the server")]
    HRESULT ConnectionTimeout([in] long newVal);
	
	[propget, id(5), helpstring("Gets the ordinal position of the LDAP server in the collection of LDAP servers")]
    HRESULT Order([out, retval] long *pVal);
	
	[propget, id(6), helpstring("Gets or sets the SecureConnection attribute")]
    HRESULT SecureConnection([out, retval] VARIANT_BOOL *pVal);
    [propput, id(6), helpstring("Gets or sets the SecureConnection attribute")]
    HRESULT SecureConnection([in] VARIANT_BOOL newVal);
	
	[propget, id(7), helpstring("Gets or sets the Global Catalog attribute")]
    HRESULT IsGlobalCatalog([out, retval] VARIANT_BOOL *pVal);
    [propput, id(7), helpstring("Gets or sets the Global Catalog attribute")]
    HRESULT IsGlobalCatalog([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(f23949aa-cded-4983-9b4b-d23ccafbbe4d),
dual,
nonextensible,
helpstring("Collection of LDAP servers"),
pointer_default(unique)
]
interface IFPCLdapServersSet : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the LDAP servers set")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the LDAP servers set")]
    HRESULT Name([in] BSTR newVal);
	
	[id(1), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCLdapServer** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_ADD), helpstring("Adds a LDAP server to the collection")]
          HRESULT Add( BSTR Name,
              [out,retval] IFPCLdapServer** ppNewLdapServer);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a LDAP server from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[id(2), helpstring("Moves the given server one step up in the order")]
          HRESULT MoveUp( long index);
        
    
	[id(3), helpstring("Moves the given server one step down in the order")]
          HRESULT MoveDown( long index);
        
    
	[propget, id(4), helpstring("Gets or sets the domain")]
    HRESULT Domain([out, retval] BSTR *pVal);
    [propput, id(4), helpstring("Gets or sets the domain")]
    HRESULT Domain([in] BSTR newVal);
	
	[propget, id(5), helpstring("Gets an FPCCredentials object used by the Forefront TMG computer to authenticate a connection to an LDAP server")]
    HRESULT Credentials([out, retval] IFPCCredentials **pVal);
	
};
	
[
object,
uuid(d77ff5c6-ec7d-455a-860e-955fd699c37b),
dual,
nonextensible,
helpstring("Collection of LDAP servers lists"),
pointer_default(unique)
]
interface IFPCLdapServersSets : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCLdapServersSet** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_ADD), helpstring("Adds an LDAP servers set to the collection")]
          HRESULT Add( BSTR Name,
              [out,retval] IFPCLdapServersSet** ppNewLdapServersList);
        
    
	[id(DISPID_REMOVE), helpstring("Removes an LDAP servers set from the collection")]
          HRESULT Remove( VARIANT v);
        
    
};
	
[
object,
uuid(62FABD02-769A-47B7-9FBA-214F8F955C4D),
dual,
nonextensible,
helpstring("Collection of RADIUS servers"),
pointer_default(unique)
]
interface IFPCRadiusServers : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCRadiusServer** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_ADD), helpstring("Adds a RADIUS server to the collection")]
          HRESULT Add( BSTR Name,
              [out,retval] IFPCRadiusServer** ppNewRadiusServer);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a RADIUS server from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(1), helpstring("Gets or sets the number of times an authentication request is retried")]
    HRESULT Retries([out, retval] long *pVal);
    [propput, id(1), helpstring("Gets or sets the number of times an authentication request is retried")]
    HRESULT Retries([in] long newVal);
	
	[propget, id(2), helpstring("Gets or sets the time during which a RADIUS server that failed to respond to retried requests will remain unavailable for subsequent requests")]
    HRESULT UnavailabilityTime([out, retval] long *pVal);
    [propput, id(2), helpstring("Gets or sets the time during which a RADIUS server that failed to respond to retried requests will remain unavailable for subsequent requests")]
    HRESULT UnavailabilityTime([in] long newVal);
	
	[id(3), helpstring("Moves the given server one step up in the order")]
          HRESULT MoveUp( long index);
        
    
	[id(4), helpstring("Moves the given server one step down in the order")]
          HRESULT MoveDown( long index);
        
    
};
	
[
object,
uuid(3D78941C-C427-415E-B5AD-C8EB19E71660),
dual,
helpstring("A RADIUS server"),
pointer_default(unique)
]
interface IFPCRadiusServer : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the RADIUS server")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the RADIUS server")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets the description of the RADIUS server")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(2), helpstring("Gets or sets the description of the RADIUS server")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(3), helpstring("Gets or sets the amount of time allowed for a connection to be established with the server")]
    HRESULT ConnectionTimeout([out, retval] long *pVal);
    [propput, id(3), helpstring("Gets or sets the amount of time allowed for a connection to be established with the server")]
    HRESULT ConnectionTimeout([in] long newVal);
	
	[propget, id(4), helpstring("Gets or sets the authentication port for connecting with the RADIUS server")]
    HRESULT Port([out, retval] long *pVal);
    [propput, id(4), helpstring("Gets or sets the authentication port for connecting with the RADIUS server")]
    HRESULT Port([in] long newVal);
	
	[propget, id(5), helpstring("Gets the ordinal position of the RADIUS server in the collection of RADIUS servers")]
    HRESULT Order([out, retval] long *pVal);
	
	
    [propput, id(6), helpstring("Sets the shared secret, an encryption key used by the RADIUS server")]
    HRESULT SharedSecret([in] BSTR newVal);
	
	[propget, id(7), helpstring("Gets or sets whether the message authenticator is always used")]
    HRESULT AlwaysUseMessageAuthenticator([out, retval] VARIANT_BOOL *pVal);
    [propput, id(7), helpstring("Gets or sets whether the message authenticator is always used")]
    HRESULT AlwaysUseMessageAuthenticator([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(B26CDD12-2C6B-46e5-9715-D100FCF4E414),
dual,
nonextensible,
helpstring("A RADIUS server"),
pointer_default(unique)
]
interface IFPCRadiusServer2 : IFPCRadiusServer
{
	[propget, id(8), helpstring("Gets or sets the accounting  port for connecting to the RADIUS server")]
    HRESULT AccountingPort([out, retval] long *pVal);
    [propput, id(8), helpstring("Gets or sets the accounting  port for connecting to the RADIUS server")]
    HRESULT AccountingPort([in] long newVal);
	
	[propget, id(9), helpstring("Gets or sets a Boolean value that indicates whether the RADIUS server is used for authentication")]
    HRESULT UsedForAuthentication([out, retval] VARIANT_BOOL *pVal);
    [propput, id(9), helpstring("Gets or sets a Boolean value that indicates whether the RADIUS server is used for authentication")]
    HRESULT UsedForAuthentication([in] VARIANT_BOOL newVal);
	
	[propget, id(10), helpstring("Gets or sets a Boolean value that indicates whether the RADIUS server is used for accounting")]
    HRESULT UsedForAccounting([out, retval] VARIANT_BOOL *pVal);
    [propput, id(10), helpstring("Gets or sets a Boolean value that indicates whether the RADIUS server is used for accounting")]
    HRESULT UsedForAccounting([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(2355E5B5-5491-4058-B3E2-84B8589C051D),
dual,
nonextensible,
helpstring("Collection of user sets"),
pointer_default(unique)
]
interface IFPCUserSets : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCUserSet** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Adds a user set to the collection")]
          HRESULT Add( BSTR Name,
              [out,retval] IFPCUserSet** ppNewSet);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a user set")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
};
	
[
object,
uuid(8FE8B9D3-AB7E-4F08-88B3-68CA87F30782),
dual,
nonextensible,
helpstring("A user set"),
pointer_default(unique)
]
interface IFPCUserSet : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the user set")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the user set")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the description of the user set")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the description of the user set")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets whether the user set is a preinstalled rule element that cannot be deleted")]
    HRESULT Predefined([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(3), helpstring("Gets the collection of Active Directory accounts included in the user set")]
    HRESULT Accounts([out, retval] IFPCAccounts **pVal);
	
	[propget, id(4), helpstring("Gets the collection of authenticated users that are not active directory accounts, that are included in the user set")]
    HRESULT NonWindowsUsers([out, retval] IFPCNonWindowsUsers **pVal);
	
};
	
[
object,
uuid(6CC321AB-516F-44B5-9CE9-0FEE5A27CA14),
dual,
nonextensible,
helpstring("Collection of AD accounts"),
pointer_default(unique)
]
interface IFPCAccounts : IDispatch
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCAccount** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[id(DISPID_ADD), helpstring("Adds an account to the collection")]
          HRESULT Add([in] BSTR Account,
              [out,retval] IFPCAccount** ppVal);
        
    
	[id(DISPID_REMOVE), helpstring("Removes an account from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[id(6), helpstring("Removes all of the accounts from the collection")]
          HRESULT RemoveAll();
        
    
	[id(7), helpstring("method AddBySid"), hidden]
          HRESULT AddBySid( VARIANT SafeArraySid,
               BSTR SamName,
               FpcAccountTypes AccType,
              [out,retval] IFPCAccount** ppVal);
        
    
};
	
[
object,
uuid(A620E869-C483-49EF-9D76-CD3B1BD678D3),
dual,
helpstring("Collection of authenticated users that do not have AD accounts"),
pointer_default(unique)
]
interface IFPCNonWindowsUsers : IDispatch
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item([in] VARIANT IndexOrUsername,
              [in,defaultvalue(NULL)] BSTR Namespace,
              [out,retval] IFPCNonWindowsUser** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[id(DISPID_ADD), helpstring("Adds a user to the collection")]
          HRESULT Add([in] BSTR Username,
              [in] BSTR Namespace,
              [out,retval] IFPCNonWindowsUser** ppVal);
        
    
	[id(6), helpstring("Adds the 'Everyone' user of the given namespace to the collection")]
          HRESULT AddEveryoneUserOfNamespace([in] BSTR Namespace,
              [out,retval] IFPCNonWindowsUser** ppVal);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a user from the collection")]
          HRESULT Remove([in] VARIANT IndexOrUsername,
              [in,defaultvalue(NULL)] BSTR Namespace);
        
    
	[id(8), helpstring("Removes the 'Everyone' user of the given namespace from the collection")]
          HRESULT RemoveEveryoneUserOfNamespace([in] BSTR Namespace);
        
    
	[id(9), helpstring("Removes all of the users from the collection")]
          HRESULT RemoveAll();
        
    
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
};
	
[
object,
uuid(dc8a741f-f68a-4a4b-8c78-37d6a4243d39),
dual,
nonextensible,
helpstring("Collection of authenticated users that do not have AD accounts"),
pointer_default(unique)
]
interface IFPCNonWindowsUsers2 : IFPCNonWindowsUsers
{
	[id(10), helpstring("Adds a LDAP user to the collection")]
          HRESULT AddLdapUser([in] BSTR Username,
              [in] BSTR LdapServerUsername,
              [in] BSTR LdapServerUserPassword,
              [in] BSTR LdapServerSetName,
              [out,retval] IFPCNonWindowsUser** ppVal);
        
    
};
	
[
object,
uuid(5FF316F0-3E2E-4495-AC08-5C6B55572CB2),
dual,
nonextensible,
helpstring("An AD account"),
pointer_default(unique)
]
interface IFPCAccount : IDispatch
{
	[propget, id(1), helpstring("Gets or sets the domain and name of the account")]
    HRESULT Account([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the domain and name of the account")]
    HRESULT Account([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets the account type")]
    HRESULT AccountType([out, retval] FpcAccountTypes *pVal);
	
	[propget, id(3), helpstring(""), hidden]
    HRESULT Sid([out, retval] VARIANT *pVal);
	
};
	
[
object,
uuid(EF2CBA01-634B-4079-AEEE-B6E2560C68D1),
dual,
helpstring("An authenticated user who does not have an AD account"),
pointer_default(unique)
]
interface IFPCNonWindowsUser : IDispatch
{
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the user name")]
    HRESULT UserName([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the user name")]
    HRESULT UserName([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets the authentication namespace for the user")]
    HRESULT Namespace([out, retval] BSTR *pVal);
	
};
	
[
object,
uuid(84590118-81f4-4b6a-aaf2-869ff8f7db2b),
dual,
nonextensible,
helpstring("An authenticated user"),
pointer_default(unique)
]
interface IFPCNonWindowsUser2 : IFPCNonWindowsUser
{
	[propget, id(10), helpstring("Gets or sets the display user name")]
    HRESULT DisplayUserName([out, retval] BSTR *pVal);
    [propput, id(10), helpstring("Gets or sets the display user name")]
    HRESULT DisplayUserName([in] BSTR newVal);
	
	[propget, id(11), helpstring("Gets or sets the realm")]
    HRESULT Realm([out, retval] BSTR *pVal);
    [propput, id(11), helpstring("Gets or sets the realm")]
    HRESULT Realm([in] BSTR newVal);
	
};
	
[
object,
uuid(7970AF8E-33C0-4D07-A4CD-551DB4DA1AD8),
dual,
nonextensible,
helpstring("A credentials object"),
pointer_default(unique)
]
interface IFPCCredentials : IDispatch
{
	[propget, id(2), helpstring("Gets or sets the user name")]
    HRESULT UserName([out, retval] BSTR *pVal);
    [propput, id(2), helpstring("Gets or sets the user name")]
    HRESULT UserName([in] BSTR newVal);
	
	
    [propput, id(3), helpstring("Sets the Password")]
    HRESULT Password([in] BSTR newVal);
	
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
};
	
[
object,
uuid(A93781CE-26D5-4017-9140-4B219FCCC4A6),
dual,
helpstring("Collection of logs"),
pointer_default(unique)
]
interface IFPCLogs : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( FpcLoggingComponents lc,
              [out,retval] IFPCLog** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[propget, id(1), helpstring("Deprecated - use IFPCLogs2::IsaDatabaseNumberOfInsertsPerBatch instead")]
    HRESULT MSDENumberOfInsertsPerBatch([out, retval] long *pVal);
    [propput, id(1), helpstring("Deprecated - use IFPCLogs2::IsaDatabaseNumberOfInsertsPerBatch instead")]
    HRESULT MSDENumberOfInsertsPerBatch([in] long newVal);
	
	[propget, id(2), helpstring("Deprecated - use IFPCLogs2::IsaDatabaseQueryTimeout instead")]
    HRESULT MSDEQueryTimeout([out, retval] long *pVal);
    [propput, id(2), helpstring("Deprecated - use IFPCLogs2::IsaDatabaseQueryTimeout instead")]
    HRESULT MSDEQueryTimeout([in] long newVal);
	
};
	
[
object,
uuid(D8B43E77-6DB3-4d5e-9400-618F9996515E),
dual,
helpstring("Collection of logs"),
pointer_default(unique)
]
interface IFPCLogs2 : IFPCLogs
{
	[propget, id(3), helpstring("Gets or sets the ISA Log Database log buffer size")]
    HRESULT IsaDatabaseNumberOfInsertsPerBatch([out, retval] long *pVal);
    [propput, id(3), helpstring("Gets or sets the ISA Log Database log buffer size")]
    HRESULT IsaDatabaseNumberOfInsertsPerBatch([in] long newVal);
	
	[propget, id(4), helpstring("Gets or sets the ISA Log Database query timeout")]
    HRESULT IsaDatabaseQueryTimeout([out, retval] long *pVal);
    [propput, id(4), helpstring("Gets or sets the ISA Log Database query timeout")]
    HRESULT IsaDatabaseQueryTimeout([in] long newVal);
	
	[propget, id(5), helpstring("Gets or sets the SQL Server log buffer size")]
    HRESULT SQLNumberOfInsertsPerBatch([out, retval] long *pVal);
    [propput, id(5), helpstring("Gets or sets the SQL Server log buffer size")]
    HRESULT SQLNumberOfInsertsPerBatch([in] long newVal);
	
};
	
[
object,
uuid(027DEBB3-73FF-48f4-812F-6B43733590D8),
dual,
nonextensible,
helpstring("Collection of logs"),
pointer_default(unique)
]
interface IFPCLogs3 : IFPCLogs2
{
	[propget, id(6), helpstring("Gets or sets the path of the directory where the log queue is stored")]
    HRESULT LogQueueDirectory([out, retval] BSTR *pVal);
    [propput, id(6), helpstring("Gets or sets the path of the directory where the log queue is stored")]
    HRESULT LogQueueDirectory([in] BSTR newVal);
	
	[propget, id(7), helpstring("Gets or sets a value from the FpcLogFileDirectoryType enumerated type that indicates the type of path specified for the directory where the log queue is stored")]
    HRESULT LogQueueDirectoryType([out, retval] FpcLogFileDirectoryType *pVal);
    [propput, id(7), helpstring("Gets or sets a value from the FpcLogFileDirectoryType enumerated type that indicates the type of path specified for the directory where the log queue is stored")]
    HRESULT LogQueueDirectoryType([in] FpcLogFileDirectoryType newVal);
	
};
	
[
object,
uuid(1C697244-2DEE-4787-A291-28C3564C7C3B),
dual,
helpstring("A log"),
pointer_default(unique)
]
interface IFPCLog : IFPCPersist
{
	[propget, id(3), helpstring("Gets the type of Forefront TMG component to which this log configuration belongs")]
    HRESULT ComponentType([out, retval] FpcLoggingComponents *pVal);
	
	[propget, id(10), helpstring("Gets or sets the type (format) of the log")]
    HRESULT LogType([out, retval] FpcLogType *pVal);
    [propput, id(10), helpstring("Gets or sets the type (format) of the log")]
    HRESULT LogType([in] FpcLogType newVal);
	
	[propget, id(12), helpstring("Gets or sets a bit field selection of logged columns")]
    HRESULT LogFieldSelection([out, retval] long *pVal);
    [propput, id(12), helpstring("Gets or sets a bit field selection of logged columns")]
    HRESULT LogFieldSelection([in] long newVal);
	
	[propget, id(13), helpstring("Gets or sets whether text log files are compressed")]
    HRESULT LogFilesCompress([out, retval] VARIANT_BOOL *pVal);
    [propput, id(13), helpstring("Gets or sets whether text log files are compressed")]
    HRESULT LogFilesCompress([in] VARIANT_BOOL newVal);
	
	[propget, id(14), helpstring("Gets or sets the number of log history days to keep")]
    HRESULT LogFileKeepOld([out, retval] long *pVal);
    [propput, id(14), helpstring("Gets or sets the number of log history days to keep")]
    HRESULT LogFileKeepOld([in] long newVal);
	
	[propget, id(15), helpstring("Gets or sets the path of the directory containing the log files")]
    HRESULT LogFileDirectory([out, retval] BSTR *pVal);
    [propput, id(15), helpstring("Gets or sets the path of the directory containing the log files")]
    HRESULT LogFileDirectory([in] BSTR newVal);
	
	[propget, id(16), helpstring("Gets or sets the SQL database source name (DSN)")]
    HRESULT LogDBDataSource([out, retval] BSTR *pVal);
    [propput, id(16), helpstring("Gets or sets the SQL database source name (DSN)")]
    HRESULT LogDBDataSource([in] BSTR newVal);
	
	[propget, id(17), helpstring("Gets or sets the name of the SQL table")]
    HRESULT LogDBTableName([out, retval] BSTR *pVal);
    [propput, id(17), helpstring("Gets or sets the name of the SQL table")]
    HRESULT LogDBTableName([in] BSTR newVal);
	
	[propget, id(18), helpstring("Gets or sets the user name of the SQL table")]
    HRESULT LogDBUserName([out, retval] BSTR *pVal);
    [propput, id(18), helpstring("Gets or sets the user name of the SQL table")]
    HRESULT LogDBUserName([in] BSTR newVal);
	
	
    [propput, id(19), helpstring("Sets the password for the SQL table")]
    HRESULT LogDBPassword([in] BSTR newVal);
	
	[propget, id(20), helpstring("Gets or sets a value from the FpcLogFileDirectoryType enumerated type that indicates the type of path specified for the log files")]
    HRESULT LogFileDirectoryType([out, retval] FpcLogFileDirectoryType *pVal);
    [propput, id(20), helpstring("Gets or sets a value from the FpcLogFileDirectoryType enumerated type that indicates the type of path specified for the log files")]
    HRESULT LogFileDirectoryType([in] FpcLogFileDirectoryType newVal);
	
	[propget, id(21), helpstring("Gets or sets whether logging is enabled")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(21), helpstring("Gets or sets whether logging is enabled")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(22), helpstring("Gets or sets whether total log size limit is enabled")]
    HRESULT LimitTotalLogSize([out, retval] VARIANT_BOOL *pVal);
    [propput, id(22), helpstring("Gets or sets whether total log size limit is enabled")]
    HRESULT LimitTotalLogSize([in] VARIANT_BOOL newVal);
	
	[propget, id(23), helpstring("Gets or sets the maximal total size of the log files")]
    HRESULT MaxTotalLogSizeGB([out, retval] long *pVal);
    [propput, id(23), helpstring("Gets or sets the maximal total size of the log files")]
    HRESULT MaxTotalLogSizeGB([in] long newVal);
	
	[propget, id(24), helpstring("Gets or sets whether free disk space limit is enabled")]
    HRESULT KeepMinFreeDiskSpace([out, retval] VARIANT_BOOL *pVal);
    [propput, id(24), helpstring("Gets or sets whether free disk space limit is enabled")]
    HRESULT KeepMinFreeDiskSpace([in] VARIANT_BOOL newVal);
	
	[propget, id(25), helpstring("Gets or sets the minimal free disk space")]
    HRESULT MinFreeDiskSpaceMB([out, retval] long *pVal);
    [propput, id(25), helpstring("Gets or sets the minimal free disk space")]
    HRESULT MinFreeDiskSpaceMB([in] long newVal);
	
	[propget, id(26), helpstring("Gets or sets whether to delete older logs when total log size or required free disk space is exceeded")]
    HRESULT DeleteOldLogsOnLimitExceeded([out, retval] VARIANT_BOOL *pVal);
    [propput, id(26), helpstring("Gets or sets whether to delete older logs when total log size or required free disk space is exceeded")]
    HRESULT DeleteOldLogsOnLimitExceeded([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(051E85D5-C0EB-4120-BC97-87013CE39B6F),
dual,
helpstring("A EE log"),
pointer_default(unique)
]
interface IFPCEELog : IFPCLog
{
	[propget, id(28), helpstring("Gets or sets the SQL Authentication method")]
    HRESULT SQLAuthType([out, retval] FpcSQLAuthType *pVal);
    [propput, id(28), helpstring("Gets or sets the SQL Authentication method")]
    HRESULT SQLAuthType([in] FpcSQLAuthType newVal);
	
	[propget, id(29), helpstring("Gets or sets the SQL server name ")]
    HRESULT SQLServerName([out, retval] BSTR *pVal);
    [propput, id(29), helpstring("Gets or sets the SQL server name ")]
    HRESULT SQLServerName([in] BSTR newVal);
	
	[propget, id(30), helpstring("Gets or sets the SQL server port ")]
    HRESULT SQLServerPort([out, retval] long *pVal);
    [propput, id(30), helpstring("Gets or sets the SQL server port ")]
    HRESULT SQLServerPort([in] long newVal);
	
	[propget, id(31), helpstring("Gets or sets the SQL database ")]
    HRESULT SQLDatabase([out, retval] BSTR *pVal);
    [propput, id(31), helpstring("Gets or sets the SQL database ")]
    HRESULT SQLDatabase([in] BSTR newVal);
	
	[propget, id(32), helpstring("Gets or sets whether to drop a connection when logging fails due to a full buffer")]
    HRESULT DropConnectionOnLogError([out, retval] VARIANT_BOOL *pVal);
    [propput, id(32), helpstring("Gets or sets whether to drop a connection when logging fails due to a full buffer")]
    HRESULT DropConnectionOnLogError([in] VARIANT_BOOL newVal);
	
	[propget, id(33), helpstring("Gets or sets whether to force encryption when logging to SQL database")]
    HRESULT SQLForceEncryption([out, retval] VARIANT_BOOL *pVal);
    [propput, id(33), helpstring("Gets or sets whether to force encryption when logging to SQL database")]
    HRESULT SQLForceEncryption([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(57440140-7301-47b0-AE8C-87905ED8F4BB),
dual,
nonextensible,
helpstring("A log"),
pointer_default(unique)
]
interface IFPCLog2 : IFPCEELog
{
	[propget, id(34), helpstring("Gets or sets a string in which each character specifies whether a particular log field is selected for logging.")]
    HRESULT LogFieldSelectionString([out, retval] BSTR *pVal);
    [propput, id(34), helpstring("Gets or sets a string in which each character specifies whether a particular log field is selected for logging.")]
    HRESULT LogFieldSelectionString([in] BSTR newVal);
	
};
	
[
object,
uuid(9f140706-af1e-4902-abd4-365c77931637),
dual,
nonextensible,
helpstring("A Sessions Monitor entry"),
pointer_default(unique)
]
interface IFPCSessionsMonitorEntry : IDispatch
{
	[propget, id(1), helpstring("Gets the session event")]
    HRESULT Event([out, retval] FpcSessionMonitorEvent *pVal);
    [propput, id(1), helpstring("Gets the session event")]
    HRESULT Event([in] FpcSessionMonitorEvent newVal);
	
	[propget, id(2), helpstring("Gets the client IP")]
    HRESULT ClientIP([out, retval] BSTR *pVal);
	
	[propget, id(3), helpstring("Gets the Client UserName")]
    HRESULT ClientUserName([out, retval] BSTR *pVal);
	
	[propget, id(4), helpstring("Gets the Client UserName")]
    HRESULT ClientProcess([out, retval] BSTR *pVal);
	
	[propget, id(5), helpstring("Gets the Server name")]
    HRESULT ServerName([out, retval] BSTR *pVal);
	
	[propget, id(6), helpstring("Gets the SourceNetwork")]
    HRESULT SourceNetwork([out, retval] BSTR *pVal);
    [propput, id(6), helpstring("Gets the SourceNetwork")]
    HRESULT SourceNetwork([in] BSTR newVal);
	
	[propget, id(7), helpstring("Gets the SourceNetworkType")]
    HRESULT SourceNetworkType([out, retval] FpcNetworkTypes *pVal);
    [propput, id(7), helpstring("Gets the SourceNetworkType")]
    HRESULT SourceNetworkType([in] FpcNetworkTypes newVal);
	
	[propget, id(8), helpstring("Gets the Client Computer")]
    HRESULT ClientComputer([out, retval] BSTR *pVal);
	
	[propget, id(9), helpstring("Gets the Activation Time")]
    HRESULT Activation([out, retval] DATE *pVal);
	
	[propget, id(10), helpstring("Gets the Session Type")]
    HRESULT SessionType([out, retval] FpcSessionType *pVal);
	
	[propget, id(11), helpstring("Gets the Session ID")]
    HRESULT SessionID([out, retval] BSTR *pVal);
	
};
	
[
object,
uuid(cf298d7f-a8d4-4dbf-b173-f3913f985c3c),
dual,
nonextensible,
helpstring("Sessions monitor"),
pointer_default(unique)
]
interface IFPCSessionsMonitor : IDispatch
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( long index,
              [out,retval] IFPCSessionsMonitorEntry** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(1), helpstring("Start a new query in all servers")]
          HRESULT ExecuteQuery([in] IFPCFilterExpressions* pFilter,
              [in] long nBufferSize);
        
    
	[id(2), helpstring("end the query in all servers")]
          HRESULT EndQuery();
        
    
	[id(3), helpstring("Disconnect a session by ID")]
          HRESULT DisconnectSession([in] BSTR ServerName,
              [in] BSTR SessionID);
        
    
	[id(4), helpstring("Returns a specific item from the collection")]
          HRESULT ItemAsync( long index,
              [out,retval] IFPCSessionsMonitorEntry** pItem);
        
    
};
	
[
object,
uuid(ad9d95b0-246e-4595-92fc-205ca49ee530),
dual,
nonextensible,
helpstring("Sessions monitors"),
pointer_default(unique)
]
interface IFPCSessionsMonitors : IDispatch
{
	[propget, id(1), helpstring("Gets the Firewall Sessions Monitor")]
    HRESULT SessionsMonitorFirewall([out, retval] IFPCSessionsMonitor **pVal);
	
	[propget, id(2), helpstring("Gets the Web Proxy Sessions Monitor")]
    HRESULT SessionsMonitorWebProxy([out, retval] IFPCSessionsMonitor **pVal);
	
};
	
[
object,
uuid(4F7C09AB-F359-4C2B-BCA5-0974AADD0202),
dual,
helpstring("log viewer object"),
pointer_default(unique)
]
interface IFPCLogViewer : IDispatch
{
	[propget, id(1), helpstring("Deprecated - use IFPCLogViewer2::LogContentIsaDatabase instead")]
    HRESULT LogContentMSDE([out, retval] IFPCLogContent **pVal);
	
	[propget, id(2), helpstring("Gets the online log content")]
    HRESULT LogContentOnline([out, retval] IFPCLogContent **pVal);
	
};
	
[
object,
uuid(49448F08-49E1-42ca-B0F1-9982E2F30012),
dual,
nonextensible,
helpstring("log viewer object"),
pointer_default(unique)
]
interface IFPCLogViewer2 : IFPCLogViewer
{
	[propget, id(3), helpstring("Gets the ISA Log Database log content")]
    HRESULT LogContentIsaDatabase([out, retval] IFPCLogContent **pVal);
	
};
	
[
object,
uuid(FB08D09B-E11E-4DBA-8EFB-71103F702605),
dual,
helpstring("Collection of log entries"),
pointer_default(unique)
]
interface IFPCLogContent : IDispatch
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( long index,
              [out,retval] IFPCLogEntry** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(1), helpstring("Start a new query in all servers")]
          HRESULT ExecuteQuery([in] IFPCFilterExpressions* pQuery,
              [in] long MaxRowsToFetch);
        
    
	[id(2), helpstring("end the query in all servers")]
          HRESULT EndQuery();
        
    
	[id(3), helpstring("Returns a specific item from the collection")]
          HRESULT ItemAsync( long index,
              [out,retval] IFPCLogEntry** pItem);
        
    
};
	
[
object,
uuid(863DAEFE-BB47-4a44-AEB2-0B03B1CE9452),
dual,
nonextensible,
helpstring("Collection of log entries"),
pointer_default(unique)
]
interface IFPCEELogContent : IFPCLogContent
{
	[id(4), helpstring("Returns the connectivity status of the array")]
          HRESULT AreAllServersUp([out,retval] VARIANT_BOOL* pVal);
        
    
};
	
[
object,
uuid(4DCF952A-AB3C-4AA5-A136-2E687AF92AD1),
dual,
helpstring("Array policy"),
pointer_default(unique)
]
interface IFPCArrayPolicy : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the policy")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the policy")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the description of the policy")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the description of the policy")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets a collection of all policy rules in this array")]
    HRESULT PolicyRules([out, retval] IFPCPolicyRules **pVal);
	
	[propget, id(3), helpstring("Gets the object that provides access to Web proxy properties")]
    HRESULT WebProxy([out, retval] IFPCWebProxy **pVal);
	
	[propget, id(4), helpstring("Gets The attack detection configuration on this array")]
    HRESULT AttackDetection([out, retval] IFPCAttackDetection **pVal);
	
	[propget, id(5), helpstring("Gets the object that provides access to ConnectionLimit properties")]
    HRESULT ConnectionLimitPolicy([out, retval] IFPCConnectionLimitPolicy **pVal);
	
	[propget, id(6), helpstring("property LowLevelSettings")]
    HRESULT LowLevelSettings([out, retval] IFPCLowLevelSettings **pVal);
	
};
	
[
object,
uuid(6faaa3d3-a238-4fb4-b68c-b4648f7a0c1a),
dual,
helpstring("Array policy"),
pointer_default(unique)
]
interface IFPCArrayPolicy2 : IFPCArrayPolicy
{
	[propget, id(7), helpstring("Gets or sets a Boolean value that indicates whether the Web Access Wizard was completed"), hidden]
    HRESULT CompletedWebAccessWizard([out, retval] VARIANT_BOOL *pVal);
    [propput, id(7), helpstring("Gets or sets a Boolean value that indicates whether the Web Access Wizard was completed"), hidden]
    HRESULT CompletedWebAccessWizard([in] VARIANT_BOOL newVal);
	
	[propget, id(8), helpstring("Gets the object that controls SIP related settings")]
    HRESULT SipSettings([out, retval] IFPCSipSettings **pVal);
	
	[propget, id(9), helpstring("Gets a FPCRestrictedPorts object that holds list of port ranges prohibited for binding on behalf of client")]
    HRESULT RestrictedPorts([out, retval] IFPCRestrictedPorts **pVal);
	
};
	
[
object,
uuid(93BC6A6C-BC80-4C5D-B95F-30BC7C28BEAE),
dual,
nonextensible,
helpstring("Array policy"),
pointer_default(unique)
]
interface IFPCArrayPolicy3 : IFPCArrayPolicy2
{
	[propget, id(10), helpstring("Gets the object that controls IPv6 related settings")]
    HRESULT IPv6Settings([out, retval] IFPCIPv6Settings **pVal);
	
};
	
[
object,
uuid(fe6cd94a-228b-4b82-8fad-781ced3141df),
dual,
nonextensible,
helpstring("Network Inspection System"),
pointer_default(unique)
]
interface IFPCNetworkInspectionSystem : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets a Boolean value that indicates whether the network inspection system is enabled")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets a Boolean value that indicates whether the network inspection system is enabled")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(2), helpstring("Gets or sets a value from the FpcNisInitialSignatureConfiguration enumerated type that specifies the initial configuration for the signature")]
    HRESULT InitialSignatureConfiguration([out, retval] FpcNisInitialSignatureConfiguration *pVal);
    [propput, id(2), helpstring("Gets or sets a value from the FpcNisInitialSignatureConfiguration enumerated type that specifies the initial configuration for the signature")]
    HRESULT InitialSignatureConfiguration([in] FpcNisInitialSignatureConfiguration newVal);
	
	[propget, id(3), helpstring("Gets an FPCSelectionIPs object that specifies the IP addresses for which the network inspection system is not enabled")]
    HRESULT ExcludedIPs([out, retval] IFPCSelectionIPs **pVal);
	
	[propget, id(4), helpstring("Gets an FPCRefs collection that contains references to destination HTTP domain names for which the network inspection system is not enabled in HTTP protocol")]
    HRESULT ExcludedHttpDomainNameSets([out, retval] IFPCRefs **pVal);
	
	[id(5), helpstring("Resets the signatures configuration")]
          HRESULT ResetConfiguration([in] FpcNisInitialSignatureConfiguration eResetVal);
        
    
	[propget, id(6), helpstring("Gets an FPCNisSignatureSet object that specifies the active signature set")]
    HRESULT ActiveSignatureSet([out, retval] IFPCNisSignatureSet **pVal);
	
	[propget, id(7), helpstring("Gets an FPCNisAvailableSignatureSets collection that contains all available signature sets")]
    HRESULT AvailableSignatureSets([out, retval] IFPCNisAvailableSignatureSets **pVal);
	
	[id(8), helpstring("Activate the most recent or a specified signature set")]
          HRESULT ActivateSignatureSet([in] VARIANT_BOOL MostRecent,
              [in,defaultvalue(NULL)] IFPCNisAvailableSignatureSet* SignatureSet);
        
    
	[propget, id(9), helpstring("Gets a Boolean value that indicates whether the most recent signature set is used")]
    HRESULT MostRecentSignatureSetUsed([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(10), helpstring("Gets a key of the selected signature set"), hidden]
    HRESULT SelectedSignatureSet([out, retval] BSTR *pVal);
	
	[propget, id(11), helpstring("Gets an FPCNisSignatureConfigurations collection that contains the signature configurations for the network inspection system"), hidden]
    HRESULT SignatureConfigurations([out, retval] IFPCNisSignatureConfigurations **pVal);
	
	[propget, id(12), helpstring("Gets or sets a value from the FpcNisProtocolAnomaliesPolicy enumerated type that indicates the network inspection system policy for protocol anomalies")]
    HRESULT ProtocolAnomaliesPolicy([out, retval] FpcNisProtocolAnomaliesPolicy *pVal);
    [propput, id(12), helpstring("Gets or sets a value from the FpcNisProtocolAnomaliesPolicy enumerated type that indicates the network inspection system policy for protocol anomalies")]
    HRESULT ProtocolAnomaliesPolicy([in] FpcNisProtocolAnomaliesPolicy newVal);
	
	[propget, id(13), helpstring("Gets a reference to the collection of references to protocols which network inspection system will inspect on local host")]
    HRESULT ProtocolsInspectedOnLocalHost([out, retval] IFPCRefs **pVal);
	
};
	
[
hidden,
object,
uuid(1AE4DE3F-B044-4FE1-8E6D-898710BB3DCB),
dual,
nonextensible,
helpstring("Collection of network inspection system signature configuration objects"),
pointer_default(unique)
]
interface IFPCNisSignatureConfigurations : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Retrieves an IFPCNisSignatureConfiguration object from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCNisSignatureConfiguration** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Creates a new FPCNisSignatureConfiguration object for the specified signature and returns a reference to it")]
          HRESULT Add([in] BSTR SignatureId,
              [out,retval] IFPCNisSignatureConfiguration** ppVal);
        
    
	[id(DISPID_REMOVE), helpstring("Removes the specified FPCNisSignatureConfiguration object from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[id(1), helpstring("Removes configuration of all signatures")]
          HRESULT RemoveAll();
        
    
};
	
[
hidden,
object,
uuid(F6BDECF7-5C23-4247-9325-A80BC8CF4608),
dual,
nonextensible,
helpstring("A single network inspection system signature configuration"),
pointer_default(unique)
]
interface IFPCNisSignatureConfiguration : IFPCPersist
{
	[propget, id(1), helpstring("Gets the GUID of the signature")]
    HRESULT Id([out, retval] BSTR *pVal);
	
	[propget, id(2), helpstring("Gets or sets a Boolean value that indicates whether the signature use custom configuration")]
    HRESULT CustomPolicyUsed([out, retval] VARIANT_BOOL *pVal);
    [propput, id(2), helpstring("Gets or sets a Boolean value that indicates whether the signature use custom configuration")]
    HRESULT CustomPolicyUsed([in] VARIANT_BOOL newVal);
	
	[propget, id(3), helpstring("Gets or sets a Boolean value that indicates whether the signature is enabled")]
    HRESULT CustomStatus([out, retval] VARIANT_BOOL *pVal);
    [propput, id(3), helpstring("Gets or sets a Boolean value that indicates whether the signature is enabled")]
    HRESULT CustomStatus([in] VARIANT_BOOL newVal);
	
	[propget, id(4), helpstring("Gets or sets a value from the FpcNisSignatureResponse enumerated type that specifies the response for the signature")]
    HRESULT CustomResponse([out, retval] FpcNisSignatureResponse *pVal);
    [propput, id(4), helpstring("Gets or sets a value from the FpcNisSignatureResponse enumerated type that specifies the response for the signature")]
    HRESULT CustomResponse([in] FpcNisSignatureResponse newVal);
	
	[propget, id(5), helpstring("Gets or sets the administrator notes regarding the signature")]
    HRESULT Notes([out, retval] BSTR *pVal);
    [propput, id(5), helpstring("Gets or sets the administrator notes regarding the signature")]
    HRESULT Notes([in] BSTR newVal);
	
	[propget, id(6), helpstring("Gets or sets a Boolean value that indicates whether the signature require administrator attention")]
    HRESULT AttentionRequired([out, retval] VARIANT_BOOL *pVal);
    [propput, id(6), helpstring("Gets or sets a Boolean value that indicates whether the signature require administrator attention")]
    HRESULT AttentionRequired([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(34ef6593-cf10-4b1b-ba20-75ce026f7bab),
dual,
nonextensible,
helpstring("A network inspection system signature set"),
pointer_default(unique)
]
interface IFPCNisSignatureSet : IDispatch
{
	[propget, id(1), helpstring("Gets an FPCNisSignatures collection that contains the set of signatures")]
    HRESULT Signatures([out, retval] IFPCNisSignatures **pVal);
	
	[propget, id(2), helpstring("Gets the major version of the signature set")]
    HRESULT MajorVersion([out, retval] unsigned short *pVal);
	
	[propget, id(3), helpstring("Gets the minor version of the signature set")]
    HRESULT MinorVersion([out, retval] unsigned short *pVal);
	
	[propget, id(4), helpstring("Gets a DATE value that specifies the date and time in Coordinated Universal Time (UTC) when the signature set was released")]
    HRESULT ReleaseDate([out, retval] DATE *pVal);
	
};
	
[
object,
uuid(d14dc991-22c1-4a28-a063-470c423b143b),
dual,
nonextensible,
helpstring("Collection of network inspection system signature "),
pointer_default(unique)
]
interface IFPCNisSignatures : IDispatch
{
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Retrieves the specified FPCNisSignature object from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCNisSignature** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
};
	
[
object,
uuid(47838a13-ca87-4c47-b78d-1c1333fe2967),
dual,
nonextensible,
helpstring("A single network inspection system signature"),
pointer_default(unique)
]
interface IFPCNisSignature : IDispatch
{
	[propget, id(1), helpstring("Gets the GUID of the signature")]
    HRESULT Id([out, retval] BSTR *pVal);
	
	[propget, id(2), helpstring("Gets the name of the signature")]
    HRESULT Name([out, retval] BSTR *pVal);
	
	[propget, id(3), helpstring("Gets the description of the signature"), hidden]
    HRESULT Description([out, retval] BSTR *pVal);
	
	[propget, id(4), helpstring("Gets a DATE value that specifies the date and time in Coordinated Universal Time (UTC) when the signature was published")]
    HRESULT DatePublished([out, retval] DATE *pVal);
	
	[propget, id(5), helpstring("Gets the URL of the signature")]
    HRESULT URL([out, retval] BSTR *pVal);
	
	[propget, id(6), helpstring("Gets a delimited list of the Common Vulnerabilities and Exposures (CVE) numbers related to the signature")]
    HRESULT RelatedCVEs([out, retval] BSTR *pVal);
	
	[propget, id(7), helpstring("Gets a delimited list of the related bulletins of the signature")]
    HRESULT RelatedBulletins([out, retval] BSTR *pVal);
	
	[propget, id(8), helpstring("Gets the name of the signature vendor")]
    HRESULT Vendor([out, retval] BSTR *pVal);
	
	[propget, id(9), helpstring("Gets a value from the FpcNisCategory enumerated type that specifies the category of the signature")]
    HRESULT Category([out, retval] FpcNisCategory *pVal);
	
	[propget, id(10), helpstring("Gets a value from the FpcNisSeverityLevel enumerated type that specifies the severity level of the signature")]
    HRESULT SeverityLevel([out, retval] FpcNisSeverityLevel *pVal);
	
	[propget, id(11), helpstring("Gets a value from the FpcNisRiskLevel enumerated type that specifies the risk level of the signature")]
    HRESULT RiskLevel([out, retval] FpcNisRiskLevel *pVal);
	
	[propget, id(12), helpstring("Gets a value from the FpcNisFidelityLevel enumerated type that specifies the fidelity level of the signature")]
    HRESULT FidelityLevel([out, retval] FpcNisFidelityLevel *pVal);
	
	[propget, id(13), helpstring("Gets a value from the FpcNisBusinessImpactLevel enumerated type that specifies the business impact level of the signature")]
    HRESULT BusinessImpactLevel([out, retval] FpcNisBusinessImpactLevel *pVal);
	
	[propget, id(14), helpstring("Gets the protocol of the signature")]
    HRESULT Protocol([out, retval] BSTR *pVal);
	
	[propget, id(15), helpstring("Gets the affected applications of the signature")]
    HRESULT AffectedApplications([out, retval] BSTR *pVal);
	
	[propget, id(16), helpstring("Gets the major version of the signature")]
    HRESULT MajorVersion([out, retval] unsigned short *pVal);
	
	[propget, id(17), helpstring("Gets the minor version of the signature")]
    HRESULT MinorVersion([out, retval] unsigned short *pVal);
	
	[propget, id(18), helpstring("Gets a Boolean value that indicates whether the signature is enabled by default")]
    HRESULT EnabledByDefault([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(19), helpstring("Gets a value from the FpcNisSignatureResponse enumerated type that specifies the default response for the signature")]
    HRESULT DefaultResponse([out, retval] FpcNisSignatureResponse *pVal);
	
	[propget, id(20), helpstring("Gets whether the signature is initial"), hidden]
    HRESULT Initial([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(21), helpstring("Gets or sets a Boolean value that indicates whether the signature uses custom configuration")]
    HRESULT CustomPolicyUsed([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(22), helpstring("Gets or sets a Boolean value that indicates whether the signature is enabled")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(22), helpstring("Gets or sets a Boolean value that indicates whether the signature is enabled")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(23), helpstring("Gets or sets a value from the FpcNisSignatureResponse enumerated type that specifies the response for the signature")]
    HRESULT Response([out, retval] FpcNisSignatureResponse *pVal);
    [propput, id(23), helpstring("Gets or sets a value from the FpcNisSignatureResponse enumerated type that specifies the response for the signature")]
    HRESULT Response([in] FpcNisSignatureResponse newVal);
	
	[propget, id(24), helpstring("Gets or sets the administrator notes regarding the signature")]
    HRESULT Notes([out, retval] BSTR *pVal);
    [propput, id(24), helpstring("Gets or sets the administrator notes regarding the signature")]
    HRESULT Notes([in] BSTR newVal);
	
	[propget, id(25), helpstring("Gets or sets a Boolean value that indicates whether the signature require administrator attention")]
    HRESULT AttentionRequired([out, retval] VARIANT_BOOL *pVal);
    [propput, id(25), helpstring("Gets or sets a Boolean value that indicates whether the signature require administrator attention")]
    HRESULT AttentionRequired([in] VARIANT_BOOL newVal);
	
	[id(26), helpstring("Apply signature default policy")]
          HRESULT ApplyDefaultPolicy();
        
    
};
	
[
object,
uuid(e8e43819-5eee-40ab-9ec9-ed97b68a8192),
dual,
nonextensible,
helpstring("Collection of available network inspection system signature sets"),
pointer_default(unique)
]
interface IFPCNisAvailableSignatureSets : IDispatch
{
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Retrieves the specified FPCNisAvailableSignatureSet object from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCNisAvailableSignatureSet** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

};
	
[
object,
uuid(9f5f575c-cb01-419f-967e-61914a513d9f),
dual,
nonextensible,
helpstring("A single available network inspection system signature set"),
pointer_default(unique)
]
interface IFPCNisAvailableSignatureSet : IDispatch
{
	[propget, id(1), helpstring("Gets the major version of the signature set")]
    HRESULT Name([out, retval] BSTR *pVal);
	
	[propget, id(2), helpstring("Gets the major version of the signature set")]
    HRESULT MajorVersion([out, retval] unsigned short *pVal);
	
	[propget, id(3), helpstring("Gets the minor version of the signature set")]
    HRESULT MinorVersion([out, retval] unsigned short *pVal);
	
	[propget, id(4), helpstring("Gets a DATE value that specifies the date and time in Coordinated Universal Time (UTC) when the signature set was released")]
    HRESULT ReleaseDate([out, retval] DATE *pVal);
	
	[propget, id(5), helpstring("Gets or sets a Boolean value that indicates whether the signature set is activated")]
    HRESULT Activated([out, retval] VARIANT_BOOL *pVal);
	
};
	
[
object,
uuid(D8FEE330-179F-4840-A1F2-45AF6CD296E7),
dual,
nonextensible,
helpstring("System policy"),
pointer_default(unique)
]
interface IFPCSystemPolicy : IFPCPersist
{
	[propget, id(2), helpstring("Gets a collection of all policy rules in this array")]
    HRESULT PolicyRules([out, retval] IFPCSystemPolicyRules **pVal);
	
	[id(3), helpstring("Create system policy rules group instance")]
          HRESULT CreateConfigurationGroupInstance([in] FpcSystemPolicyConfigGroupEnum service,
              [out,retval] IFPCSystemPolicyConfigGroup** ppConfigGroup);
        
    
	[propget, id(4), helpstring("Gets or sets whether DCOM access is enabled in system policy"), hidden]
    HRESULT StrictRPCEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(4), helpstring("Gets or sets whether DCOM access is enabled in system policy"), hidden]
    HRESULT StrictRPCEnabled([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(60EA3725-BDFD-4225-A332-69F20E6906A7),
dual,
nonextensible,
helpstring("System policy Configuration group"),
pointer_default(unique)
]
interface IFPCSystemPolicyConfigGroup : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets whether the config group is enabled")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets whether the config group is enabled")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(2), helpstring("Gets a reference to the source selection IPs to which the rule applies")]
    HRESULT SourceSelectionIPs([out, retval] IFPCSelectionIPs **pVal);
	
	[propget, id(3), helpstring("Gets a reference to the selection destination IPs to which the rule applies")]
    HRESULT DestinationSelectionIPs([out, retval] IFPCSelectionIPs **pVal);
	
	[propget, id(4), helpstring("Gets a reference to the collection of references to the destination domain name sets to which the rule applies")]
    HRESULT DestinationDomainNameSets([out, retval] IFPCRefs **pVal);
	
	[propget, id(5), helpstring("Gets a reference to the collection of references to the Url sets to which the rule applies")]
    HRESULT URLSets([out, retval] IFPCRefs **pVal);
	
};
	
[
object,
uuid(DC79F9BD-0A4E-473d-BCDF-13BE9DB26433),
dual,
nonextensible,
helpstring("A mapping between User-Agent headers and a set of forms for forms-based authentication"),
pointer_default(unique)
]
interface IFPCUserAgentMapping : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets a string that specifies the User-Agent headers")]
    HRESULT UserAgent([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets a string that specifies the User-Agent headers")]
    HRESULT UserAgent([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the description of the User-Agent mapping")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the description of the User-Agent mapping")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets a Boolean value that indicates whether the User-Agent mapping is enabled")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(2), helpstring("Gets or sets a Boolean value that indicates whether the User-Agent mapping is enabled")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(3), helpstring("Gets or sets the type of forms for forms-based authentication that will be associated with the User-Agent headers")]
    HRESULT FBAFormsType([out, retval] FpcFBAFormsTypes *pVal);
    [propput, id(3), helpstring("Gets or sets the type of forms for forms-based authentication that will be associated with the User-Agent headers")]
    HRESULT FBAFormsType([in] FpcFBAFormsTypes newVal);
	
	[propget, id(4), helpstring("Gets the ordinal position of the mapping in the collection of User-Agent mappings")]
    HRESULT Order([out, retval] long *pVal);
	
};
	
[
object,
uuid(1CA709E4-DDF0-460d-9BDA-4A5D384F5EF5),
dual,
nonextensible,
helpstring("Collection of mappings between User-Agent headers and a set of forms for forms-based authentication "),
pointer_default(unique)
]
interface IFPCUserAgentMappings : IFPCPersist
{
	[id(DISPID_ADD), helpstring("Creates a new User-Agent mapping in the collection")]
          HRESULT Add( BSTR UserAgent,
               FpcFBAFormsTypes FormsType,
              [out,retval] IFPCUserAgentMapping** ppNewAssociation);
        
    
	[id(DISPID_REMOVE), helpstring("Removes the specified User-Agent mapping from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Returns the requested User-Agent mapping from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCUserAgentMapping** pServer);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(1), helpstring("Moves the specified mapping one step up the list of User-Agent mappings")]
          HRESULT MoveUp( long index);
        
    
	[id(2), helpstring("Moves the specified mapping one step down the list of User-Agent mappings")]
          HRESULT MoveDown( long index);
        
    
};
	
[
object,
uuid(F371A28F-BDB0-43D4-8697-16EFD100D82F),
dual,
nonextensible,
helpstring("Cache configuration"),
pointer_default(unique)
]
interface IFPCCacheConfiguration : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets whether the Web proxy returns expired cached objects when an updated object cannot be retrieved")]
    HRESULT ReturnExpiredEnable([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets whether the Web proxy returns expired cached objects when an updated object cannot be retrieved")]
    HRESULT ReturnExpiredEnable([in] VARIANT_BOOL newVal);
	
	[propget, id(2), helpstring("Gets or sets the time factor to which the policy set by the ReturnExpiredEnable property applies")]
    HRESULT ReturnExpiredTTLPercent([out, retval] long *pVal);
    [propput, id(2), helpstring("Gets or sets the time factor to which the policy set by the ReturnExpiredEnable property applies")]
    HRESULT ReturnExpiredTTLPercent([in] long newVal);
	
	[propget, id(3), helpstring("Gets or sets the maximum time during which the expired cached object would be returned")]
    HRESULT ReturnExpiredMaxTime([out, retval] long *pVal);
    [propput, id(3), helpstring("Gets or sets the maximum time during which the expired cached object would be returned")]
    HRESULT ReturnExpiredMaxTime([in] long newVal);
	
	[propget, id(4), helpstring("Gets a reference to an object for accessing the active cache configuration")]
    HRESULT ActiveCacheConfiguration([out, retval] IFPCActiveCacheConfiguration **pVal);
	
	[propget, id(5), helpstring("Gets or sets the percentage of physical memory used for the Forefront TMG cache")]
    HRESULT MemoryUsagePercentage([out, retval] long *pVal);
    [propput, id(5), helpstring("Gets or sets the percentage of physical memory used for the Forefront TMG cache")]
    HRESULT MemoryUsagePercentage([in] long newVal);
	
	[propget, id(6), helpstring("Gets or sets the maximum URL size to be cached to physical memory")]
    HRESULT MemoryCacheMaxURLSize([out, retval] long *pVal);
    [propput, id(6), helpstring("Gets or sets the maximum URL size to be cached to physical memory")]
    HRESULT MemoryCacheMaxURLSize([in] long newVal);
	
	[propget, id(7), helpstring("Gets or sets whether caching of replies that are missing the modification date is enabled")]
    HRESULT CacheWithNoLastModDate([out, retval] VARIANT_BOOL *pVal);
    [propput, id(7), helpstring("Gets or sets whether caching of replies that are missing the modification date is enabled")]
    HRESULT CacheWithNoLastModDate([in] VARIANT_BOOL newVal);
	
	[propget, id(8), helpstring("Gets or sets whether caching of replies whose responses were not OK (200) is enabled")]
    HRESULT CacheNon200Responses([out, retval] VARIANT_BOOL *pVal);
    [propput, id(8), helpstring("Gets or sets whether caching of replies whose responses were not OK (200) is enabled")]
    HRESULT CacheNon200Responses([in] VARIANT_BOOL newVal);
	
	[propget, id(9), helpstring("Gets or sets whether requests for objects are queued, if those objects are in the process of being cached")]
    HRESULT QueueRequests([out, retval] VARIANT_BOOL *pVal);
    [propput, id(9), helpstring("Gets or sets whether requests for objects are queued, if those objects are in the process of being cached")]
    HRESULT QueueRequests([in] VARIANT_BOOL newVal);
	
	[propget, id(10), helpstring("Gets the collection of cache rules")]
    HRESULT CacheRules([out, retval] IFPCCacheRules **pVal);
	
};
	
[
object,
uuid(F6B4A304-6C88-4212-AB3E-B74ABE595063),
dual,
nonextensible,
helpstring("Collection of cache rules"),
pointer_default(unique)
]
interface IFPCCacheRules : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCCacheRule** pItem);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Adds a cache rule to the collection")]
          HRESULT Add( BSTR Name,
              [out,retval] IFPCCacheRule** ppNewRule);
        
    
	[id(5), helpstring("Moves the given rule one step up in the order of execution")]
          HRESULT MoveUp( long index);
        
    
	[id(6), helpstring("Moves the given rule one step down in the order of execution")]
          HRESULT MoveDown( long index);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a cache rule from the collection")]
          HRESULT Remove( VARIANT v);
        
    
};
	
[
object,
uuid(F52A49B8-3C60-41F5-98B2-CF72AF3672AB),
dual,
helpstring("A cache rule"),
pointer_default(unique)
]
interface IFPCCacheRule : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets whether the rule is enabled")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets whether the rule is enabled")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the rule")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the rule")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets the description of the rule")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(2), helpstring("Gets or sets the description of the rule")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(3), helpstring("Gets a reference to the collection of URL sets to which the rule applies")]
    HRESULT URLSets([out, retval] IFPCRefs **pVal);
	
	[propget, id(4), helpstring("Gets a reference to the selection destination IPs to which the rule applies")]
    HRESULT DestinationSelectionIPs([out, retval] IFPCSelectionIPs **pVal);
	
	[propget, id(5), helpstring("Gets a reference to the collection of destination domain name sets to which the rule applies")]
    HRESULT DestinationDomainNameSets([out, retval] IFPCRefs **pVal);
	
	[propget, id(6), helpstring("Gets a Boolean value that indicates whether the object size limit specified in the ObjectSizeLimit property is enabled")]
    HRESULT ObjectSizeLimitEnabled([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(7), helpstring("Gets the size of the object that can be cached (this value and ObjectSizeLimitUnits)")]
    HRESULT ObjectSizeLimit([out, retval] long *pVal);
	
	[propget, id(8), helpstring("Gets the units used to measure object size in the ObjectSizeLimit property")]
    HRESULT ObjectSizeLimitUnits([out, retval] FpcSizeUnits *pVal);
	
	[id(9), helpstring("Sets the size boundary according to which objects can or cannot be cached")]
          HRESULT SetSizeBound([in] VARIANT_BOOL Enable,
              [in,defaultvalue(0)] long Size,
              [in,defaultvalue(fpcKB)] FpcSizeUnits Units);
        
    
	[propget, id(10), helpstring("Gets or sets whether responses are cached when either the incoming or outgoing request uses SSL")]
    HRESULT CacheSSLResponses([out, retval] VARIANT_BOOL *pVal);
    [propput, id(10), helpstring("Gets or sets whether responses are cached when either the incoming or outgoing request uses SSL")]
    HRESULT CacheSSLResponses([in] VARIANT_BOOL newVal);
	
	[propget, id(11), helpstring("Gets or sets whether a response will be cached")]
    HRESULT NeverCacheResponse([out, retval] VARIANT_BOOL *pVal);
    [propput, id(11), helpstring("Gets or sets whether a response will be cached")]
    HRESULT NeverCacheResponse([in] VARIANT_BOOL newVal);
	
	[propget, id(12), helpstring("Gets or sets whether a dynamic response will be cached")]
    HRESULT CacheDynamicContent([out, retval] VARIANT_BOOL *pVal);
    [propput, id(12), helpstring("Gets or sets whether a dynamic response will be cached")]
    HRESULT CacheDynamicContent([in] VARIANT_BOOL newVal);
	
	[propget, id(13), helpstring("Gets or sets whether a response will be cached for offline browsing")]
    HRESULT CacheContentForOfflineBrowsing([out, retval] VARIANT_BOOL *pVal);
    [propput, id(13), helpstring("Gets or sets whether a response will be cached for offline browsing")]
    HRESULT CacheContentForOfflineBrowsing([in] VARIANT_BOOL newVal);
	
	[propget, id(14), helpstring("Gets or sets whether a response that was authenticated through the proxy will be cached")]
    HRESULT CacheAuthenticatedContent([out, retval] VARIANT_BOOL *pVal);
    [propput, id(14), helpstring("Gets or sets whether a response that was authenticated through the proxy will be cached")]
    HRESULT CacheAuthenticatedContent([in] VARIANT_BOOL newVal);
	
	[propget, id(15), helpstring("Gets or sets the condition in which an object should be retrieved from the cache")]
    HRESULT UseCacheCondition([out, retval] FpcCacheAction *pVal);
    [propput, id(15), helpstring("Gets or sets the condition in which an object should be retrieved from the cache")]
    HRESULT UseCacheCondition([in] FpcCacheAction newVal);
	
	[propget, id(16), helpstring("Gets the HTTP cache configuration")]
    HRESULT HTTPConfiguration([out, retval] IFPCHTTPCacheConfiguration **pVal);
	
	[propget, id(17), helpstring("Gets the FTP cache configuration")]
    HRESULT FTPConfiguration([out, retval] IFPCFTPCacheConfiguration **pVal);
	
	[propget, id(18), helpstring("Gets whether the rule is a preinstalled rule that cannot be deleted")]
    HRESULT IsDefault([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(19), helpstring("Gets the rule's position in the rule order")]
    HRESULT Order([out, retval] long *pVal);
	
};
	
[
object,
uuid(0A642175-2262-46AC-AF4D-2AC60E85B9AE),
dual,
nonextensible,
helpstring("A cache rule"),
pointer_default(unique)
]
interface IFPCCacheRule2 : IFPCCacheRule
{
	[propget, id(40), helpstring("Gets or sets whether to cache content received through the Background Intelligent Transfer Service (BITS)")]
    HRESULT CacheBITSContent([out, retval] VARIANT_BOOL *pVal);
    [propput, id(40), helpstring("Gets or sets whether to cache content received through the Background Intelligent Transfer Service (BITS)")]
    HRESULT CacheBITSContent([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(D5D9F8EA-BD36-46A2-AA6D-4F09B2DD68F2),
dual,
nonextensible,
helpstring("HTTP cache configuration"),
pointer_default(unique)
]
interface IFPCHTTPCacheConfiguration : IDispatch
{
	[propget, id(1), helpstring("Gets or sets whether caching of HTTP replies is enabled or disabled")]
    HRESULT HTTPEnable([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets whether caching of HTTP replies is enabled or disabled")]
    HRESULT HTTPEnable([in] VARIANT_BOOL newVal);
	
	[propget, id(3), helpstring("Gets or sets the age factor for determining the TTL of cached HTTP requests")]
    HRESULT AgeFactor([out, retval] long *pVal);
    [propput, id(3), helpstring("Gets or sets the age factor for determining the TTL of cached HTTP requests")]
    HRESULT AgeFactor([in] long newVal);
	
	[propget, id(4), helpstring("Gets or sets the time units in which the MinInterval property is expressed")]
    HRESULT MinIntervalUnits([out, retval] FpcTimeScale *pVal);
    [propput, id(4), helpstring("Gets or sets the time units in which the MinInterval property is expressed")]
    HRESULT MinIntervalUnits([in] FpcTimeScale newVal);
	
	[propget, id(5), helpstring("Gets or sets the minimum TTL interval of cached objects originating from HTTP requests, when the ExpirationPolicy property is fpcCachePolicyCustom")]
    HRESULT MinInterval([out, retval] long *pVal);
    [propput, id(5), helpstring("Gets or sets the minimum TTL interval of cached objects originating from HTTP requests, when the ExpirationPolicy property is fpcCachePolicyCustom")]
    HRESULT MinInterval([in] long newVal);
	
	[propget, id(6), helpstring("Gets or sets the time units in which the MaxIntervalValue property is expressed")]
    HRESULT MaxIntervalUnits([out, retval] FpcTimeScale *pVal);
    [propput, id(6), helpstring("Gets or sets the time units in which the MaxIntervalValue property is expressed")]
    HRESULT MaxIntervalUnits([in] FpcTimeScale newVal);
	
	[propget, id(7), helpstring("Gets or sets the maximum TTL interval of cached objects originating from HTTP requests, when the ExpirationPolicy property is fpcCachePolicyCustom")]
    HRESULT MaxIntervalValue([out, retval] long *pVal);
    [propput, id(7), helpstring("Gets or sets the maximum TTL interval of cached objects originating from HTTP requests, when the ExpirationPolicy property is fpcCachePolicyCustom")]
    HRESULT MaxIntervalValue([in] long newVal);
	
	[propget, id(8), helpstring("Gets or sets whether bounds are applied to objects that have an expiration time")]
    HRESULT ApplyBoundsToObjectsWithExpiration([out, retval] VARIANT_BOOL *pVal);
    [propput, id(8), helpstring("Gets or sets whether bounds are applied to objects that have an expiration time")]
    HRESULT ApplyBoundsToObjectsWithExpiration([in] VARIANT_BOOL newVal);
	
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
};
	
[
object,
uuid(1C78923A-7B8A-45AA-B6D0-7D29ADDA8D7F),
dual,
nonextensible,
helpstring("FTP cache configuration"),
pointer_default(unique)
]
interface IFPCFTPCacheConfiguration : IDispatch
{
	[propget, id(1), helpstring("Gets or sets whether caching of FTP replies is enabled or disabled")]
    HRESULT FTPEnable([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets whether caching of FTP replies is enabled or disabled")]
    HRESULT FTPEnable([in] VARIANT_BOOL newVal);
	
	[propget, id(2), helpstring("Gets or sets the fixed Time to Live (TTL) for FTP cached files")]
    HRESULT FTPTTLValue([out, retval] long *pVal);
    [propput, id(2), helpstring("Gets or sets the fixed Time to Live (TTL) for FTP cached files")]
    HRESULT FTPTTLValue([in] long newVal);
	
	[propget, id(3), helpstring("Gets or sets the time units in which the Time to Live (TTL) is measured")]
    HRESULT FTPTTLUnits([out, retval] FpcTimeScale *pVal);
    [propput, id(3), helpstring("Gets or sets the time units in which the Time to Live (TTL) is measured")]
    HRESULT FTPTTLUnits([in] FpcTimeScale newVal);
	
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
};
	
[
object,
uuid(F8CC2145-D3E6-4D41-9B7D-CBA1708C0EA5),
dual,
nonextensible,
helpstring("Active cache configuration"),
pointer_default(unique)
]
interface IFPCActiveCacheConfiguration : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets whether active caching is enabled")]
    HRESULT ActiveCachingEnable([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets whether active caching is enabled")]
    HRESULT ActiveCachingEnable([in] VARIANT_BOOL newVal);
	
	[propget, id(2), helpstring("Gets or sets how actively popular objects are prefetched into the cache")]
    HRESULT ActiveCachingPolicy([out, retval] FpcActiveCachingPolicy *pVal);
    [propput, id(2), helpstring("Gets or sets how actively popular objects are prefetched into the cache")]
    HRESULT ActiveCachingPolicy([in] FpcActiveCachingPolicy newVal);
	
};
	
[
object,
uuid(0BDD6B34-C0C8-4D8E-BB6E-5953368127CF),
dual,
helpstring("A firewall service protocol"),
pointer_default(unique)
]
interface IFPCProtocolDefinition : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the protocol")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the protocol")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets the description of the protocol")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(2), helpstring("Gets or sets the description of the protocol")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(3), helpstring("Gets the related application filters")]
    HRESULT ApplicationFilters([out, retval] IFPCRefs **pVal);
	
	[propget, id(4), helpstring("Gets a collection of all of this protocol's primary connections")]
    HRESULT PrimaryConnections([out, retval] IFPCProtocolConnections **pVal);
	
	[propget, id(6), helpstring("Gets a collection of all of this protocol's secondary connections")]
    HRESULT SecondaryConnections([out, retval] IFPCProtocolConnections **pVal);
	
	[propget, id(7), helpstring("Gets whether the protocol is a predefined Forefront TMG protocol")]
    HRESULT Predefined([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(8), helpstring("Gets the GUID that identifies the protocol")]
    HRESULT Guid([out, retval] BSTR *pVal);
	
	[propget, id(9), helpstring("Gets the category of the protocol (bitmask)")]
    HRESULT ProtocolCategory([out, retval] long *pVal);
	
	[propget, id(10), helpstring("Gets or sets whether this protocol was defined by an application filter")]
    HRESULT ApplicationFilterDefined([out, retval] VARIANT_BOOL *pVal);
    [propput, id(10), helpstring("Gets or sets whether this protocol was defined by an application filter")]
    HRESULT ApplicationFilterDefined([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(644A7F16-00A7-4969-AC1F-83ACC56F5B4B),
dual,
nonextensible,
helpstring("A firewall service protocol"),
pointer_default(unique)
]
interface IFPCProtocolDefinition2 : IFPCProtocolDefinition
{
	[propget, id(11), helpstring("Gets or sets whether this protocol definition is associated with a standard protocol")]
    HRESULT AssociatedWithStandard([out, retval] VARIANT_BOOL *pVal);
	
	[id(12), helpstring("Sets the protocol definition to represent a non-standard protocol that is not associated with any standard protocol")]
          HRESULT DisAssociateFromStandard();
        
    
	[id(13), helpstring("Indicates that the protocol definition represents a non-standard protocol and associates it with a standard protocol")]
          HRESULT AssociateWithStandard([in] FpcItemScope Scope,
              [in] BSTR StandardProtocol);
        
    
	[propget, id(14), helpstring("Gets a reference to the standard protocol associated with this non-standard protocol")]
    HRESULT AssociatedStandardProtocol([out, retval] IFPCRef **pVal);
	
};
	
[
object,
uuid(4005EE21-0F51-45BE-8E20-C4E5590955C9),
dual,
helpstring("A single connection in a firewall service protocol"),
pointer_default(unique)
]
interface IFPCProtocolConnection : IDispatch
{
	[propget, id(1), helpstring("Gets a port number designating the low end of the range")]
    HRESULT PortLow([out, retval] long *pVal);
	
	[propget, id(2), helpstring("Gets a port number designating the high end of the range")]
    HRESULT PortHigh([out, retval] long *pVal);
	
	[propget, id(3), helpstring("Gets the communication protocol of the connection")]
    HRESULT Protocol([out, retval] FpcConnectionProtocolType *pVal);
	
	[propget, id(4), helpstring("Gets the direction of a TCP connection")]
    HRESULT TCPDirection([out, retval] FpcConnectionDirectionType *pVal);
	
	[propget, id(5), helpstring("Gets the direction of the UDP connection")]
    HRESULT UDPDirection([out, retval] FpcUDPConnectionDirectionType *pVal);
	
	[id(6), helpstring("Sets all of the parameters of a TCP connection")]
          HRESULT SetTCP( long PortLo,
               long PortHi,
               FpcConnectionDirectionType Direction);
        
    
	[id(7), helpstring("Sets all of the parameters of a UDP connection")]
          HRESULT SetUDP( long PortLo,
               long PortHi,
               FpcUDPConnectionDirectionType Direction);
        
    
	[id(8), helpstring("Sets all of the parameters of a ICMP connection")]
          HRESULT SetICMP( long Code,
               long Type,
               FpcUDPConnectionDirectionType Direction);
        
    
	[propget, id(9), helpstring("Gets the direction of the raw connection")]
    HRESULT RawDirection([out, retval] FpcUDPConnectionDirectionType *pVal);
	
	[propget, id(10), helpstring("Gets the ICMP code for the connection")]
    HRESULT ICMPCode([out, retval] long *pVal);
	
	[propget, id(11), helpstring("Gets the ICMP type for the connection")]
    HRESULT ICMPType([out, retval] long *pVal);
	
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
};
	
[
object,
uuid(ec6dfa9c-cc15-401d-8a4c-c680a9faff0a),
dual,
nonextensible,
helpstring("A single connection in a firewall service protocol"),
pointer_default(unique)
]
interface IFPCProtocolConnection2 : IFPCProtocolConnection
{
	[id(12), helpstring("Sets all of the parameters of a ICMP connection"), hidden]
          HRESULT SetICMPv6( long Code,
               long Type,
               FpcUDPConnectionDirectionType Direction);
        
    
};
	
[
object,
uuid(74D5F8D1-EA65-4BBC-A563-C801AED45419),
dual,
nonextensible,
helpstring("Configuration of the IP options checking mechanism"),
pointer_default(unique)
]
interface IFPCIpOptions : IFPCPersist
{
	[id(1), helpstring("Selects a specified IP option")]
          HRESULT Select([in] long IpOption);
        
    
	[id(2), helpstring("Clears a specified IP option")]
          HRESULT Clear([in] long IpOption);
        
    
	[id(3), helpstring("Queries whether a specified IP option is selected")]
          HRESULT IsSelected([in] long IpOption,
              [out,retval] VARIANT_BOOL* pVal);
        
    
	[id(4), helpstring("Selects all of the IP options")]
          HRESULT SelectAll();
        
    
	[id(5), helpstring("Clears all of the IP options")]
          HRESULT ClearAll();
        
    
	[propget, id(6), helpstring("Gets or sets under what conditions a packet will be accepted or denied, based on the IP options")]
    HRESULT IPOptionsAction([out, retval] FpcIpOptionsAction *pVal);
    [propput, id(6), helpstring("Gets or sets under what conditions a packet will be accepted or denied, based on the IP options")]
    HRESULT IPOptionsAction([in] FpcIpOptionsAction newVal);
	
};
	
[
object,
uuid(29CBD83C-E012-4025-8161-67D47A2C2F07),
dual,
helpstring("Collection of connections in a firewall service protocol"),
pointer_default(unique)
]
interface IFPCProtocolConnections : IDispatch
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( long Index,
              [out,retval] IFPCProtocolConnection** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(1), helpstring("Creates a new TCP connection object and returns a reference to it")]
          HRESULT AddTCP( FpcConnectionDirectionType Direction,
               long PortLo,
               long PortHi,
              [out,retval] IFPCProtocolConnection** pNew);
        
    
	[id(2), helpstring("Creates a new UDP connection object and returns a reference to it")]
          HRESULT AddUDP( FpcUDPConnectionDirectionType Direction,
               long PortLo,
               long PortHi,
              [out,retval] IFPCProtocolConnection** pNew);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a protocol connection from the collection")]
          HRESULT Remove( VARIANT Index);
        
    
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(3), helpstring("Creates a new ICMP connection object and returns a reference to it")]
          HRESULT AddICMP( FpcUDPConnectionDirectionType Direction,
               long Code,
               long Type,
              [out,retval] IFPCProtocolConnection** pNew);
        
    
	[id(4), helpstring("Creates a new raw protocol connection object and returns a reference to it")]
          HRESULT AddRaw( FpcUDPConnectionDirectionType Direction,
               FpcConnectionProtocolType Protocol,
              [out,retval] IFPCProtocolConnection** pNew);
        
    
};
	
[
object,
uuid(f540289d-bcc1-4851-b8c8-752b51b838b7),
dual,
nonextensible,
helpstring("Collection of connections in a firewall service protocol"),
pointer_default(unique)
]
interface IFPCProtocolConnections2 : IFPCProtocolConnections
{
	[id(5), helpstring("Creates a new ICMPv6 connection object and returns a reference to it"), hidden]
          HRESULT AddICMPv6( FpcUDPConnectionDirectionType Direction,
               long Code,
               long Type,
              [out,retval] IFPCProtocolConnection** pNew);
        
    
};
	
[
object,
uuid(C13F8550-74CF-414C-9CAD-BA5576708B57),
dual,
nonextensible,
helpstring("Collection of firewall service protocols"),
pointer_default(unique)
]
interface IFPCProtocolDefinitions : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCProtocolDefinition** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_REMOVE), helpstring("Removes a protocol definition from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[id(DISPID_ADD), helpstring("Adds a protocol definition to the collection")]
          HRESULT Add( BSTR ProtocolName,
              [in,defaultvalue("")] BSTR ProtocolGuid,
              [in,defaultvalue(fpcProtocolCategoryUserDefined)] long catagory,
              [out,retval] IFPCProtocolDefinition** ppNew);
        
    
};
	
[
object,
uuid(56AD2469-0FB9-4BC9-ABF6-CEA63E6446B9),
dual,
nonextensible,
helpstring("Collection of connected network adapters"),
pointer_default(unique)
]
interface IFPCAdapters : IDispatch
{
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( long Index,
              [out,retval] IFPCAdapter** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

};
	
[
object,
uuid(77471330-3BCD-45AD-B23D-5411BF257A2A),
dual,
helpstring("Collection of all network adapters (connected, disconnected and disabled)"),
pointer_default(unique)
]
interface IFPCAllAdapters : IDispatch
{
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( long Index,
              [out,retval] IFPCAdapter** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

};
	
[
object,
uuid(8280CDEC-779B-4548-94AF-54A26E92DE0D),
dual,
nonextensible,
helpstring("Collection of all network adapters (connected, disconnected and disabled)"),
pointer_default(unique)
]
interface IFPCAllAdapters2 : IFPCAllAdapters
{
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
};
	
[
object,
uuid(899C06B4-81CB-467A-8E29-2304B9B32117),
dual,
helpstring("A network adapter"),
pointer_default(unique)
]
interface IFPCAdapter : IDispatch
{
	[propget, id(1), helpstring("Gets the description of the adapter")]
    HRESULT Description([out, retval] BSTR *pVal);
	
	[propget, id(2), helpstring("Gets a comma-delimited list of all IP addresses bound to the network adapter (replaced in Forefront TMG by FPCAdapter.Addresses)")]
    HRESULT IpAddresses([out, retval] BSTR *pVal);
	
	[propget, id(3), helpstring("Gets the IP range set for the adapter")]
    HRESULT IpRanges([out, retval] IFPCReadOnlyIpRangeSet **pVal);
	
	[propget, id(4), helpstring("The IP address set for the adapter (read-only)")]
    HRESULT IpAddressSet([out, retval] VARIANT *pVal);
	
	[id(5), helpstring("Determines if an IP address is included in the address set of the adapter")]
          HRESULT IsIpInAddressSet([in] BSTR IpStr,
              [out,retval] VARIANT_BOOL* pIsIpInAddressSet);
        
    
	[propget, id(6), helpstring("A Boolean value that indicates whether the network adapter uses DHCP (read-only)")]
    HRESULT DhcpEnabled([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(7), helpstring("The friendly name of the network adapter (read-only)")]
    HRESULT FriendlyName([out, retval] BSTR *pVal);
	
};
	
[
object,
uuid(A5E66D48-28EA-46d4-95E4-7FD9B0087BAD),
dual,
nonextensible,
helpstring("A network adapter"),
pointer_default(unique)
]
interface IFPCAdapter2 : IFPCAdapter
{
	[propget, id(8), helpstring("Gets a comma-delimited list of all IP addresses bound to the network adapter")]
    HRESULT Addresses([out, retval] BSTR *pVal);
    [propput, id(8), helpstring("Gets a comma-delimited list of all IP addresses bound to the network adapter")]
    HRESULT Addresses([in] BSTR newVal);
	
	[propget, id(9), helpstring("Gets a comma-delimited list of all subnet masks configured on the network adapter")]
    HRESULT SubnetMasks([out, retval] BSTR *pVal);
    [propput, id(9), helpstring("Gets a comma-delimited list of all subnet masks configured on the network adapter")]
    HRESULT SubnetMasks([in] BSTR newVal);
	
	[propget, id(10), helpstring("Gets a comma-delimited list of all gateways configured on the network adapter")]
    HRESULT Gateways([out, retval] BSTR *pVal);
    [propput, id(10), helpstring("Gets a comma-delimited list of all gateways configured on the network adapter")]
    HRESULT Gateways([in] BSTR newVal);
	
	[id(11), helpstring("Enable DHCP")]
          HRESULT EnableDhcp();
        
    
	[propget, id(12), helpstring("Gets the IP address of the DHCP server for the network adapter")]
    HRESULT DhcpServer([out, retval] BSTR *pVal);
	
	[propget, id(13), helpstring("Gets a ccomma-delimited list of all DNS servers defined for the network adapter")]
    HRESULT DnsServers([out, retval] BSTR *pVal);
    [propput, id(13), helpstring("Gets a ccomma-delimited list of all DNS servers defined for the network adapter")]
    HRESULT DnsServers([in] BSTR newVal);
	
	[propget, id(14), helpstring("Gets a value that indicates whether DNS servers will be detected automatically")]
    HRESULT AutoDnsServerDetection([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(17), helpstring("Gets a value from the FpcAdapterConnectionType enumerated type that specifies the type of connection to the network adapter")]
    HRESULT ConnectionType([out, retval] FpcAdapterConnectionType *pVal);
    [propput, id(17), helpstring("Gets a value from the FpcAdapterConnectionType enumerated type that specifies the type of connection to the network adapter")]
    HRESULT ConnectionType([in] FpcAdapterConnectionType newVal);
	
	[id(19), helpstring("Gets the primary IP address of the network adapter")]
          HRESULT GetPrimaryIpAddress([out,retval] BSTR* pVal);
        
    
	[id(20), helpstring("Gets the primary subnet mask of the network adapter")]
          HRESULT GetPrimarySubnetMask([out,retval] BSTR* pVal);
        
    
	[id(21), helpstring("Gets the primary gateway of the network adapter")]
          HRESULT GetPrimaryGateway([out,retval] BSTR* pVal);
        
    
	[id(22), helpstring("Gets the IP address of the primary DNS server of the network adapter")]
          HRESULT GetPrimaryDnsServer([out,retval] BSTR* pVal);
        
    
	[id(23), helpstring("Gets the IP address of the secondary DNS server of the network adapter")]
          HRESULT GetSecondaryDnsServer([out,retval] BSTR* pVal);
        
    
	[propget, id(24), helpstring("Gets a a value from the FpcAdapterState enumerated type that specifies the state of the network adapter")]
    HRESULT State([out, retval] FpcAdapterState *pVal);
	
	[id(25), helpstring("Sets the primary IP address of the network adapter")]
          HRESULT SetPrimaryIpAddress([in] BSTR newVal);
        
    
	[id(26), helpstring("Sets the primary subnet mask of the network adapter")]
          HRESULT SetPrimarySubnetMask([in] BSTR newVal);
        
    
	[id(27), helpstring("Sets the primary gateway of the network adapter")]
          HRESULT SetPrimaryGateway([in] BSTR newVal);
        
    
	[id(28), helpstring("Sets the IP address of the primary DNS server of the network adapter")]
          HRESULT SetPrimaryDnsServer([in] BSTR newVal);
        
    
	[id(29), helpstring("Sets the IP address of the secondary DNS server of the network adapter")]
          HRESULT SetSecondaryDnsServer([in] BSTR newVal);
        
    
	[id(30), helpstring("Enables the automatic detection of DNS servers")]
          HRESULT EnableAutoDnsDetection();
        
    
	[id(31), helpstring("Gets a mask that contain network connectivity types of the network adapter"), hidden]
          HRESULT GetConnectivityStatus([out,retval] FpcNlmConnectivity* pNlmConnectivity);
        
    
	[propget, id(32), helpstring("Gets a Boolean value that indicates whether the adapter is enabled")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(32), helpstring("Gets a Boolean value that indicates whether the adapter is enabled")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(33), helpstring("Gets the IP address of the primary WINS server of the network adapter")]
    HRESULT PrimaryWinsServer([out, retval] BSTR *pVal);
	
	[propget, id(34), helpstring("Gets the IP address of the secondary WINS server of the network adapter")]
    HRESULT SecondaryWinsServer([out, retval] BSTR *pVal);
	
	[propget, id(35), helpstring("Gets the physical address of the network adapter")]
    HRESULT PhysicalAddress([out, retval] BSTR *pVal);
	
	[propget, id(36), helpstring("Gets the connection-specific DNS suffix of the network adapter")]
    HRESULT ConnectionSpecificDnsSuffix([out, retval] BSTR *pVal);
	
	[id(37), helpstring("Gets the GUID of the network adapter device")]
          HRESULT GetDeviceGuid([out,retval] BSTR* pbstrConnectionSpecificDnsSuffix);
        
    
};
	
[
object,
uuid(54426ED3-443F-42AD-B7DB-3AD7D2A04538),
dual,
helpstring("Collection of objects used by a rule, as a reference"),
pointer_default(unique)
]
interface IFPCRefs : IDispatch
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( long Index,
              [out,retval] IFPCRef** pVal);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_ADD), helpstring("Adds an FPCRef object to the collection")]
          HRESULT Add( BSTR Name,
               FpcIncludeStatus IncludeStatus,
              [out,retval] IFPCRef** ppNewRef);
        
    
	[id(DISPID_REMOVE), helpstring("Removes an FPCRef object from the collection")]
          HRESULT Remove( long Index);
        
    
	[id(6), helpstring("Removes all of the FPCRef objects from the collection")]
          HRESULT RemoveAll();
        
    
	[id(8), helpstring("Returns True if an object that has the specified properties exists in the collection")]
          HRESULT Exists([in] BSTR Name,
              [out,retval] VARIANT_BOOL* fExists);
        
    
	[id(9), helpstring("Removes an object identified by its properties")]
          HRESULT RemoveSpecified([in] BSTR Name);
        
    
};
	
[
object,
uuid(2746bb73-fbc1-4e3d-8135-7ba8dfc67eb9),
dual,
nonextensible,
helpstring("Collection of objects used by a rule, as a reference"),
pointer_default(unique)
]
interface IFPCEERefs : IFPCRefs
{
	[id(10), helpstring("Adds an FPCRef object from specific scope to the collection")]
          HRESULT AddScopedItem([in] FpcItemScope Scope,
              [in] BSTR Name,
              [in] FpcIncludeStatus IncludeStatus,
              [out,retval] IFPCRef** ppNewRef);
        
    
	[id(11), helpstring("Returns True if an object that has the specified properties from specific scope exists in the collection")]
          HRESULT ExistsScopedItem([in] FpcItemScope Scope,
              [in] BSTR Name,
              [out,retval] VARIANT_BOOL* fExists);
        
    
	[id(12), helpstring("Removes an object from specific scope identified by its properties")]
          HRESULT RemoveSpecifiedScopedItem([in] FpcItemScope Scope,
              [in] BSTR Name);
        
    
};
	
[
object,
uuid(9F11296C-FC14-4014-B354-DD585B08D5F4),
dual,
helpstring("Object for referencing another object"),
pointer_default(unique)
]
interface IFPCRef : IDispatch
{
	[propget, id(DISPID_VALUE), helpstring("Gets the name of the object referenced by the FPCRef object")]
    HRESULT Name([out, retval] BSTR *pVal);
	
	[propget, id(1), helpstring("Specifies the include status of this object")]
    HRESULT IncludeStatus([out, retval] FpcIncludeStatus *pVal);
	
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
};
	
[
object,
uuid(35af4cad-2f0d-4c6c-9948-357555863662),
dual,
nonextensible,
helpstring("Object for referencing another object"),
pointer_default(unique)
]
interface IFPCEERef : IFPCRef
{
	[propget, id(2), helpstring("Specifies the scope of this reference object")]
    HRESULT Scope([out, retval] FpcItemScope *pVal);
	
};
	
[
object,
uuid(88AEE899-2841-4B0E-A616-A3D3E3712B13),
dual,
helpstring("An application filter"),
pointer_default(unique)
]
interface IFPCApplicationFilter : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the vendor-supplied name of the application filter")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the vendor-supplied name of the application filter")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets the vendor-supplied version of the application filter")]
    HRESULT Version([out, retval] BSTR *pVal);
    [propput, id(2), helpstring("Gets or sets the vendor-supplied version of the application filter")]
    HRESULT Version([in] BSTR newVal);
	
	[propget, id(3), helpstring("Gets or sets the name of the vendor of the application filter")]
    HRESULT Vendor([out, retval] BSTR *pVal);
    [propput, id(3), helpstring("Gets or sets the name of the vendor of the application filter")]
    HRESULT Vendor([in] BSTR newVal);
	
	[propget, id(4), helpstring("Gets or sets the vendor-supplied description of the application filter")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(4), helpstring("Gets or sets the vendor-supplied description of the application filter")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(6), helpstring("Gets the globally unique identifier (GUID) that identifies the application filter")]
    HRESULT Guid([out, retval] BSTR *pVal);
	
	[propget, id(7), helpstring("Gets whether the filter is a preinstalled element that cannot be deleted")]
    HRESULT Predefined([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(10), helpstring("Gets or sets whether the application filter is enabled")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(10), helpstring("Gets or sets whether the application filter is enabled")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(E97D34BC-B216-407c-B7F0-FAA7493F875D),
dual,
nonextensible,
helpstring("An application filter"),
pointer_default(unique)
]
interface IFPCApplicationFilter2 : IFPCApplicationFilter
{
	[propget, id(11), helpstring("Gets or sets filter flags bits, some bits are reserved and some are available for private use by filters")]
    HRESULT FilterSpecificFlags([out, retval] LONG *pVal);
    [propput, id(11), helpstring("Gets or sets filter flags bits, some bits are reserved and some are available for private use by filters")]
    HRESULT FilterSpecificFlags([in] LONG newVal);
	
};
	
[
object,
uuid(DB3AD95A-676C-4593-83C3-2C65687C0B11),
dual,
nonextensible,
helpstring("Collection of application filters"),
pointer_default(unique)
]
interface IFPCApplicationFilters : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCApplicationFilter** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_ADD), helpstring("")]
          HRESULT Add( BSTR Guid,
               BSTR Name,
              [out,retval] IFPCApplicationFilter** ppNewAppFilter);
        
    
	[id(DISPID_REMOVE), helpstring("")]
          HRESULT Remove( VARIANT v);
        
    
};
	
[
object,
uuid(11BE43E3-C450-4552-9DB5-83C0C22BF959),
dual,
nonextensible,
helpstring("Collection of routing rules"),
pointer_default(unique)
]
interface IFPCRoutingRules : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCRoutingRule** pItem);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Adds a routing rule to the collection")]
          HRESULT Add( BSTR Name,
              [out,retval] IFPCRoutingRule** ppNewRule);
        
    
	[id(5), helpstring("Moves the specified rule up the ladder of execution")]
          HRESULT MoveUp( long index);
        
    
	[id(6), helpstring("Moves the specified rule down the ladder of execution")]
          HRESULT MoveDown( long index);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a routing rule from the collection")]
          HRESULT Remove( VARIANT v);
        
    
};
	
[
object,
uuid(B0CC3D87-1ABE-40E3-9605-7F3953CBD592),
dual,
nonextensible,
helpstring("A routing rule"),
pointer_default(unique)
]
interface IFPCRoutingRule : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the rule")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the rule")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the description of the rule")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the description of the rule")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets whether this rule is enabled")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(2), helpstring("Gets or sets whether this rule is enabled")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(3), helpstring("Gets whether the rule is a preinstalled rule that cannot be deleted")]
    HRESULT IsDefault([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(4), helpstring("Gets the rule's place in the order of execution ")]
    HRESULT Order([out, retval] long *pVal);
	
	[propget, id(5), helpstring("Gets a reference to the collection of URL sets to which the rule applies")]
    HRESULT URLSets([out, retval] IFPCRefs **pVal);
	
	[propget, id(6), helpstring("Gets a reference to the selection destination IPs to which the rule applies")]
    HRESULT DestinationSelectionIPs([out, retval] IFPCSelectionIPs **pVal);
	
	[propget, id(7), helpstring("Gets a reference to the collection of destination domain name sets to which the rule applies")]
    HRESULT DestinationDomainNameSets([out, retval] IFPCRefs **pVal);
	
	[propget, id(8), helpstring("Gets the specific server or array of the main (primary) route")]
    HRESULT PrimaryRoute([out, retval] IFPCPrimaryRoute **pVal);
	
	[propget, id(9), helpstring("Gets or sets the protocol to use when redirecting (bridging) HTTP requests that came on a non-secure channel")]
    HRESULT NonSecureProtocolRedirection([out, retval] FpcPublishProtocolRedirectionType *pVal);
    [propput, id(9), helpstring("Gets or sets the protocol to use when redirecting (bridging) HTTP requests that came on a non-secure channel")]
    HRESULT NonSecureProtocolRedirection([in] FpcPublishProtocolRedirectionType newVal);
	
	[propget, id(10), helpstring("Gets or sets the protocol to use when redirecting (bridging) SSL requests that came on a secure channel")]
    HRESULT SecureProtocolRedirection([out, retval] FpcPublishProtocolRedirectionType *pVal);
    [propput, id(10), helpstring("Gets or sets the protocol to use when redirecting (bridging) SSL requests that came on a secure channel")]
    HRESULT SecureProtocolRedirection([in] FpcPublishProtocolRedirectionType newVal);
	
	[propget, id(11), helpstring("Gets or sets whether or not a secure channel is required")]
    HRESULT SSLRequireSecureChannel([out, retval] FpcSSLRequireSecureChannelMode *pVal);
    [propput, id(11), helpstring("Gets or sets whether or not a secure channel is required")]
    HRESULT SSLRequireSecureChannel([in] FpcSSLRequireSecureChannelMode newVal);
	
	[propget, id(12), helpstring("Gets or sets the client certificate to use when the Web proxy authenticates with the publishing server")]
    HRESULT SSLClientCertificate([out, retval] IFPCCertificate **pVal);
    [propput, id(12), helpstring("Gets or sets the client certificate to use when the Web proxy authenticates with the publishing server")]
    HRESULT SSLClientCertificate([in] IFPCCertificate *newVal);
	
	[propget, id(13), helpstring("Gets or sets whether basic credentials are delegated")]
    HRESULT DelegateBasicCredentials([out, retval] VARIANT_BOOL *pVal);
    [propput, id(13), helpstring("Gets or sets whether basic credentials are delegated")]
    HRESULT DelegateBasicCredentials([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(4932960C-A356-4491-ABDC-8D78BEF36427),
dual,
helpstring("Primary route"),
pointer_default(unique)
]
interface IFPCPrimaryRoute : IDispatch
{
	[propget, id(DISPID_VALUE), helpstring("Gets the name of the server or array to which the request should be redirected")]
    HRESULT RouteServerName([out, retval] BSTR *pVal);
	
	[propget, id(2), helpstring("Gets the port to use for routing requests from Web proxy clients to an upstream proxy server on the primary route")]
    HRESULT RouteServerPort([out, retval] long *pVal);
	
	[propget, id(3), helpstring("Gets whether polling of the upstream proxy or array for membership information is enabled")]
    HRESULT AutomaticPollConfig([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(5), helpstring("Gets the URL that points to an upstream server, to poll for the upstream server's array configuration information")]
    HRESULT PollAtURL([out, retval] BSTR *pVal);
	
	[id(6), helpstring("Sets whether the upstream server or array should be polled for array membership")]
          HRESULT SetAutoPollConfig([in] VARIANT_BOOL fSetAuto,
              [in,defaultvalue("")] BSTR AutoPollUrl);
        
    
	[propget, id(7), helpstring("Gets an FPCCredentials object used by the Forefront TMG computer to authenticate a connection to an upstream proxy server")]
    HRESULT Credentials([out, retval] IFPCCredentials **pVal);
	
	[id(8), helpstring("Sets the server and port for the primary route server or array")]
          HRESULT SetServerAndPort( BSTR ServerName,
               long Port,
               long SSLPort);
        
    
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[propget, id(11), helpstring("Gets or sets the primary route type")]
    HRESULT RouteType([out, retval] FpcPrimaryRouteType *pVal);
    [propput, id(11), helpstring("Gets or sets the primary route type")]
    HRESULT RouteType([in] FpcPrimaryRouteType newVal);
	
	[propget, id(12), helpstring("Gets or sets whether use of authentication in upstream routing is enabled")]
    HRESULT AuthenticationEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(12), helpstring("Gets or sets whether use of authentication in upstream routing is enabled")]
    HRESULT AuthenticationEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(411), helpstring("Gets or sets the type of authentication that the primary route server or array uses if authentication is enabled")]
    HRESULT AuthenticationType([out, retval] FpcAuthType *pVal);
    [propput, id(411), helpstring("Gets or sets the type of authentication that the primary route server or array uses if authentication is enabled")]
    HRESULT AuthenticationType([in] FpcAuthType newVal);
	
	[propget, id(13), helpstring("Gets the port number for the redirection")]
    HRESULT RedirectHostPort([out, retval] long *pVal);
	
	[propget, id(14), helpstring("Gets the port number for a redirection using SSL")]
    HRESULT RedirectHostSSLPort([out, retval] long *pVal);
	
	[propget, id(15), helpstring("Gets the name for the redirect site")]
    HRESULT RedirectHost([out, retval] BSTR *pVal);
	
	[id(16), helpstring("Sets whether requests are redirected to a hosted site, specified by a host site name and port number")]
          HRESULT SetRedirectHostAndPorts([in] BSTR Host,
              [in] long RedirectHostPort,
              [in] long RedirectHostSSLPort);
        
    
	[propget, id(17), helpstring("Gets or sets if auto dial is enabled")]
    HRESULT EnableAutoDial([out, retval] VARIANT_BOOL *pVal);
    [propput, id(17), helpstring("Gets or sets if auto dial is enabled")]
    HRESULT EnableAutoDial([in] VARIANT_BOOL newVal);
	
	[propget, id(18), helpstring("Gets the specific server or array of the backup route")]
    HRESULT BackupRoute([out, retval] IFPCBackupRoute **pVal);
	
	[propget, id(19), helpstring("Gets the port for listening on a secure channel")]
    HRESULT RouteServerSSLPort([out, retval] long *pVal);
	
};
	
[
object,
uuid(A071421E-F1BF-486F-9D83-183043D5171A),
dual,
nonextensible,
helpstring("Primary route"),
pointer_default(unique)
]
interface IFPCPrimaryRoute2 : IFPCPrimaryRoute
{
	[propget, id(20), helpstring("Gets or sets a Boolean value that indicates whether content returned in response to requests sent on this route will be inspected for malware if malware inspection is enabled")]
    HRESULT InspectForMalware([out, retval] VARIANT_BOOL *pVal);
    [propput, id(20), helpstring("Gets or sets a Boolean value that indicates whether content returned in response to requests sent on this route will be inspected for malware if malware inspection is enabled")]
    HRESULT InspectForMalware([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(F46E6D90-72A2-4290-BCBE-86A3F7EDD5AE),
dual,
helpstring("Backup route"),
pointer_default(unique)
]
interface IFPCBackupRoute : IDispatch
{
	[propget, id(DISPID_VALUE), helpstring("Gets the name of the Forefront TMG or array")]
    HRESULT RouteServerName([out, retval] BSTR *pVal);
	
	[propget, id(2), helpstring("Gets the port to use for routing requests from Web proxy clients to an upstream proxy server on the backup route")]
    HRESULT RouteServerPort([out, retval] long *pVal);
	
	[propget, id(3), helpstring("Gets whether polling of the upstream proxy or array is enabled for membership information")]
    HRESULT AutomaticPollConfig([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(5), helpstring("Gets the URL to poll for the array configuration information")]
    HRESULT PollAtURL([out, retval] BSTR *pVal);
	
	[propget, id(6), helpstring("Gets credential information used by the Forefront TMG to authenticate a connection to an upstream server")]
    HRESULT Credentials([out, retval] IFPCCredentials **pVal);
	
	[id(7), helpstring("Sets the server and port for the backup route")]
          HRESULT SetServerAndPort( BSTR ServerName,
               long Port,
               long SSLPort);
        
    
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[propget, id(10), helpstring("Gets or sets whether there is a backup route, and whether it is direct to the Internet or through an upstream proxy server")]
    HRESULT BackupRouteType([out, retval] FpcBackupRouteType *pVal);
    [propput, id(10), helpstring("Gets or sets whether there is a backup route, and whether it is direct to the Internet or through an upstream proxy server")]
    HRESULT BackupRouteType([in] FpcBackupRouteType newVal);
	
	[propget, id(11), helpstring("Gets or sets whether the use of downstream client authentication in upstream routing is enabled")]
    HRESULT AuthenticationEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(11), helpstring("Gets or sets whether the use of downstream client authentication in upstream routing is enabled")]
    HRESULT AuthenticationEnabled([in] VARIANT_BOOL newVal);
	
	[id(12), helpstring("Sets whether polling of the upstream Forefront TMG or array is enabled for membership information")]
          HRESULT SetAutoPollConfig([in] VARIANT_BOOL fSetAuto,
              [in,defaultvalue("")] BSTR AutoPollUrl);
        
    
	[propget, id(411), helpstring("Gets or sets the type of authentication that the entity uses")]
    HRESULT AuthenticationType([out, retval] FpcAuthType *pVal);
    [propput, id(411), helpstring("Gets or sets the type of authentication that the entity uses")]
    HRESULT AuthenticationType([in] FpcAuthType newVal);
	
	[propget, id(13), helpstring("Gets or sets if auto dial is enabled")]
    HRESULT EnableAutoDial([out, retval] VARIANT_BOOL *pVal);
    [propput, id(13), helpstring("Gets or sets if auto dial is enabled")]
    HRESULT EnableAutoDial([in] VARIANT_BOOL newVal);
	
	[propget, id(14), helpstring("Gets the port for listening on a secure channel")]
    HRESULT RouteServerSSLPort([out, retval] long *pVal);
	
};
	
[
object,
uuid(39B5BF73-9C6F-4446-A028-A258CAE5347B),
dual,
nonextensible,
helpstring("Backup route"),
pointer_default(unique)
]
interface IFPCBackupRoute2 : IFPCBackupRoute
{
	[propget, id(15), helpstring("Gets or sets a Boolean value that indicates whether content returned in response to requests sent on this route will be inspected for malware if malware inspection is enabled")]
    HRESULT InspectForMalware([out, retval] VARIANT_BOOL *pVal);
    [propput, id(15), helpstring("Gets or sets a Boolean value that indicates whether content returned in response to requests sent on this route will be inspected for malware if malware inspection is enabled")]
    HRESULT InspectForMalware([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(7D9F3059-D1A3-4C9C-9EE6-BE4F886F4030),
dual,
nonextensible,
helpstring("Collection of dial-up network connections"),
pointer_default(unique)
]
interface IFPCDialupNetworkConnections : IDispatch
{
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( long Index,
              [out,retval] VARIANT* pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);
	
};
	
[
object,
uuid(97A70720-39E0-4AFE-831C-1D708440E9A4),
dual,
nonextensible,
helpstring("Cache prefetching object"),
pointer_default(unique)
]
interface IFPCCacheContents : IDispatch
{
	[id(1), helpstring("Causes the Web proxy to retrieve an object and store it in the cache")]
          HRESULT FetchUrl( BSTR FetchUrl,
               BSTR CacheUrl,
               long TtlInMinutes,
               FpcFetchURLFlags Flags);
        
    
};
	
[
object,
uuid(95755301-0828-4AE1-A4AA-19957F0AF2B5),
dual,
nonextensible,
helpstring("Attack Detection Configuration"),
pointer_default(unique)
]
interface IFPCAttackDetection : IFPCPersist
{
	[propget, id(2), helpstring("Gets or sets whether IP fragment filtering is enabled")]
    HRESULT IPFragmentsFilteringEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(2), helpstring("Gets or sets whether IP fragment filtering is enabled")]
    HRESULT IPFragmentsFilteringEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(4), helpstring("Gets or sets whether intrusion detection is enabled")]
    HRESULT IntrusionDetectionEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(4), helpstring("Gets or sets whether intrusion detection is enabled")]
    HRESULT IntrusionDetectionEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(5), helpstring("Gets or sets whether intrusion detection logging is enabled")]
    HRESULT IntrusionDetectionLoggingEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(5), helpstring("Gets or sets whether intrusion detection logging is enabled")]
    HRESULT IntrusionDetectionLoggingEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(11), helpstring("Gets or sets whether Firwall Server will detect Windows out-of-band attacks and generate an event")]
    HRESULT WinOutOfBandDetectionEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(11), helpstring("Gets or sets whether Firwall Server will detect Windows out-of-band attacks and generate an event")]
    HRESULT WinOutOfBandDetectionEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(12), helpstring("Gets or sets whether land attacks are detected and generate an event")]
    HRESULT LandAttackDetectionEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(12), helpstring("Gets or sets whether land attacks are detected and generate an event")]
    HRESULT LandAttackDetectionEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(13), helpstring("Gets or sets whether Firwall Server will detect ping-of-death attacks and generate an event")]
    HRESULT PingOfDeathDetectionEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(13), helpstring("Gets or sets whether Firwall Server will detect ping-of-death attacks and generate an event")]
    HRESULT PingOfDeathDetectionEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(14), helpstring("Gets or sets whether IP half-scan attacks are detected and generate an event")]
    HRESULT IPHalfScanDetectionEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(14), helpstring("Gets or sets whether IP half-scan attacks are detected and generate an event")]
    HRESULT IPHalfScanDetectionEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(15), helpstring("Gets or sets whether port scan attacks are detected and generate an event")]
    HRESULT PortScanDetectionEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(15), helpstring("Gets or sets whether port scan attacks are detected and generate an event")]
    HRESULT PortScanDetectionEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(16), helpstring("Gets or sets whether Firwall Server will detect UDP bomb attacks and generate an event")]
    HRESULT UdpBombDetectionEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(16), helpstring("Gets or sets whether Firwall Server will detect UDP bomb attacks and generate an event")]
    HRESULT UdpBombDetectionEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(17), helpstring("Gets or sets whether IP routing is enabled")]
    HRESULT IPRoutingEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(17), helpstring("Gets or sets whether IP routing is enabled")]
    HRESULT IPRoutingEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(18), helpstring("Gets or sets, if detection of port scan attacks is enabled, the total number of ports that can be scanned before Firwall Server generates an alert")]
    HRESULT PortScanDetectionAllPortsThreshold([out, retval] long *pVal);
    [propput, id(18), helpstring("Gets or sets, if detection of port scan attacks is enabled, the total number of ports that can be scanned before Firwall Server generates an alert")]
    HRESULT PortScanDetectionAllPortsThreshold([in] long newVal);
	
	[propget, id(19), helpstring("Gets or sets, if detection of port scan attacks is enabled, the total number of well-known ports that can be scanned before Firwall Server generates an alert")]
    HRESULT PortScanDetectionWellKnownPortsThreshold([out, retval] long *pVal);
    [propput, id(19), helpstring("Gets or sets, if detection of port scan attacks is enabled, the total number of well-known ports that can be scanned before Firwall Server generates an alert")]
    HRESULT PortScanDetectionWellKnownPortsThreshold([in] long newVal);
	
	[propget, id(22), helpstring("Gets an FPCIpOptions object that enables configuration of the IP options checking mechanism")]
    HRESULT IpOptions([out, retval] IFPCIpOptions **pVal);
	
};
	
[
object,
uuid(075FC499-8140-4E54-B0A8-0EFE23DB29C9),
dual,
nonextensible,
helpstring("A cache drive"),
pointer_default(unique)
]
interface IFPCCacheDrive : IDispatch
{
	[propget, id(1), helpstring("Gets the name of the drive")]
    HRESULT Name([out, retval] BSTR *pVal);
	
	[propget, id(2), helpstring("Gets or sets the disk size allocated to the cache")]
    HRESULT CacheLimitInMegs([out, retval] long *pVal);
    [propput, id(2), helpstring("Gets or sets the disk size allocated to the cache")]
    HRESULT CacheLimitInMegs([in] long newVal);
	
};
	
[
object,
uuid(A24E69BD-4335-4415-853E-2BA1B6E3B78E),
dual,
nonextensible,
helpstring("Collection of cache drives"),
pointer_default(unique)
]
interface IFPCCacheDrives : IFPCPersist
{
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[propget, id(3), helpstring("Gets the total size allocated to the cache in all drives")]
    HRESULT TotalCacheInMegs([out, retval] long *pVal);
	
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCCacheDrive** pItem);
        
    
	[id(DISPID_ADD), helpstring("Adds a drive to the collection")]
          HRESULT Add( BSTR Name,
               long CacheLimitInMegs,
              [out,retval] IFPCCacheDrive** ppNewCacheDrive);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a drive from the collection")]
          HRESULT Remove( VARIANT v);
        
    
};
	
[
object,
uuid(FF3D6396-DA29-411E-80E5-7B34503827F8),
dual,
nonextensible,
helpstring("A disk drive"),
pointer_default(unique)
]
interface IFPCDiskDrive : IDispatch
{
	[propget, id(1), helpstring("Gets the name of the drive")]
    HRESULT Name([out, retval] BSTR *pVal);
	
	[propget, id(2), helpstring("Gets the name of the file system")]
    HRESULT FileSystem([out, retval] BSTR *pVal);
	
	[propget, id(3), helpstring("Gets the size of the disk in Megabytes")]
    HRESULT DiskSizeInMegs([out, retval] long *pVal);
	
	[propget, id(4), helpstring("Gets the size of the free space, in megabytes, on the current disk")]
    HRESULT FreeSpaceInMegs([out, retval] long *pVal);
	
	[propget, id(5), helpstring("Gets the amount of disk space being used by the cache"), hidden]
    HRESULT CurrentCacheInMegs([out, retval] long *pVal);
	
};
	
[
object,
uuid(FB439EFE-7DBB-4CA0-BA33-EA8F7E48DDFA),
dual,
nonextensible,
helpstring("Collection of disk drives"),
pointer_default(unique)
]
interface IFPCDiskDrives : IDispatch
{
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[propget, id(5), helpstring("Gets the total amount of disk space in all NTFS file system drive")]
    HRESULT TotalDiskSizeInMegs([out, retval] long *pVal);
	
	[propget, id(6), helpstring("Gets the total amount of free space in all NTFS file system drives")]
    HRESULT TotalFreeSizeInMegs([out, retval] long *pVal);
	
	[propget, id(7), helpstring("Gets the total amount of disk space currently being used by the cache"), hidden]
    HRESULT TotalCurrentCacheInMegs([out, retval] long *pVal);
	
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCDiskDrive** pItem);
        
    
};
	
[
object,
uuid(7B501D43-7672-4394-8E63-B4A011B6EBBA),
dual,
nonextensible,
helpstring("Client configuration"),
pointer_default(unique)
]
interface IFPCClientConfig : IFPCPersist
{
	[propget, id(1), helpstring("Gets an object that allows access to the configuration of the Forefront TMG Client")]
    HRESULT Firewall([out, retval] IFPCFirewallClientConfig **pVal);
	
	[propget, id(2), helpstring("Gets an object that allows access to the configuration of the Web proxy client browser")]
    HRESULT Browser([out, retval] IFPCWebBrowserClientConfig **pVal);
	
};
	
[
object,
uuid(E80D5D4E-064F-4C12-9FBA-C6CEC717DF4B),
dual,
nonextensible,
helpstring("Forefront TMG Client configuration"),
pointer_default(unique)
]
interface IFPCFirewallClientConfig : IFPCPersist
{
	[propget, id(5), helpstring("Gets or sets the name or IP of the Forefront TMG used by Forefront TMG Clients")]
    HRESULT ServerOrArrayNameOrIP([out, retval] BSTR *pVal);
    [propput, id(5), helpstring("Gets or sets the name or IP of the Forefront TMG used by Forefront TMG Clients")]
    HRESULT ServerOrArrayNameOrIP([in] BSTR newVal);
	
};
	
[
object,
uuid(7083FB25-3304-4FCF-A884-F01A82634D34),
dual,
nonextensible,
helpstring("Browser configuration"),
pointer_default(unique)
]
interface IFPCWebBrowserClientConfig : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets whether the Forefront TMG Forefront TMG Client installation will affect the client's Web browser settings")]
    HRESULT BrowserConfigEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets whether the Forefront TMG Forefront TMG Client installation will affect the client's Web browser settings")]
    HRESULT BrowserConfigEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(2), helpstring("Gets or sets whether automatic configuration settings are automatically detected")]
    HRESULT BrowserConfigAutoDetect([out, retval] VARIANT_BOOL *pVal);
    [propput, id(2), helpstring("Gets or sets whether automatic configuration settings are automatically detected")]
    HRESULT BrowserConfigAutoDetect([in] VARIANT_BOOL newVal);
	
	[propget, id(3), helpstring("Gets or sets whether the browser will use the information in the configuration file")]
    HRESULT BrowserConfigScriptEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(3), helpstring("Gets or sets whether the browser will use the information in the configuration file")]
    HRESULT BrowserConfigScriptEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(4), helpstring("Gets whether the browser configuration uses a default script or a custom script")]
    HRESULT BrowserConfigScriptFlag([out, retval] FpcBrowserConfigScriptFlag *pVal);
	
	[propget, id(5), helpstring("Gets the address (URL) or file name of the file that will be used to configure the browser")]
    HRESULT BrowserConfigScriptAddress([out, retval] BSTR *pVal);
	
	[id(6), helpstring("Sets whether the default or custom script is used")]
          HRESULT SetBrowserConfigScript([in] FpcBrowserConfigScriptFlag Flag,
              [in,defaultvalue("")] BSTR Script);
        
    
	[propget, id(7), helpstring("Gets or sets the name of the Forefront TMG or array")]
    HRESULT ServerOrArrayName([out, retval] BSTR *pVal);
    [propput, id(7), helpstring("Gets or sets the name of the Forefront TMG or array")]
    HRESULT ServerOrArrayName([in] BSTR newVal);
	
	[propget, id(8), helpstring("Gets an FPCAutoScript object")]
    HRESULT AutoScript([out, retval] IFPCClientAutoScript **pVal);
	
};
	
[
object,
uuid(26DB0E07-775F-46A4-AEB7-D020A98A7498),
dual,
helpstring("The browser's automatic script"),
pointer_default(unique)
]
interface IFPCClientAutoScript : IDispatch
{
	[propget, id(1), helpstring("Gets a collection of domain names to be accessed directly by clients")]
    HRESULT DirectAddressDestinations([out, retval] IFPCPublicNames **pVal);
	
	[propget, id(2), helpstring("Gets a collection of IP addresses to be accessed directly by clients")]
    HRESULT DirectIPDestinations([out, retval] IFPCIpRangeSet **pVal);
	
	[propget, id(3), helpstring("Gets the client backup route")]
    HRESULT BackupRoute([out, retval] IFPCClientBackupRoute **pVal);
	
	[propget, id(4), helpstring("Gets or sets whether a client will bypass the Web proxy for requests that do not include a dot")]
    HRESULT BypassLocalServers([out, retval] VARIANT_BOOL *pVal);
    [propput, id(4), helpstring("Gets or sets whether a client will bypass the Web proxy for requests that do not include a dot")]
    HRESULT BypassLocalServers([in] VARIANT_BOOL newVal);
	
	[propget, id(5), helpstring("Gets or sets whether to include the Local Domain Table addresses in the list of direct-access servers")]
    HRESULT IncludeLDT([out, retval] VARIANT_BOOL *pVal);
    [propput, id(5), helpstring("Gets or sets whether to include the Local Domain Table addresses in the list of direct-access servers")]
    HRESULT IncludeLDT([in] VARIANT_BOOL newVal);
	
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
};
	
[
object,
uuid(CA8EE73F-4F45-4B33-A699-81C9C268ACFD),
dual,
helpstring("The browser's automatic script"),
pointer_default(unique)
]
interface IFPCClientAutoScript2 : IFPCClientAutoScript
{
	[propget, id(6), helpstring("Gets or sets whether to include the network's IP address ranges in the list of direct-access servers")]
    HRESULT IncludeNetworkIpRangeSet([out, retval] VARIANT_BOOL *pVal);
    [propput, id(6), helpstring("Gets or sets whether to include the network's IP address ranges in the list of direct-access servers")]
    HRESULT IncludeNetworkIpRangeSet([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(0828FDE4-7BDE-4CC9-8135-B2606E6D1C6E),
dual,
nonextensible,
helpstring("The browser's automatic script"),
pointer_default(unique)
]
interface IFPCClientAutoScript3 : IFPCClientAutoScript2
{
	[propget, id(7), helpstring("Gets or sets a Boolean value that indicates whether URLs will be converted to lower case before checking for a match")]
    HRESULT ConvertUrlToLowerCase([out, retval] VARIANT_BOOL *pVal);
    [propput, id(7), helpstring("Gets or sets a Boolean value that indicates whether URLs will be converted to lower case before checking for a match")]
    HRESULT ConvertUrlToLowerCase([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(676D3396-07F4-4E56-A761-7444697FE1F8),
dual,
nonextensible,
helpstring("Web browser client configuration backup route information"),
pointer_default(unique)
]
interface IFPCClientBackupRoute : IDispatch
{
	[propget, id(1), helpstring("Gets or sets whether the option of backup route in the Web proxy client is enabled")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets whether the option of backup route in the Web proxy client is enabled")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(2), helpstring("Gets or sets the type of the backup route, such as direct to the Internet or by proxy")]
    HRESULT ClientBackupRouteType([out, retval] FpcClientBackupRouteType *pVal);
    [propput, id(2), helpstring("Gets or sets the type of the backup route, such as direct to the Internet or by proxy")]
    HRESULT ClientBackupRouteType([in] FpcClientBackupRouteType newVal);
	
	[propget, id(3), helpstring("Gets or sets the backup route")]
    HRESULT AutoConfigBackupRoute([out, retval] BSTR *pVal);
    [propput, id(3), helpstring("Gets or sets the backup route")]
    HRESULT AutoConfigBackupRoute([in] BSTR newVal);
	
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
};
	
[
object,
uuid(382909C7-CE6D-4E87-AA73-F1F412C3F33F),
dual,
nonextensible,
helpstring("Collection of LDT entries"),
pointer_default(unique)
]
interface IFPCLDT : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCLDTEntry** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Adds an LDT entry to the collection")]
          HRESULT Add( BSTR DomainName,
              [out,retval] IFPCLDTEntry** ppNewLDTEntry);
        
    
	[id(DISPID_REMOVE), helpstring("Removes an LDT entry from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
};
	
[
object,
uuid(42E5AF8A-AE69-4F4B-A422-0B283F4E7EB5),
dual,
nonextensible,
helpstring("A local domain table entry"),
pointer_default(unique)
]
interface IFPCLDTEntry : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the entry")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the entry")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(3), helpstring("Gets or sets the description of the entry")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(3), helpstring("Gets or sets the description of the entry")]
    HRESULT Description([in] BSTR newVal);
	
};
	
[
object,
uuid(ACAA3A2F-49B1-489E-B24A-54AE4251EC9B),
dual,
nonextensible,
helpstring("Collection of scheduled content download tasks"),
pointer_default(unique)
]
interface IFPCScheduledContentDownload : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCScheduledContentDownloadConfig** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Adds a prefetch task to the collection")]
          HRESULT Add( BSTR Name,
               BSTR URL,
              [out,retval] IFPCScheduledContentDownloadConfig** ppNewScheduledContentDownloadConfig);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a prefetch task from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[propget, id(1), helpstring("Gets whether the Web proxy clients is enabled for the local host network"), hidden]
    HRESULT EnableLocalHostWebProxyClients([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(2), helpstring("Gets whether the Prefetcher System Policy is enabled"), hidden]
    HRESULT EnablePrefetcherSystemPolicy([out, retval] VARIANT_BOOL *pVal);
	
};
	
[
object,
uuid(FF37B351-3484-4759-BF69-094F3C3A51CF),
dual,
nonextensible,
helpstring("A scheduled content download job"),
pointer_default(unique)
]
interface IFPCScheduledContentDownloadConfig : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the content download job")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the content download job")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(3), helpstring("Gets or sets the description of the content download job")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(3), helpstring("Gets or sets the description of the content download job")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(5), helpstring("Retrieves the days of the week on which the content download job will run")]
    HRESULT ScheduleDays([out, retval] FpcDaysOfWeek *pVal);
	
	[propget, id(7), helpstring("Gets or sets the upper limit of the depth to fetch")]
    HRESULT MaxDepth([out, retval] long *pVal);
    [propput, id(7), helpstring("Gets or sets the upper limit of the depth to fetch")]
    HRESULT MaxDepth([in] long newVal);
	
	[propget, id(8), helpstring("Gets or sets the upper limit of total cache-object size in kilobytes")]
    HRESULT MaxPages([out, retval] long *pVal);
    [propput, id(8), helpstring("Gets or sets the upper limit of total cache-object size in kilobytes")]
    HRESULT MaxPages([in] long newVal);
	
	[propget, id(9), helpstring("Gets or sets the hour part of the start time for a content download job that runs only once")]
    HRESULT DownloadOnceHour([out, retval] long *pVal);
    [propput, id(9), helpstring("Gets or sets the hour part of the start time for a content download job that runs only once")]
    HRESULT DownloadOnceHour([in] long newVal);
	
	[propget, id(10), helpstring("Gets or sets the minute part of the start time for a content download job that runs only once")]
    HRESULT DownloadOnceMinute([out, retval] long *pVal);
    [propput, id(10), helpstring("Gets or sets the minute part of the start time for a content download job that runs only once")]
    HRESULT DownloadOnceMinute([in] long newVal);
	
	[propget, id(11), helpstring("Gets or sets the day part of the date to start the content download job")]
    HRESULT StartDateDay([out, retval] long *pVal);
    [propput, id(11), helpstring("Gets or sets the day part of the date to start the content download job")]
    HRESULT StartDateDay([in] long newVal);
	
	[propget, id(12), helpstring("Gets or sets the month part of the date to start the content download job")]
    HRESULT StartDateMonth([out, retval] long *pVal);
    [propput, id(12), helpstring("Gets or sets the month part of the date to start the content download job")]
    HRESULT StartDateMonth([in] long newVal);
	
	[propget, id(13), helpstring("Gets or sets the year part of the date to start the content download job")]
    HRESULT StartDateYear([out, retval] long *pVal);
    [propput, id(13), helpstring("Gets or sets the year part of the date to start the content download job")]
    HRESULT StartDateYear([in] long newVal);
	
	[propget, id(14), helpstring("Gets or sets a Boolean value that indicates whether to download content only from the domain of the root URL, or from other domains as well")]
    HRESULT StayInDomain([out, retval] VARIANT_BOOL *pVal);
    [propput, id(14), helpstring("Gets or sets a Boolean value that indicates whether to download content only from the domain of the root URL, or from other domains as well")]
    HRESULT StayInDomain([in] VARIANT_BOOL newVal);
	
	[propget, id(15), helpstring("Gets an enumeration value that specifies whether the content download job is run only once, every day, or on specified days of the week")]
    HRESULT TaskPeriod([out, retval] FpcScheduledTaskRunningPeriod *pVal);
	
	[propget, id(16), helpstring("Gets or sets the Time to Live (TTL) of the pages to be downloaded (in minutes)")]
    HRESULT TTL([out, retval] long *pVal);
    [propput, id(16), helpstring("Gets or sets the Time to Live (TTL) of the pages to be downloaded (in minutes)")]
    HRESULT TTL([in] long newVal);
	
	[propget, id(17), helpstring("Gets or sets a Boolean value that indicates whether the content download job is enabled")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(17), helpstring("Gets or sets a Boolean value that indicates whether the content download job is enabled")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(18), helpstring("Gets or sets the URL to be downloaded")]
    HRESULT URL([out, retval] BSTR *pVal);
    [propput, id(18), helpstring("Gets or sets the URL to be downloaded")]
    HRESULT URL([in] BSTR newVal);
	
	[propget, id(19), helpstring("Gets or sets the FETCH_TTL_IF_NONE flag, which is passed to the FetchUrl method")]
    HRESULT FetchUrlFlagTtlIfNone([out, retval] VARIANT_BOOL *pVal);
    [propput, id(19), helpstring("Gets or sets the FETCH_TTL_IF_NONE flag, which is passed to the FetchUrl method")]
    HRESULT FetchUrlFlagTtlIfNone([in] VARIANT_BOOL newVal);
	
	[propget, id(20), helpstring("Gets or sets the FETCH_TTL_OVERRIDE flag, which is passed to the FetchUrl method")]
    HRESULT FetchUrlFlagTtlOverride([out, retval] VARIANT_BOOL *pVal);
    [propput, id(20), helpstring("Gets or sets the FETCH_TTL_OVERRIDE flag, which is passed to the FetchUrl method")]
    HRESULT FetchUrlFlagTtlOverride([in] VARIANT_BOOL newVal);
	
	[propget, id(21), helpstring("Gets or sets the FETCH_SYNCHRONOUS flag, which is passed to the FetchUrl method")]
    HRESULT FetchUrlFlagSync([out, retval] VARIANT_BOOL *pVal);
    [propput, id(21), helpstring("Gets or sets the FETCH_SYNCHRONOUS flag, which is passed to the FetchUrl method")]
    HRESULT FetchUrlFlagSync([in] VARIANT_BOOL newVal);
	
	[propget, id(22), helpstring("Gets or sets the FETCH_NO_ARRAY_ROUTING flag, which is passed to the FetchUrl method")]
    HRESULT FetchUrlFlagNoArrayRoute([out, retval] VARIANT_BOOL *pVal);
    [propput, id(22), helpstring("Gets or sets the FETCH_NO_ARRAY_ROUTING flag, which is passed to the FetchUrl method")]
    HRESULT FetchUrlFlagNoArrayRoute([in] VARIANT_BOOL newVal);
	
	[propget, id(23), helpstring("Gets or sets the conditions under which content will be cached")]
    HRESULT FetchUrlCacheContent([out, retval] FpcCacheContent *pVal);
    [propput, id(23), helpstring("Gets or sets the conditions under which content will be cached")]
    HRESULT FetchUrlCacheContent([in] FpcCacheContent newVal);
	
	[id(30), helpstring("Sets the values of the TaskPeriod and ScheduleDays properties ")]
          HRESULT SetTaskPeriod( FpcScheduledTaskRunningPeriod period,
              [in,defaultvalue(fpcNone)] FpcDaysOfWeek days);
        
    
	[id(31), helpstring("Runs the scheduled content download")]
          HRESULT Run();
        
    
	[id(32), helpstring("Aborts the scheduled content download")]
          HRESULT AbortOnAllServers();
        
    
	[propget, id(33), helpstring("Gets or sets the number of concurrent TCP connections that may be created for the content download job")]
    HRESULT NumberOfConcurrentConnections([out, retval] long *pVal);
    [propput, id(33), helpstring("Gets or sets the number of concurrent TCP connections that may be created for the content download job")]
    HRESULT NumberOfConcurrentConnections([in] long newVal);
	
	[propget, id(34), helpstring("Gets or sets an enumeration value that specifies whether the download job is to run once on a single day or more than once on a single day")]
    HRESULT DailyFrequency([out, retval] FpcDailyFrequency *pVal);
    [propput, id(34), helpstring("Gets or sets an enumeration value that specifies whether the download job is to run once on a single day or more than once on a single day")]
    HRESULT DailyFrequency([in] FpcDailyFrequency newVal);
	
	[propget, id(35), helpstring("Gets or sets the hour for the daily download")]
    HRESULT DailyHour([out, retval] long *pVal);
    [propput, id(35), helpstring("Gets or sets the hour for the daily download")]
    HRESULT DailyHour([in] long newVal);
	
	[propget, id(36), helpstring("Gets or sets the minute part of the time for a one-time run on a single day")]
    HRESULT DailyMinute([out, retval] long *pVal);
    [propput, id(36), helpstring("Gets or sets the minute part of the time for a one-time run on a single day")]
    HRESULT DailyMinute([in] long newVal);
	
	[propget, id(37), helpstring("Gets or sets the repetition time for repeated runs on a single day")]
    HRESULT DailyFreqTimeValue([out, retval] long *pVal);
    [propput, id(37), helpstring("Gets or sets the repetition time for repeated runs on a single day")]
    HRESULT DailyFreqTimeValue([in] long newVal);
	
	[propget, id(38), helpstring("Gets or sets the time units of the repetition time for repeated runs on a single day")]
    HRESULT DailyFreqTimeUnits([out, retval] FpcTimeScale *pVal);
    [propput, id(38), helpstring("Gets or sets the time units of the repetition time for repeated runs on a single day")]
    HRESULT DailyFreqTimeUnits([in] FpcTimeScale newVal);
	
	[propget, id(39), helpstring("Gets the hour part of the start time for repeated runs on a single day")]
    HRESULT DailyFreqStartHour([out, retval] long *pVal);
	
	[propget, id(40), helpstring("Gets the minute part of the start time for repeated runs on a single day")]
    HRESULT DailyFreqStartMinute([out, retval] long *pVal);
	
	[propget, id(41), helpstring("Gets the hour part of the end time for repeated runs on a single day")]
    HRESULT DailyFreqEndHour([out, retval] long *pVal);
	
	[propget, id(42), helpstring("Gets the minute part of the end time for repeated runs on a single day")]
    HRESULT DailyFreqEndMinute([out, retval] long *pVal);
	
	[id(43), helpstring("Sets the hour and minute parts of the start and end times for repeated runs on a single day")]
          HRESULT SetDailyFrequency( long StartTimeHour,
               long StartTimeMinute,
               long EndTimeHour,
               long EndTimeMinute);
        
    
	[propget, id(44), helpstring("Gets the status of the scheduled content download job")]
    HRESULT ScheduledContentDownloadJobStatuses([out, retval] IFPCScheduledContentDownloadJobStatuses **pVal);
	
};
	
[
object,
uuid(FCCE1F1D-17CB-43DF-BC8E-FC018B68C187),
dual,
nonextensible,
helpstring("Collection of public names"),
pointer_default(unique)
]
interface IFPCPublicNames : IDispatch
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] BSTR* pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_ADD), helpstring("Adds a public name to the collection")]
          HRESULT Add( BSTR Name);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a public name from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
};
	
[
object,
uuid(0415F6C1-B41F-4354-9965-1230CA1CDC6C),
dual,
nonextensible,
helpstring("Collection of pattern matching expressions for link translation"),
pointer_default(unique)
]
interface IFPCLinkTranslationPatterns : IDispatch
{
	[id(DISPID_VALUE), helpstring("Retrieves the requested pattern matching expression from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] BSTR* pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_REFRESH), helpstring("Reads all of the collection's properties and elements from persistent storage")]
          HRESULT Refresh();
        
    
	[id(DISPID_SAVE), helpstring("Writes any changes in the collection's properties and elements to persistent storage")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_ADD), helpstring("Adds a pattern matching expression to the collection")]
          HRESULT Add( BSTR Name);
        
    
	[id(DISPID_REMOVE), helpstring("Removes the specified pattern matching expression from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(1), helpstring("Removes all of the pattern matching expressions from this collection")]
          HRESULT RemoveAll();
        
    
};
	
[
object,
uuid(2C155CB7-A319-465c-BC0C-74C624F66FF5),
dual,
nonextensible,
helpstring("Configuration settings for redirecting links to unpublished sites in link translation"),
pointer_default(unique)
]
interface IFPCLinkTranslationRedirection : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets the URL to which links to the unpublished sites will be redirected")]
    HRESULT RedirectUrl([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the URL to which links to the unpublished sites will be redirected")]
    HRESULT RedirectUrl([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets a Boolean value that indicates whether links to the unpublished sites will be directed to the specified URL")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(2), helpstring("Gets or sets a Boolean value that indicates whether links to the unpublished sites will be directed to the specified URL")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(3), helpstring("Gets a collection that contains references to URL sets containing the URLs of unpublished sites")]
    HRESULT URLSets([out, retval] IFPCRefs **pVal);
	
};
	
[
object,
uuid(B505D2AC-4F70-4761-BAAD-B8A6AE2B96BA),
dual,
nonextensible,
helpstring("Collection of path mappings"),
pointer_default(unique)
]
interface IFPCPathMappings : IDispatch
{
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item([in] VARIANT Index,
              [out,retval] IFPCPathMapping** pItem);
        
    
	[id(DISPID_ADD), helpstring("Adds a path mapping to the collection")]
          HRESULT Add([in] BSTR InternalPath,
              [in] VARIANT_BOOL SameAsInternal,
              [in] BSTR ExternalPath,
              [out,retval] IFPCPathMapping** pNewItem);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a path mapping from the collection")]
          HRESULT Remove([in] VARIANT v);
        
    
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
};
	
[
object,
uuid(F8476F19-0248-4A54-BEEF-84AA34ACD848),
dual,
nonextensible,
helpstring("A path mapping"),
pointer_default(unique)
]
interface IFPCPathMapping : IDispatch
{
	[propget, id(DISPID_VALUE), helpstring("Gets the internal path")]
    HRESULT InternalPath([out, retval] BSTR *pVal);
	
	[propget, id(2), helpstring("Gets whether the path is the same as the internal path")]
    HRESULT SameAsInternalPath([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(3), helpstring("Gets the external path")]
    HRESULT ExternalPath([out, retval] BSTR *pVal);
	
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
};
	
[
object,
uuid(D30F9C36-3390-4A61-A564-213F8A7F7F3C),
dual,
nonextensible,
helpstring("Filter expression"),
pointer_default(unique)
]
interface IFPCFilterExpression : IDispatch
{
	[propget, id(1), helpstring("Gets the criteria")]
    HRESULT Criteria([out, retval] FpcFilterCriteria *pVal);
	
	[propget, id(2), helpstring("Gets the condition")]
    HRESULT Condition([out, retval] FpcFilterCondition *pVal);
	
	[propget, id(3), helpstring("Gets the value type")]
    HRESULT ValueType([out, retval] FpcFilterValueType *pVal);
	
	[propget, id(4), helpstring("Gets the value")]
    HRESULT EnumValue([out, retval] long *pVal);
	
	[propget, id(5), helpstring("Gets the value")]
    HRESULT NumericValue([out, retval] long *pVal);
	
	[propget, id(6), helpstring("Gets the value")]
    HRESULT IPAddressValue([out, retval] BSTR *pVal);
	
	[propget, id(7), helpstring("Gets the value")]
    HRESULT StringValue([out, retval] BSTR *pVal);
	
	[propget, id(8), helpstring("Gets the value")]
    HRESULT DateValue([out, retval] DATE *pVal);
	
};
	
[
object,
uuid(EF4850F9-E09D-4360-B389-14E313F28058),
dual,
helpstring("Filter query"),
pointer_default(unique)
]
interface IFPCFilterExpressions : IDispatch
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( long index,
              [out,retval] IFPCFilterExpression** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(1), helpstring("Adds a filter expression to the collection")]
          HRESULT AddEnumFilter([in] FpcFilterCriteria Criteria,
              [in] FpcFilterCondition Condition,
              [in] long Value,
              [out,retval] IFPCFilterExpression** ppNewFilterExpression);
        
    
	[id(2), helpstring("Adds a filter expression to the collection")]
          HRESULT AddNumericFilter([in] FpcFilterCriteria Criteria,
              [in] FpcFilterCondition Condition,
              [in] long Value,
              [out,retval] IFPCFilterExpression** ppNewFilterExpression);
        
    
	[id(3), helpstring("Adds a filter expression to the collection")]
          HRESULT AddIPAddressFilter([in] FpcFilterCriteria Criteria,
              [in] FpcFilterCondition Condition,
              [in] BSTR Value,
              [out,retval] IFPCFilterExpression** ppNewFilterExpression);
        
    
	[id(4), helpstring("Adds a filter expression to the collection")]
          HRESULT AddStringFilter([in] FpcFilterCriteria Criteria,
              [in] FpcFilterCondition Condition,
              [in] BSTR Value,
              [out,retval] IFPCFilterExpression** ppNewFilterExpression);
        
    
	[id(5), helpstring("Adds a filter expression to the collection")]
          HRESULT AddDateFilter([in] FpcFilterCriteria Criteria,
              [in] FpcFilterCondition Condition,
              [in] DATE Value,
              [out,retval] IFPCFilterExpression** ppNewFilterExpression);
        
    
	[propget, id(6), helpstring("Gets the type of the filter. session filter or log filter")]
    HRESULT FilterType([out, retval] FpcFilterType *pVal);
    [propput, id(6), helpstring("Gets the type of the filter. session filter or log filter")]
    HRESULT FilterType([in] FpcFilterType newVal);
	
	[id(DISPID_REMOVE), helpstring("Removes a filter expression from the collection")]
          HRESULT Remove( long index);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
};
	
[
object,
uuid(371AB1FF-7AEC-4a1e-BA67-EDF92092F71F),
dual,
nonextensible,
helpstring("Filter query"),
pointer_default(unique)
]
interface IFPCFilterExpressions2 : IFPCFilterExpressions
{
	[id(7), helpstring("Adds a filter expression to the collection")]
          HRESULT AddMultipleStringFilter([in] FpcFilterCriteria Criteria,
              [in] FpcFilterCondition Condition,
              [in] BSTR Value,
              [out,retval] IFPCFilterExpression** ppNewFilterExpression);
        
    
	[id(8), helpstring("Adds a filter expression to the collection")]
          HRESULT AddMultipleEnumFilter([in] FpcFilterCriteria Criteria,
              [in] FpcFilterCondition Condition,
              [in] long Value,
              [out,retval] IFPCFilterExpression** ppNewFilterExpression);
        
    
};
	
[
object,
uuid(956ce8c8-6fcd-476c-934e-91d60972c7ad),
dual,
nonextensible,
helpstring("Collection of user agent strings"),
pointer_default(unique)
]
interface IFPCUserAgents : IDispatch
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] BSTR* pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_ADD), helpstring("Adds a user agent name to the collection")]
          HRESULT Add( BSTR Name);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a user agent name from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
};
	
[
object,
uuid(5d105891-fdd9-473a-9090-984ac5c864b4),
dual,
nonextensible,
helpstring("Collection of HTTP headers"),
pointer_default(unique)
]
interface IFPCHTTPHeaders : IDispatch
{
	[id(DISPID_VALUE), helpstring("Returns the specified HTTP header from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] BSTR* pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[id(DISPID_SAVE), helpstring("Writes all changes in the collection's data to persistent storage")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_ADD), helpstring("Adds an HTTP header to the collection")]
          HRESULT Add( BSTR Name);
        
    
	[id(DISPID_REMOVE), helpstring("Removes an HTTP header from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
};
	
[
object,
uuid(435051CF-8578-4A39-B9E1-11B62D616AD7),
dual,
nonextensible,
helpstring("Defines firewall chainings"),
pointer_default(unique)
]
interface IFPCFirewallChaining : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets the how requests are chained")]
    HRESULT ForwardType([out, retval] FpcFwForwardType *pVal);
    [propput, id(1), helpstring("Gets or sets the how requests are chained")]
    HRESULT ForwardType([in] FpcFwForwardType newVal);
	
	[propget, id(2), helpstring("Gets or sets the name or IP address of the server or array to which to chain")]
    HRESULT ForwardTo([out, retval] BSTR *pVal);
    [propput, id(2), helpstring("Gets or sets the name or IP address of the server or array to which to chain")]
    HRESULT ForwardTo([in] BSTR newVal);
	
	[propget, id(3), helpstring("Gets credential information for authentication when chaining to an upstream server")]
    HRESULT Credentials([out, retval] IFPCCredentials **pVal);
	
	[propget, id(4), helpstring("Gets or sets whether use of authentication in upstream routing is enabled")]
    HRESULT AuthenticationEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(4), helpstring("Gets or sets whether use of authentication in upstream routing is enabled")]
    HRESULT AuthenticationEnabled([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(5BDA4E41-5BD7-4C4A-9317-3B0C0346E95C),
dual,
nonextensible,
helpstring("Defines firewall dialing"),
pointer_default(unique)
]
interface IFPCDialingConfiguration : IFPCPersist
{
	[id(1), helpstring("Enable automatic dialing when the firewall first tries to access the network ")]
          HRESULT EnableAutoDialToNetwork( BSTR NetworkName,
              [in,defaultvalue("")] BSTR newDialupConnectionName);
        
    
	[id(2), helpstring("Disable automatic dialing")]
          HRESULT DisableAutoDial();
        
    
	[propget, id(3), helpstring("Gets a Boolean that indicates whether automatic dialing is enabled ")]
    HRESULT AutoDialEnabled([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(4), helpstring("Gets a reference to the network to which the automatic dialing configuration refers")]
    HRESULT AutoDialedNetwork([out, retval] IFPCRef **pVal);
	
	[propget, id(5), helpstring("Gets the name of the dial-up connection that is configured on the firewall servers which is used for automatic dialing")]
    HRESULT DialupConnectionName([out, retval] BSTR *pVal);
    [propput, id(5), helpstring("Gets the name of the dial-up connection that is configured on the firewall servers which is used for automatic dialing")]
    HRESULT DialupConnectionName([in] BSTR newVal);
	
	[propget, id(6), helpstring("Gets the credentials needed for automatic dialing")]
    HRESULT Credentials([out, retval] IFPCCredentials **pVal);
	
	[propget, id(7), helpstring("Gets or sets whether the dial up connection should become the default gateway when active")]
    HRESULT DefaultGateway([out, retval] VARIANT_BOOL *pVal);
    [propput, id(7), helpstring("Gets or sets whether the dial up connection should become the default gateway when active")]
    HRESULT DefaultGateway([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(A038F7DE-03CF-4AE4-BC57-98B0CF7F40D3),
dual,
helpstring("Defines Web proxy attributes"),
pointer_default(unique)
]
interface IFPCWebProxy : IFPCPersist
{
	[propget, id(9), helpstring("Gets a collection of tunnel port ranges")]
    HRESULT TunnelPortRanges([out, retval] IFPCTunnelPortRanges **pVal);
	
	[propget, id(10), helpstring("Gets or sets whether a Web proxy computer uses a DNS or WINS name system")]
    HRESULT CARPNameSystem([out, retval] FpcNameSystem *pVal);
    [propput, id(10), helpstring("Gets or sets whether a Web proxy computer uses a DNS or WINS name system")]
    HRESULT CARPNameSystem([in] FpcNameSystem newVal);
	
	[propget, id(11), helpstring("Gets or sets whether the Web proxy will use DNS or WINS information to resolve the name of an upstream server")]
    HRESULT UpstreamResolveSystem([out, retval] FpcNameSystem *pVal);
    [propput, id(11), helpstring("Gets or sets whether the Web proxy will use DNS or WINS information to resolve the name of an upstream server")]
    HRESULT UpstreamResolveSystem([in] FpcNameSystem newVal);
	
	[propget, id(12), helpstring("Gets or sets whether the Web proxy will check client certificate CRL")]
    HRESULT ValidateClientCertificateCRL([out, retval] VARIANT_BOOL *pVal);
    [propput, id(12), helpstring("Gets or sets whether the Web proxy will check client certificate CRL")]
    HRESULT ValidateClientCertificateCRL([in] VARIANT_BOOL newVal);
	
	[propget, id(13), helpstring("Gets or sets whether the Web proxy will check server certificate CRLs in forward scenario. This setting applies when Forefront TMG, acting as a Web proxy, initiates a secure connection (SSL bridging) to an upstream proxy or Web server")]
    HRESULT ValidateServerCertificateCRLInForward([out, retval] VARIANT_BOOL *pVal);
    [propput, id(13), helpstring("Gets or sets whether the Web proxy will check server certificate CRLs in forward scenario. This setting applies when Forefront TMG, acting as a Web proxy, initiates a secure connection (SSL bridging) to an upstream proxy or Web server")]
    HRESULT ValidateServerCertificateCRLInForward([in] VARIANT_BOOL newVal);
	
	[propget, id(14), helpstring("Gets or sets whether the Web proxy will prefer digest authentication over advanced digest authentication on .NET server")]
    HRESULT UseDigestSSP([out, retval] VARIANT_BOOL *pVal);
    [propput, id(14), helpstring("Gets or sets whether the Web proxy will prefer digest authentication over advanced digest authentication on .NET server")]
    HRESULT UseDigestSSP([in] VARIANT_BOOL newVal);
	
	[propget, id(15), helpstring("Gets or sets whether the Web proxy will skip name resolution while checking Web publishing rules")]
    HRESULT SkipNameResolutionForWebPublishingRules([out, retval] VARIANT_BOOL *pVal);
    [propput, id(15), helpstring("Gets or sets whether the Web proxy will skip name resolution while checking Web publishing rules")]
    HRESULT SkipNameResolutionForWebPublishingRules([in] VARIANT_BOOL newVal);
	
	[propget, id(16), helpstring("Gets or sets whether the Web proxy will skip name resolution while checking access and routing rules")]
    HRESULT SkipNameResolutionForAccessAndRoutingRules([out, retval] VARIANT_BOOL *pVal);
    [propput, id(16), helpstring("Gets or sets whether the Web proxy will skip name resolution while checking access and routing rules")]
    HRESULT SkipNameResolutionForAccessAndRoutingRules([in] VARIANT_BOOL newVal);
	
	[propget, id(17), helpstring("Gets or sets whether the Web proxy will remove all proxy authorization headers from requests passed to upstream server")]
    HRESULT RemoveAllProxyAuthorization([out, retval] VARIANT_BOOL *pVal);
    [propput, id(17), helpstring("Gets or sets whether the Web proxy will remove all proxy authorization headers from requests passed to upstream server")]
    HRESULT RemoveAllProxyAuthorization([in] VARIANT_BOOL newVal);
	
	[propget, id(18), helpstring("Gets or sets whether the Web proxy will remove all redundant proxy authorization headers from requests passed to upstream server")]
    HRESULT RemoveRedundantProxyAuthorization([out, retval] VARIANT_BOOL *pVal);
    [propput, id(18), helpstring("Gets or sets whether the Web proxy will remove all redundant proxy authorization headers from requests passed to upstream server")]
    HRESULT RemoveRedundantProxyAuthorization([in] VARIANT_BOOL newVal);
	
	[propget, id(19), helpstring("Gets or sets the password that will be used when connecting anonymous ftp requests")]
    HRESULT WebProxyFtpClientPassword([out, retval] BSTR *pVal);
    [propput, id(19), helpstring("Gets or sets the password that will be used when connecting anonymous ftp requests")]
    HRESULT WebProxyFtpClientPassword([in] BSTR newVal);
	
	[propget, id(20), helpstring("Gets or sets the size of the connection cache")]
    HRESULT ConnectCacheSize([out, retval] long *pVal);
    [propput, id(20), helpstring("Gets or sets the size of the connection cache")]
    HRESULT ConnectCacheSize([in] long newVal);
	
	[propget, id(21), helpstring("Gets or sets the maximum allowd size of the http response headers")]
    HRESULT MaxResponseHeadersSize([out, retval] long *pVal);
    [propput, id(21), helpstring("Gets or sets the maximum allowd size of the http response headers")]
    HRESULT MaxResponseHeadersSize([in] long newVal);
	
	[propget, id(22), helpstring("Gets or sets whether the Web proxy will remove trailers from responses that are encoded with the chunked transfer coding (this setting is only relevant for responses sent to http 1.1 clients)")]
    HRESULT RemoveTrailersFromChunkedEncodedResponses([out, retval] VARIANT_BOOL *pVal);
    [propput, id(22), helpstring("Gets or sets whether the Web proxy will remove trailers from responses that are encoded with the chunked transfer coding (this setting is only relevant for responses sent to http 1.1 clients)")]
    HRESULT RemoveTrailersFromChunkedEncodedResponses([in] VARIANT_BOOL newVal);
	
	[propget, id(23), helpstring("Gets or sets whether the Web proxy will try to connect to the certificate authority and download the most updated CRL")]
    HRESULT ValidateCrlOnline([out, retval] VARIANT_BOOL *pVal);
    [propput, id(23), helpstring("Gets or sets whether the Web proxy will try to connect to the certificate authority and download the most updated CRL")]
    HRESULT ValidateCrlOnline([in] VARIANT_BOOL newVal);
	
	[propget, id(24), helpstring("Gets or sets whether the Web proxy will check server certificate CRL in reverse scenario. This setting applies when Forefront TMG, publishing a website, initiates a secure connection (SSL bridging) to the published Web server")]
    HRESULT ValidateServerCertificateCRLInReverse([out, retval] VARIANT_BOOL *pVal);
    [propput, id(24), helpstring("Gets or sets whether the Web proxy will check server certificate CRL in reverse scenario. This setting applies when Forefront TMG, publishing a website, initiates a secure connection (SSL bridging) to the published Web server")]
    HRESULT ValidateServerCertificateCRLInReverse([in] VARIANT_BOOL newVal);
	
	[propget, id(25), helpstring("Gets or sets a Boolean value that indicates whether the Web proxy will reject requests with URLs that are longer than the maximum length that can be logged")]
    HRESULT EnforceLogUrlLengthInWebProxy([out, retval] VARIANT_BOOL *pVal);
    [propput, id(25), helpstring("Gets or sets a Boolean value that indicates whether the Web proxy will reject requests with URLs that are longer than the maximum length that can be logged")]
    HRESULT EnforceLogUrlLengthInWebProxy([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(1cf41ef3-d9da-46dd-905f-ffb2ddb2467d),
dual,
helpstring("Defines Web proxy attributes"),
pointer_default(unique)
]
interface IFPCEEWebProxy : IFPCWebProxy
{
	[propget, id(26), helpstring("Gets or sets whether the Web proxy will remove trailers from requests that are encoded with the chunked transfer coding (this setting is only relevant for requests sent by http 1.1 clients)")]
    HRESULT RemoveTrailersFromChunkedEncodedRequests([out, retval] VARIANT_BOOL *pVal);
    [propput, id(26), helpstring("Gets or sets whether the Web proxy will remove trailers from requests that are encoded with the chunked transfer coding (this setting is only relevant for requests sent by http 1.1 clients)")]
    HRESULT RemoveTrailersFromChunkedEncodedRequests([in] VARIANT_BOOL newVal);
	
	[propget, id(27), helpstring("Gets or sets whether the Web proxy will skip the authentication process for routing information requests")]
    HRESULT SkipAuthenticationForRoutingInformation([out, retval] VARIANT_BOOL *pVal);
    [propput, id(27), helpstring("Gets or sets whether the Web proxy will skip the authentication process for routing information requests")]
    HRESULT SkipAuthenticationForRoutingInformation([in] VARIANT_BOOL newVal);
	
	[propget, id(28), helpstring("Gets a reference to the collection of references to the domain name sets which represent the CARP exception list")]
    HRESULT CARPExceptions([out, retval] IFPCRefs **pVal);
	
};
	
[
object,
uuid(dafc907b-35bf-49b6-8201-fb62bc64670d),
dual,
helpstring("Defines Web proxy attributes"),
pointer_default(unique)
]
interface IFPCWebProxy2 : IFPCEEWebProxy
{
	[propget, id(29), helpstring("Gets an object that defines the HTTP compression configuration settings")]
    HRESULT HTTPCompressionConfiguration([out, retval] IFPCHTTPCompressionConfiguration **pVal);
	
	[propget, id(30), helpstring("Gets a collection of explicit link translation mappings")]
    HRESULT ExplicitLinkTranslationMappings([out, retval] IFPCExplicitLinkTranslationMappings **pVal);
	
	[propget, id(31), helpstring("Gets or sets a Boolean value that indicates whether link translation can be enabled in Web publishing rules")]
    HRESULT LinkTranslationEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(31), helpstring("Gets or sets a Boolean value that indicates whether link translation can be enabled in Web publishing rules")]
    HRESULT LinkTranslationEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(32), helpstring("Gets or sets a Boolean value that indicates whether to apply PUT and DELETE on cache in forward web proxy scenario")]
    HRESULT ApplyPutAndDeleteInForward([out, retval] VARIANT_BOOL *pVal);
    [propput, id(32), helpstring("Gets or sets a Boolean value that indicates whether to apply PUT and DELETE on cache in forward web proxy scenario")]
    HRESULT ApplyPutAndDeleteInForward([in] VARIANT_BOOL newVal);
	
	[propget, id(33), helpstring("Gets or sets a Boolean value that indicates whether to apply PUT and DELETE on cache in reverse web proxy scenario")]
    HRESULT ApplyPutAndDeleteInReverse([out, retval] VARIANT_BOOL *pVal);
    [propput, id(33), helpstring("Gets or sets a Boolean value that indicates whether to apply PUT and DELETE on cache in reverse web proxy scenario")]
    HRESULT ApplyPutAndDeleteInReverse([in] VARIANT_BOOL newVal);
	
	[propget, id(34), helpstring("Gets the configuration settings for redirecting links to unpublished sites in link translation")]
    HRESULT LinkTranslationRedirection([out, retval] IFPCLinkTranslationRedirection **pVal);
	
	[propget, id(35), helpstring("Gets or sets a Boolean value that indicates whether requests with an invalid UTF8-encoded URL will be blocked")]
    HRESULT BlockInvalidUtf8Urls([out, retval] VARIANT_BOOL *pVal);
    [propput, id(35), helpstring("Gets or sets a Boolean value that indicates whether requests with an invalid UTF8-encoded URL will be blocked")]
    HRESULT BlockInvalidUtf8Urls([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(F5720ED0-AA95-4710-8139-D38B9F818017),
dual,
nonextensible,
helpstring("Defines Web proxy attributes"),
pointer_default(unique)
]
interface IFPCWebProxy3 : IFPCWebProxy2
{
	[propget, id(36), helpstring("Gets an FPCOutboundHTTPSInspectionConfiguration object that holds the configuration settings for outbound HTTPS inspection."), hidden]
    HRESULT OutboundHTTPSInspectionConfiguration([out, retval] IFPCOutboundHTTPSInspectionConfiguration **pVal);
	
	[propget, id(37), helpstring("Gets an FPCUrlFilteringSettings object that holds the URL filtering settings for the array")]
    HRESULT UrlFilteringSettings([out, retval] IFPCUrlFilteringSettings **pVal);
	
	[propget, id(38), helpstring("Gets an FPCCookieCryptoConfiguration object that holds the configuration used for cookie hashing and encryption in forms-based authentication")]
    HRESULT CookieCryptoConfiguration([out, retval] IFPCCookieCryptoConfiguration **pVal);
	
	[propget, id(39), helpstring("Gets an PerfCounterSettings object that holds the web proxy counters settings")]
    HRESULT PerfCounterSettings([out, retval] IFPCPerfCounterSettings **pVal);
	
	[id(40), helpstring("Performs connectivity test to the specified web server")]
            HRESULT TestConnectivity
            (
                [in] BSTR ServerUrl,
                [in] LONG PathPingMode,
                [out,retval] BSTR* TestResult
            );
        
    
};
	
[
object,
uuid(bf065e4e-916f-444e-84a2-986ea857910f),
dual,
nonextensible,
helpstring("Defines cookie crypto configuration attributes"),
pointer_default(unique)
]
interface IFPCCookieCryptoConfiguration : IDispatch
{
	[propget, id(1), helpstring("Gets or sets the ID of the algorithm used for cookie hashing")]
    HRESULT HashAlgorithmId([out, retval] long *pVal);
    [propput, id(1), helpstring("Gets or sets the ID of the algorithm used for cookie hashing")]
    HRESULT HashAlgorithmId([in] long newVal);
	
	[propget, id(2), helpstring("Gets or sets the symmetric algorithm ID used for cookie encryption")]
    HRESULT EncryptionAlgorithmId([out, retval] long *pVal);
    [propput, id(2), helpstring("Gets or sets the symmetric algorithm ID used for cookie encryption")]
    HRESULT EncryptionAlgorithmId([in] long newVal);
	
	[propget, id(3), helpstring("Gets or sets the session key size in bits")]
    HRESULT KeyLengthMask([out, retval] long *pVal);
    [propput, id(3), helpstring("Gets or sets the session key size in bits")]
    HRESULT KeyLengthMask([in] long newVal);
	
	[propget, id(4), helpstring("Gets or sets the name of the cryptographic service provider to be used with cookies")]
    HRESULT ProviderName([out, retval] BSTR *pVal);
    [propput, id(4), helpstring("Gets or sets the name of the cryptographic service provider to be used with cookies")]
    HRESULT ProviderName([in] BSTR newVal);
	
	[propget, id(5), helpstring("Gets or sets the type of the cryptographic service provider to be used with cookies")]
    HRESULT ProviderType([out, retval] long *pVal);
    [propput, id(5), helpstring("Gets or sets the type of the cryptographic service provider to be used with cookies")]
    HRESULT ProviderType([in] long newVal);
	
};
	
[
object,
uuid(E8C3C748-290D-43D5-BDB5-5A146D76FCBB),
dual,
nonextensible,
helpstring("User Mapping Settings"),
pointer_default(unique)
]
interface IFPCUserMapping : IDispatch
{
	[propget, id(1), helpstring("Gets or sets whether user mapping is enabled")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets whether user mapping is enabled")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(2), helpstring("Gets or sets the domain for user mapping")]
    HRESULT Domain([out, retval] BSTR *pVal);
    [propput, id(2), helpstring("Gets or sets the domain for user mapping")]
    HRESULT Domain([in] BSTR newVal);
	
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
};
	
[
object,
uuid(7F79E3FF-09CE-4A35-B242-8F6EA4C7F318),
dual,
nonextensible,
helpstring("An authentication scheme"),
pointer_default(unique)
]
interface IFPCAuthenticationScheme : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the namespace of the authentication scheme")]
    HRESULT Namespace([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the namespace of the authentication scheme")]
    HRESULT Namespace([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets the version of the authentication scheme")]
    HRESULT Version([out, retval] BSTR *pVal);
    [propput, id(2), helpstring("Gets or sets the version of the authentication scheme")]
    HRESULT Version([in] BSTR newVal);
	
	[propget, id(3), helpstring("Gets or sets the name of the vendor of the authentication scheme")]
    HRESULT Vendor([out, retval] BSTR *pVal);
    [propput, id(3), helpstring("Gets or sets the name of the vendor of the authentication scheme")]
    HRESULT Vendor([in] BSTR newVal);
	
	[propget, id(4), helpstring("Gets or sets the description of the authentication scheme")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(4), helpstring("Gets or sets the description of the authentication scheme")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(9), helpstring("Gets or sets which services can use the authentication scheme")]
    HRESULT Services([out, retval] FpcServiceTypes *pVal);
    [propput, id(9), helpstring("Gets or sets which services can use the authentication scheme")]
    HRESULT Services([in] FpcServiceTypes newVal);
	
	[propget, id(10), helpstring("Gets or sets whether this authentication scheme provides a users namespace and a authentication method")]
    HRESULT Provides([out, retval] FpcAuthenticationSchemeProvides *pVal);
    [propput, id(10), helpstring("Gets or sets whether this authentication scheme provides a users namespace and a authentication method")]
    HRESULT Provides([in] FpcAuthenticationSchemeProvides newVal);
	
	[propget, id(12), helpstring("Gets whether the authentication scheme is a preinstalled rule element that cannot be deleted")]
    HRESULT Predefined([out, retval] VARIANT_BOOL *pVal);
	
};
	
[
object,
uuid(F0A23B0E-1728-48C4-B893-A6D10E5EC01E),
dual,
nonextensible,
helpstring("Collection of authentication schemes"),
pointer_default(unique)
]
interface IFPCAuthenticationSchemes : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCAuthenticationScheme** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_ADD), helpstring("Adds an authentication scheme to the collection")]
          HRESULT Add( BSTR Namespace,
               BSTR StorageName,
              [out,retval] IFPCAuthenticationScheme** ppNewScheme);
        
    
	[id(DISPID_REMOVE), helpstring("Removes an authentication scheme from the collection")]
          HRESULT Remove( VARIANT v);
        
    
};
	
[
object,
uuid(910878C4-9634-49FB-A01E-14D397ED5813),
dual,
helpstring("A Web filter"),
pointer_default(unique)
]
interface IFPCWebFilter : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the vendor-supplied name of the filter")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the vendor-supplied name of the filter")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets the vendor-supplied version of the filter")]
    HRESULT Version([out, retval] BSTR *pVal);
    [propput, id(2), helpstring("Gets or sets the vendor-supplied version of the filter")]
    HRESULT Version([in] BSTR newVal);
	
	[propget, id(3), helpstring("Gets or sets the name of the vendor of the filter")]
    HRESULT Vendor([out, retval] BSTR *pVal);
    [propput, id(3), helpstring("Gets or sets the name of the vendor of the filter")]
    HRESULT Vendor([in] BSTR newVal);
	
	[propget, id(4), helpstring("Gets or sets the vendor-supplied description of the filter")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(4), helpstring("Gets or sets the vendor-supplied description of the filter")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(5), helpstring("Gets the GUID that identifies the filter")]
    HRESULT Guid([out, retval] BSTR *pVal);
	
	[propget, id(6), helpstring("Gets the filter's place in the order of filters")]
    HRESULT Order([out, retval] long *pVal);
	
	[propget, id(8), helpstring("Gets or sets the filter DLL path relative to Forefront TMG installation directory\isapi")]
    HRESULT RelativePath([out, retval] BSTR *pVal);
    [propput, id(8), helpstring("Gets or sets the filter DLL path relative to Forefront TMG installation directory\isapi")]
    HRESULT RelativePath([in] BSTR newVal);
	
	[propget, id(11), helpstring("Gets or sets whether the filter is enabled")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(11), helpstring("Gets or sets whether the filter is enabled")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(12), helpstring("Gets whether the filter operates in reverse proxy, forward proxy, or both configurations")]
    HRESULT FilterDirection([out, retval] FpcFilterDirection *pVal);
	
	[propget, id(13), helpstring("Gets or sets the priority of the filter")]
    HRESULT Priority([out, retval] FpcFilterPriority *pVal);
    [propput, id(13), helpstring("Gets or sets the priority of the filter")]
    HRESULT Priority([in] FpcFilterPriority newVal);
	
};
	
[
object,
uuid(D7BD923F-E263-4744-8FA3-EBE6F677FC65),
dual,
nonextensible,
helpstring("A Web filter"),
pointer_default(unique)
]
interface IFPCWebFilter2 : IFPCWebFilter
{
	[propget, id(14), helpstring("Gets or sets a Boolean value that indicates whether the Web filter will receive notifications for outbound HTTPS requests sent over an inspected SSL tunnel"), hidden]
    HRESULT HandleInspectedOutboundHTTPSRequests([out, retval] VARIANT_BOOL *pVal);
    [propput, id(14), helpstring("Gets or sets a Boolean value that indicates whether the Web filter will receive notifications for outbound HTTPS requests sent over an inspected SSL tunnel"), hidden]
    HRESULT HandleInspectedOutboundHTTPSRequests([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(7B407F22-3DBB-4879-AE9B-93B7FC97AC8F),
dual,
nonextensible,
helpstring("Collection of Web filters"),
pointer_default(unique)
]
interface IFPCWebFilters : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCWebFilter** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_ADD), helpstring("Adds a Web filter to the collection")]
          HRESULT Add( BSTR Guid,
               BSTR Name,
               BSTR RelativePath,
               FpcFilterPriority Priority,
               FpcFilterDirection Direction,
              [out,retval] IFPCWebFilter** ppNewFilter);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a Web filter from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[id(8), helpstring("Moves the given filter one step up in the filter order")]
          HRESULT MoveUp( long index);
        
    
	[id(9), helpstring("Moves the given filter one step down in the filter order")]
          HRESULT MoveDown( long index);
        
    
};
	
[
object,
uuid(762B0F4C-11CD-41D2-972D-F6623489DE50),
dual,
nonextensible,
helpstring("Collection of tunnel port ranges"),
pointer_default(unique)
]
interface IFPCTunnelPortRanges : IDispatch
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCTunnelPortRange** ppItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a tunnel port range from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[id(5), helpstring("Adds a tunnel port range to the collection")]
          HRESULT AddRange( BSTR bstrName,
               long lLowPort,
               long lHighPort,
              [out,retval] IFPCTunnelPortRange** ppNewDest);
        
    
};
	
[
object,
uuid(025b848e-8016-404d-a2d1-dadecc458f9f),
dual,
helpstring("Defines HTTP compression configuration settings"),
pointer_default(unique)
]
interface IFPCHTTPCompressionConfiguration : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets a Boolean value that indicates whether HTTP compression is enabled")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets a Boolean value that indicates whether HTTP compression is enabled")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(2), helpstring("Gets an object that specifies the complete set of source IP addresses for which HTTP compression is enabled")]
    HRESULT RequestSource([out, retval] IFPCSelectionIPs **pVal);
	
	[propget, id(3), helpstring("Gets a collection of references to the Web listeners for which HTTP compression is enabled")]
    HRESULT WebListeners([out, retval] IFPCRefs **pVal);
	
	[propget, id(4), helpstring("Gets an object that specifies the complete set of destination IP addresses for which HTTP compression is enabled")]
    HRESULT RequestDestination([out, retval] IFPCSelectionIPs **pVal);
	
	[propget, id(5), helpstring("Gets a collection of references to the content type sets for which HTTP compression is enabled")]
    HRESULT CompressibleContentTypeSets([out, retval] IFPCRefs **pVal);
	
	[propget, id(6), helpstring("Gets or sets the minimum HTTP message content length that may be compressed")]
    HRESULT MinimumCompressionLength([out, retval] long *pVal);
    [propput, id(6), helpstring("Gets or sets the minimum HTTP message content length that may be compressed")]
    HRESULT MinimumCompressionLength([in] long newVal);
	
	[propget, id(7), helpstring("Gets or sets a Boolean value that indicates whether CompressibleContentTypeSets is interpreted as a list of compression exceptions")]
    HRESULT NoCompressionForSpecifiedContentTypes([out, retval] VARIANT_BOOL *pVal);
    [propput, id(7), helpstring("Gets or sets a Boolean value that indicates whether CompressibleContentTypeSets is interpreted as a list of compression exceptions")]
    HRESULT NoCompressionForSpecifiedContentTypes([in] VARIANT_BOOL newVal);
	
	[propget, id(8), helpstring("Gets or sets a Boolean value that indicates whether HTTP Compression is allowed for responses with no Content-Type or extension")]
    HRESULT AllowCompressionWithoutContentType([out, retval] VARIANT_BOOL *pVal);
    [propput, id(8), helpstring("Gets or sets a Boolean value that indicates whether HTTP Compression is allowed for responses with no Content-Type or extension")]
    HRESULT AllowCompressionWithoutContentType([in] VARIANT_BOOL newVal);
	
	[propget, id(9), helpstring("Gets the object that contains user agent names that don't support compression")]
    HRESULT UnsupportedUserAgents([out, retval] IFPCUserAgents **pVal);
	
	[propget, id(10), helpstring("Gets an FPCHTTPHeaders collection that contains the list of HTTP headers for which a compressed response will not be returned when any of them is present in the request")]
    HRESULT UnsupportedHeaders([out, retval] IFPCHTTPHeaders **pVal);
	
};
	
[
object,
uuid(997f60e3-f1e3-4da1-b3ee-525d767584e1),
dual,
nonextensible,
helpstring("Defines HTTP compression configuration settings"),
pointer_default(unique)
]
interface IFPCHTTPCompressionConfiguration2 : IFPCHTTPCompressionConfiguration
{
	[propget, id(11), helpstring("Gets or sets a Boolean value that indicates whether HTTP compression is allowed for responses with no Content-Length")]
    HRESULT AllowCompressionWithoutContentLength([out, retval] VARIANT_BOOL *pVal);
    [propput, id(11), helpstring("Gets or sets a Boolean value that indicates whether HTTP compression is allowed for responses with no Content-Length")]
    HRESULT AllowCompressionWithoutContentLength([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(CADD3935-9EDE-432A-9320-D82531702BAC),
dual,
nonextensible,
helpstring("A tunnel port range"),
pointer_default(unique)
]
interface IFPCTunnelPortRange : IDispatch
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the tunnel port range")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the tunnel port range")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the low end of the port range")]
    HRESULT TunnelLowPort([out, retval] long *pVal);
    [propput, id(1), helpstring("Gets or sets the low end of the port range")]
    HRESULT TunnelLowPort([in] long newVal);
	
	[propget, id(2), helpstring("Gets or sets the high end of the port range")]
    HRESULT TunnelHighPort([out, retval] long *pVal);
    [propput, id(2), helpstring("Gets or sets the high end of the port range")]
    HRESULT TunnelHighPort([in] long newVal);
	
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
};
	
[
object,
uuid(EC8D16A5-FB1B-464A-A72E-50D1CBA4FA0E),
dual,
nonextensible,
helpstring("Collection of content type sets"),
pointer_default(unique)
]
interface IFPCContentTypeSets : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCContentTypeSet** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Adds a content type set to the collection")]
          HRESULT Add( BSTR Name,
              [out,retval] IFPCContentTypeSet** ppNewSet);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a content type set from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
};
	
[
object,
uuid(1B20808A-74C4-465E-9899-BE7D14883BB8),
dual,
helpstring("A content type set"),
pointer_default(unique)
]
interface IFPCContentTypeSet : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the content type set")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the content type set")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the description of the content type set")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the description of the content type set")]
    HRESULT Description([in] BSTR newVal);
	
	[id(2), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] BSTR* pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Adds a new file type to the object")]
          HRESULT Add( BSTR Name);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a file type from the object")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(4), helpstring("Removes all of the content types from the object")]
          HRESULT RemoveAll();
        
    
};
	
[
object,
uuid(B05553C2-0322-4C17-833D-11168991C62B),
dual,
nonextensible,
helpstring("Collection of content type sets"),
pointer_default(unique)
]
interface IFPCContentTypeSet2 : IFPCContentTypeSet
{
	[propget, id(5), helpstring("Gets whether the content type set is a preinstalled that cannot be deleted")]
    HRESULT Predefined([out, retval] VARIANT_BOOL *pVal);
	
};
	
[
object,
uuid(738C027F-811A-46a8-8077-B3C3C4163238),
dual,
nonextensible,
helpstring("Collection of connectivity check results"),
pointer_default(unique)
]
interface IFPCConnectivityResults : IDispatch
{
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT Index,
              [out,retval] IFPCConnectivityResult** pItem);
        
    
};
	
[
object,
uuid(0E637123-28F2-4dc7-94AA-72F2B3CDA2AB),
dual,
helpstring("A connectivity check result"),
pointer_default(unique)
]
interface IFPCConnectivityResult : IDispatch
{
	[propget, id(1), helpstring("Gets the address of the checked service")]
    HRESULT ServerAddress([out, retval] BSTR *pVal);
	
	[propget, id(2), helpstring("Gets the type of the request to send to the checked service")]
    HRESULT RequestType([out, retval] FpcRequestType *pVal);
	
	[propget, id(3), helpstring("Gets the port of the checked service (0 if default or irrelevant)")]
    HRESULT TCPPort([out, retval] long *pVal);
	
	[propget, id(4), helpstring("Gets the first check time for this connectivity item that resulted in the current error code")]
    HRESULT DateCheckedFirst([out, retval] DATE *pVal);
	
	[propget, id(5), helpstring("Gets the last check time for this connectivity item")]
    HRESULT DateCheckedLast([out, retval] DATE *pVal);
	
	[propget, id(6), helpstring("Gets the last result in milliseconds")]
    HRESULT Result([out, retval] long *pVal);
	
	[propget, id(7), helpstring("Gets the last error code")]
    HRESULT ErrorCode([out, retval] FpcConnectivityErrorCode *pVal);
	
};
	
[
object,
uuid(3C0DA61A-45BD-4b09-9269-C76604EFFF80),
dual,
nonextensible,
helpstring("A connectivity check result"),
pointer_default(unique)
]
interface IFPCConnectivityResult2 : IFPCConnectivityResult
{
	[propget, id(8), helpstring("Gets the Host header used by the connectivity check")]
    HRESULT HostHeader([out, retval] BSTR *pVal);
	
};
	
[
object,
uuid(9D70A210-DBE1-4BDC-B135-E359776ABD5F),
dual,
nonextensible,
helpstring("Collection of signaled alerts"),
pointer_default(unique)
]
interface IFPCSignaledAlerts : IDispatch
{
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT IndexOrEventGuid,
              [optional] VARIANT AdditionalKey,
              [optional] VARIANT Server,
              [out,retval] IFPCSignaledAlert** pItem);
        
    
};
	
[
object,
uuid(F1367F80-DD77-4C98-AB5C-952E570BDB69),
dual,
nonextensible,
helpstring("A signaled alert"),
pointer_default(unique)
]
interface IFPCSignaledAlert : IDispatch
{
	[propget, id(1), helpstring("Gets the event that triggered the alert")]
    HRESULT EventGUID([out, retval] BSTR *pVal);
	
	[propget, id(2), helpstring("Gets the additional key of the alert")]
    HRESULT AdditionalKey([out, retval] long *pVal);
	
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[id(4), helpstring("Resets the alert")]
          HRESULT Reset();
        
    
	[propget, id(5), helpstring("Gets the name of the alert")]
    HRESULT Name([out, retval] BSTR *pVal);
	
	[propget, id(9), helpstring("Gets the severity of the alert")]
    HRESULT Severity([out, retval] FpcAlertSeverity *pVal);
	
	[propget, id(10), helpstring("Gets the server name of the alert")]
    HRESULT Server([out, retval] BSTR *pVal);
	
	[id(11), helpstring("Acknowledges all the alert instances")]
          HRESULT Acknowledge();
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( long index,
              [out,retval] IFPCSignaledAlertInstance** pItem);
        
    
};
	
[
object,
uuid(9A2520BB-4C0A-4C9B-AC5D-EA949EE07A9F),
dual,
nonextensible,
helpstring("A signaled alert instance"),
pointer_default(unique)
]
interface IFPCSignaledAlertInstance : IDispatch
{
	[propget, id(1), helpstring("Gets the description of the alert instance")]
    HRESULT Description([out, retval] BSTR *pVal);
	
	[propget, id(2), helpstring("Gets a possible resolution of the issue that caused the alert instance")]
    HRESULT Resolution([out, retval] BSTR *pVal);
	
	[propget, id(3), helpstring("Gets a DATE value that specifies the date and Greenwich Mean Time from which this instance was signaled")]
    HRESULT TimeStamp([out, retval] DATE *pVal);
	
	[propget, id(4), helpstring("Gets the status of the alert instance (acknowledged or new)")]
    HRESULT Acknowledged([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(5), helpstring("Gets the number of instances that occured at this timestamp")]
    HRESULT Count([out, retval] LONG *pVal);
	
	[id(6), helpstring("Resets the alert instance")]
          HRESULT Reset();
        
    
	[id(7), helpstring("Acknowledges the alert instance")]
          HRESULT Acknowledge();
        
    
	[id(8), helpstring("Renew DHCP addresses"), hidden]
          HRESULT RenewDhcpAddresses();
        
    
};
	
[
object,
uuid(E5EA006F-3548-40D5-B7CD-4461488D1C51),
dual,
nonextensible,
helpstring("The status of a single run of a content download job on a single server"),
pointer_default(unique)
]
interface IFPCScheduledContentDownloadJobStatus : IDispatch
{
	[propget, id(1), helpstring("Gets the time at which the run of the content download job started")]
    HRESULT StartTime([out, retval] DATE *pVal);
	
	[propget, id(2), helpstring("Gets the number of objects queued for download")]
    HRESULT NumberOfObjectsQueued([out, retval] long *pVal);
	
	[propget, id(3), helpstring("Gets the number of objects that have been downloaded")]
    HRESULT NumberOfObjectsFetched([out, retval] long *pVal);
	
	[propget, id(4), helpstring("Gets the current location of the download in the hierarchy of links")]
    HRESULT CurrentDepth([out, retval] long *pVal);
	
	[propget, id(5), helpstring("Gets the name of the server on which the job is running")]
    HRESULT ServerName([out, retval] BSTR *pVal);
	
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[id(6), helpstring("Aborts the job")]
          HRESULT Abort();
        
    
};
	
[
object,
uuid(AF86D501-7A99-4A0F-8969-15F56FFAEF51),
dual,
nonextensible,
helpstring("Collection containing the status of individual runs of a single content download job"),
pointer_default(unique)
]
interface IFPCScheduledContentDownloadJobStatuses : IDispatch
{
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT NameOrIndex,
              [out,retval] IFPCScheduledContentDownloadJobStatus** pItem);
        
    
};
	
[
object,
uuid(D1E3C584-E0C5-4016-AF3D-9B8786EA5887),
dual,
nonextensible,
helpstring("Collection of client settings sections"),
pointer_default(unique)
]
interface IFPCClientConfigSettings : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCClientSettingsSection** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(2), helpstring("Adds a client settings section to the collection")]
          HRESULT AddSection( BSTR bstrSection,
              [out,retval] IFPCClientSettingsSection** ppNewSection);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a client settings section from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(4), helpstring("Gets or sets whether Forefront TMG uses encrypted control channel")]
    HRESULT EnableControlChannelEncryption([out, retval] VARIANT_BOOL *pVal);
    [propput, id(4), helpstring("Gets or sets whether Forefront TMG uses encrypted control channel")]
    HRESULT EnableControlChannelEncryption([in] VARIANT_BOOL newVal);
	
	[propget, id(5), helpstring("Gets or sets whether Forefront TMG supports old Forefront TMG Clients")]
    HRESULT SupportOldFirewallClients([out, retval] VARIANT_BOOL *pVal);
    [propput, id(5), helpstring("Gets or sets whether Forefront TMG supports old Forefront TMG Clients")]
    HRESULT SupportOldFirewallClients([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(33E85CEE-1F29-40DD-8098-F28F22403862),
dual,
nonextensible,
helpstring("Sections of client settings"),
pointer_default(unique)
]
interface IFPCClientSettingsSection : IDispatch
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the settings section")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the settings section")]
    HRESULT Name([in] BSTR newVal);
	
	[id(2), helpstring("Gets or sets the value associated with the given name"), propget]
          HRESULT Value([in] BSTR Name,
              [out,retval] BSTR* pVal);
        
    
	[id(2), helpstring("Gets or sets the value associated with the given name"), propput]
          HRESULT Value([in] BSTR Name,
              [in] BSTR newVal);
        
    
	[propget, id(3), helpstring("Gets the names of all of the client settings")]
    HRESULT AllNames([out, retval] VARIANT *pVal);
	
	[id(4), helpstring("Removes a client setting value from the list of client settings")]
          HRESULT RemoveValue([in] BSTR Name);
        
    
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
};
	
[
object,
uuid(605A0473-B1A8-49C1-B49E-E8FCFFCD599C),
dual,
nonextensible,
helpstring("Collection of networks"),
pointer_default(unique)
]
interface IFPCNetworks : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCNetwork** pItem);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Adds a network to the collection")]
          HRESULT Add( BSTR Name,
              [out,retval] IFPCNetwork** ppNewNetwork);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a network from the collection")]
          HRESULT Remove( VARIANT v);
        
    
};
	
[
object,
uuid(35FC4FB3-488D-4478-A1AE-93A33AF63A3F),
dual,
helpstring("A network"),
pointer_default(unique)
]
interface IFPCNetwork : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets the description of the network")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the description of the network")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets the type of network")]
    HRESULT NetworkType([out, retval] FpcNetworkTypes *pVal);
	
	[propget, id(3), helpstring("Gets the IP range set for the network")]
    HRESULT IpRangeSet([out, retval] IFPCIpRangeSet **pVal);
	
	[propget, id(4), helpstring("Gets the collection containing the Local Domain Table configuration")]
    HRESULT LDT([out, retval] IFPCLDT **pVal);
	
	[propget, id(5), helpstring("Gets or sets the type of the network connection")]
    HRESULT NetworkConnectionType([out, retval] FpcNetworkConnectionType *pVal);
    [propput, id(5), helpstring("Gets or sets the type of the network connection")]
    HRESULT NetworkConnectionType([in] FpcNetworkConnectionType newVal);
	
	[propget, id(6), helpstring("Gets the client configuration")]
    HRESULT ClientConfig([out, retval] IFPCClientConfig **pVal);
	
	[propget, id(7), helpstring("Gets whether the network is predefined by Firwall Server, rather than administrator-defined")]
    HRESULT Predefined([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(8), helpstring("Gets or sets whether Forefront TMG Clients are enabled for the network")]
    HRESULT EnableFirewallClients([out, retval] VARIANT_BOOL *pVal);
    [propput, id(8), helpstring("Gets or sets whether Forefront TMG Clients are enabled for the network")]
    HRESULT EnableFirewallClients([in] VARIANT_BOOL newVal);
	
	[propget, id(9), helpstring("Gets or sets whether Web proxy clients are enabled for the network")]
    HRESULT EnableWebProxyClients([out, retval] VARIANT_BOOL *pVal);
    [propput, id(9), helpstring("Gets or sets whether Web proxy clients are enabled for the network")]
    HRESULT EnableWebProxyClients([in] VARIANT_BOOL newVal);
	
	[propget, id(10), helpstring("Gets a reference to the properties of Web listener to outgoing Web requests")]
    HRESULT WebListenerProperties([out, retval] IFPCWebListenerProperties **pVal);
	
	[propget, id(11), helpstring("Gets or sets whether the Web proxy binds to an additional port in order to return the routing script")]
    HRESULT EnableAutoDiscoveryPort([out, retval] VARIANT_BOOL *pVal);
    [propput, id(11), helpstring("Gets or sets whether the Web proxy binds to an additional port in order to return the routing script")]
    HRESULT EnableAutoDiscoveryPort([in] VARIANT_BOOL newVal);
	
	[propget, id(12), helpstring("Gets or sets the port to bind to if the EnableAutoAddinonalPort property is True")]
    HRESULT AutoDiscoveryPort([out, retval] long *pVal);
    [propput, id(12), helpstring("Gets or sets the port to bind to if the EnableAutoAddinonalPort property is True")]
    HRESULT AutoDiscoveryPort([in] long newVal);
	
	[propget, id(13), helpstring("Gets a reference to the site-to-site VPN connection configuration")]
    HRESULT VpnConfiguration([out, retval] IFPCVpnNetworkConfiguration **pVal);
	
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the network")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the network")]
    HRESULT Name([in] BSTR newVal);
	
};
	
[
object,
uuid(095fb5b7-e4a1-4bc4-b9ad-2f33addd6e14),
dual,
helpstring("A network"),
pointer_default(unique)
]
interface IFPCEENetwork : IFPCNetwork
{
	[propget, id(14), helpstring("Gets a reference to the collection of references to the enterprise networks that are part of the set")]
    HRESULT EnterpriseNetworks([out, retval] IFPCRefs **pVal);
	
	[propget, id(15), helpstring("Gets the NLB Cluster for the network")]
    HRESULT NLBCluster([out, retval] IFPCEENLBCluster **pVal);
	
	[propget, id(16), helpstring("Gets an FPCReadOnlyIpRangeSet collection that contains the complete set of IP address ranges defining all the enterprise networks included in the network")]
    HRESULT CalculatedEEIpRangeSet([out, retval] IFPCEEReadOnlyIpRangeSet **pVal);
	
	[propget, id(17), helpstring("Gets or sets the Spoof Detection mode"), hidden]
    HRESULT SpoofDetectionMode([out, retval] FpcSpoofDetectionMode *pVal);
    [propput, id(17), helpstring("Gets or sets the Spoof Detection mode"), hidden]
    HRESULT SpoofDetectionMode([in] FpcSpoofDetectionMode newVal);
	
};
	
[
object,
uuid(74B508FA-55C8-4A83-8A73-A7EF21B09FC5),
dual,
nonextensible,
helpstring("A network"),
pointer_default(unique)
]
interface IFPCNetwork2 : IFPCEENetwork
{
	[propget, id(18), helpstring("Gets the Internet service provider (ISP) redundancy configuration"), hidden]
    HRESULT ISPRedundancyConfig([out, retval] IFPCISPRedundancyConfig **pVal);
	
	[propget, id(19), helpstring("Gets the IPv6 range set for the network")]
    HRESULT Ipv6RangeSet([out, retval] IFPCIpRangeSet **pVal);
	
};
	
[
object,
uuid(447c2551-4255-4f9b-9a0e-f35dbb18fe05),
dual,
nonextensible,
helpstring("Collection of enterprise networks"),
pointer_default(unique)
]
interface IFPCEEEnterpriseNetworks : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCEEEnterpriseNetwork** pItem);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Adds an enterprise network to the collection")]
          HRESULT Add( BSTR Name,
              [out,retval] IFPCEEEnterpriseNetwork** ppNewEnterpriseNetwork);
        
    
	[id(DISPID_REMOVE), helpstring("Removes an enterprise network from the collection")]
          HRESULT Remove( VARIANT v);
        
    
};
	
[
object,
uuid(36a69fb1-6527-4ea3-a5ea-5abcce5e6c44),
dual,
helpstring("A network"),
pointer_default(unique)
]
interface IFPCEEEnterpriseNetwork : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the network")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the network")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the description of the network")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the description of the network")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets the IP range set for the network")]
    HRESULT IpRangeSet([out, retval] IFPCIpRangeSet **pVal);
	
	[propget, id(3), helpstring("Gets whether the network is predefined by Firwall Server, rather than administrator-defined")]
    HRESULT Predefined([out, retval] VARIANT_BOOL *pVal);
	
};
	
[
object,
uuid(3ada3a9f-0225-46fb-9d6f-be790a9ad59a),
dual,
nonextensible,
helpstring("A network"),
pointer_default(unique)
]
interface IFPCEEEnterpriseNetwork2 : IFPCEEEnterpriseNetwork
{
	[propget, id(4), helpstring("Gets the IPv6 range set for the network")]
    HRESULT Ipv6RangeSet([out, retval] IFPCIpRangeSet **pVal);
	
};
	
[
object,
uuid(92B1CCA7-6349-4015-9F96-E5764B67BF3D),
dual,
nonextensible,
helpstring("Collection of network templates"),
pointer_default(unique)
]
interface IFPCNetworkTemplates : IDispatch
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCNetworkTemplate** pItem);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[id(DISPID_ADD), helpstring("Adds a network template to the collection")]
          HRESULT Add( BSTR Name,
               BSTR XMLName,
               BSTR SmallBMPName,
               BSTR MediumBMPName,
               BSTR LargeBMPName,
              [out,retval] IFPCNetworkTemplate** ppNewNetworkTemplate);
        
    
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a network template from the collection")]
          HRESULT Remove( VARIANT v);
        
    
};
	
[
object,
uuid(63A06624-1880-478E-A474-A40D4F0C7772),
dual,
nonextensible,
helpstring("A network template"),
pointer_default(unique)
]
interface IFPCNetworkTemplate : IDispatch
{
	[propget, id(1), helpstring("Gets or sets the description of the network template")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the description of the network template")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets the XML content of the network template")]
    HRESULT XMLName([out, retval] BSTR *pVal);
	
	[propget, id(3), helpstring("Gets the small BMP content of the network template")]
    HRESULT SmallBMPName([out, retval] BSTR *pVal);
	
	[propget, id(4), helpstring("Gets the medium BMP content of the network template")]
    HRESULT MediumBMPName([out, retval] BSTR *pVal);
	
	[propget, id(5), helpstring("Gets the large BMP content of the network template")]
    HRESULT LargeBMPName([out, retval] BSTR *pVal);
	
	[propget, id(6), helpstring("Gets the networks of the network template")]
    HRESULT NetworksInTemplate([out, retval] IFPCNetworksInTemplate **pVal);
	
	[propget, id(7), helpstring("Gets the policies of the network template")]
    HRESULT PoliciesInTemplate([out, retval] IFPCPoliciesInTemplate **pVal);
	
	[propget, id(8), helpstring("Gets the ordinal position of the network template in the collection of network templates")]
    HRESULT Order([out, retval] long *pVal);
	
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the network template")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the network template")]
    HRESULT Name([in] BSTR newVal);
	
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[propget, id(DISPID_PERSISTENTNAME), helpstring("Gets the persistent name of the object. The persistent name of an object is a name that is unique for the object at the respective level of the COM object hierarchy")]
    HRESULT PersistentName([out, retval] BSTR *pVal);
	
};
	
[
object,
uuid(30EC5140-EEBA-49E3-A251-1C2655497034),
dual,
nonextensible,
helpstring("Collection of networks in template"),
pointer_default(unique)
]
interface IFPCNetworksInTemplate : IDispatch
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCNetworkInTemplate** pItem);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[propget, id(1), helpstring("Gets a Boolean value that indicates whether the networks in the template are the same as those in the current configuration.")]
    HRESULT NetworksAreIdentical([out, retval] VARIANT_BOOL *pVal);
	
};
	
[
object,
uuid(EA9EF115-D213-4A35-9618-0C751873C98B),
dual,
nonextensible,
helpstring("A network in template"),
pointer_default(unique)
]
interface IFPCNetworkInTemplate : IDispatch
{
	[propget, id(1), helpstring("Gets the description of the network in template")]
    HRESULT Description([out, retval] BSTR *pVal);
	
	[propget, id(DISPID_VALUE), helpstring("Gets the name of the network in template")]
    HRESULT Name([out, retval] BSTR *pVal);
	
	[propget, id(DISPID_PERSISTENTNAME), helpstring("Gets the persistent name of the object. The persistent name of an object is a name that is unique for the object at the respective level of the COM object hierarchy")]
    HRESULT PersistentName([out, retval] BSTR *pVal);
	
};
	
[
object,
uuid(63B19C74-2D90-40B6-A432-C61C03DE7826),
dual,
nonextensible,
helpstring("Collection of policies in template"),
pointer_default(unique)
]
interface IFPCPoliciesInTemplate : IDispatch
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCPolicyInTemplate** pItem);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

};
	
[
object,
uuid(4FE62077-EC84-40CF-84DB-14664CAB655F),
dual,
nonextensible,
helpstring("A Policy in template"),
pointer_default(unique)
]
interface IFPCPolicyInTemplate : IDispatch
{
	[propget, id(1), helpstring("Gets the description of the Policy in template")]
    HRESULT Description([out, retval] BSTR *pVal);
	
	[propget, id(DISPID_VALUE), helpstring("Gets the name of the Policy in template")]
    HRESULT Name([out, retval] BSTR *pVal);
	
	[propget, id(DISPID_PERSISTENTNAME), helpstring("Gets the persistent name of the object. The persistent name of an object is a name that is unique for the object at the respective level of the COM object hierarchy")]
    HRESULT PersistentName([out, retval] BSTR *pVal);
	
};
	
[
object,
uuid(BE5A17C0-EC05-4C81-A29F-02C303526E04),
dual,
nonextensible,
helpstring("Collection of Network sets"),
pointer_default(unique)
]
interface IFPCNetworkSets : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item([in] VARIANT v,
              [out,retval] IFPCNetworkSet** pItem);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Adds a network set to the collection")]
          HRESULT Add([in] BSTR Name,
              [in,defaultvalue(fpcSelectedNetworks)] FpcNetworkSetType NetworkSetType,
              [out,retval] IFPCNetworkSet** ppNewNetworkSet);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a network set from the collection")]
          HRESULT Remove( VARIANT v);
        
    
};
	
[
object,
uuid(D7FFA701-EE5F-41D5-818F-1EEC6B080FE2),
dual,
helpstring("A network set"),
pointer_default(unique)
]
interface IFPCNetworkSet : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets the description of the network set")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the description of the network set")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets a reference to the collection of references to the networks that are part of the set")]
    HRESULT Networks([out, retval] IFPCRefs **pVal);
	
	[propget, id(3), helpstring("Gets the type of the network set")]
    HRESULT NetworkSetType([out, retval] FpcNetworkSetType *pVal);
	
	[propget, id(4), helpstring("Gets whether the network is predefined by Firwall Server, rather than administrator-defined")]
    HRESULT Predefined([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the network set")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the network set")]
    HRESULT Name([in] BSTR newVal);
	
};
	
[
object,
uuid(d6cee227-7b78-495d-a10e-a766c2869924),
dual,
nonextensible,
helpstring("A network set"),
pointer_default(unique)
]
interface IFPCEENetworkSet : IFPCNetworkSet
{
	[propget, id(5), helpstring("Gets a reference to the collection of references to the enterprise networks that are part of the set")]
    HRESULT EnterpriseNetworks([out, retval] IFPCRefs **pVal);
	
};
	
[
object,
uuid(5FD4D889-A534-48F7-ACD0-0C50FB64E11B),
dual,
helpstring("A network rule"),
pointer_default(unique)
]
interface IFPCNetworkRule : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the rule")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the rule")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the description of the rule")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the description of the rule")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets whether the rule is enabled")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(2), helpstring("Gets or sets whether the rule is enabled")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(3), helpstring("Gets the rule's place in the order of execution ")]
    HRESULT Order([out, retval] long *pVal);
	
	[propget, id(4), helpstring("Gets or sets the routing type")]
    HRESULT RoutingType([out, retval] FpcNetworkRoutingTypes *pVal);
    [propput, id(4), helpstring("Gets or sets the routing type")]
    HRESULT RoutingType([in] FpcNetworkRoutingTypes newVal);
	
	[propget, id(5), helpstring("Gets a reference to the source selection IPs to which the rule applies")]
    HRESULT SourceSelectionIPs([out, retval] IFPCSelectionIPs **pVal);
	
	[propget, id(6), helpstring("Gets a reference to the destination selection IPs to which the rule applies")]
    HRESULT DestinationSelectionIPs([out, retval] IFPCSelectionIPs **pVal);
	
	[propget, id(7), helpstring("Gets whether the network rule is a preinstalled rule that cannot be deleted, and whose place in the rule order cannot be changed")]
    HRESULT Predefined([out, retval] VARIANT_BOOL *pVal);
	
};
	
[
object,
uuid(6698DEEE-8FF5-4334-9B80-3BD007D6BDD4),
dual,
nonextensible,
helpstring("A network rule"),
pointer_default(unique)
]
interface IFPCNetworkRule2 : IFPCNetworkRule
{
	[propget, id(8), helpstring("Gets an FPCIPAddresses collection that contains the hiding addresses specified in the rule"), hidden]
    HRESULT HidingAddresses([out, retval] IFPCIPAddresses **pVal);
	
	[propget, id(9), helpstring("Gets an FPCIPAddresses collection that contains NAT-PT prefixes specified in the rule"), hidden]
    HRESULT NatPtPrefixes([out, retval] IFPCIPAddresses **pVal);
	
};
	
[
object,
uuid(9E786E67-AA0C-4D21-9ADF-D6A27FAAB90F),
dual,
nonextensible,
helpstring("A read-only IP range entry"),
pointer_default(unique)
]
interface IFPCReadOnlyIpRangeEntry : IDispatch
{
	[propget, id(1), helpstring("Gets the lower bound of the IP range")]
    HRESULT IP_From([out, retval] BSTR *pVal);
	
	[propget, id(2), helpstring("Gets the upper bound of the IP range")]
    HRESULT IP_To([out, retval] BSTR *pVal);
	
};
	
[
object,
uuid(5B5583F1-C0A5-4569-889B-B8F544C9DDE1),
dual,
helpstring("Collection of read-only IP range entries"),
pointer_default(unique)
]
interface IFPCReadOnlyIpRangeSet : IDispatch
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item([in] VARIANT IndexOrIP_From,
              [in,defaultvalue(NULL)] BSTR IP_To,
              [out,retval] IFPCReadOnlyIpRangeEntry** pItem);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[id(1), helpstring("Determines if an IP address is included in the collection")]
          HRESULT IsIpInSet([in] BSTR IpStr,
              [out,retval] VARIANT_BOOL* pIsIpInSet);
        
    
	[id(2), helpstring("Determines if an IP range intersects with IP addresses that are in use")]
          HRESULT IsRangeIntersect( BSTR IpFrom,
               BSTR IpTo,
              [out,retval] VARIANT_BOOL* pIsRangeIntersect);
        
    
};
	
[
object,
uuid(71065365-5087-421f-B4EC-84579C0F8E4C),
dual,
nonextensible,
helpstring("Collection of read-only IP range entries"),
pointer_default(unique)
]
interface IFPCEEReadOnlyIpRangeSet : IFPCReadOnlyIpRangeSet
{
	[id(3), helpstring("Determines if an IP range is contained within the IP addresses that are in use")]
          HRESULT IsRangeContained( BSTR IpFrom,
               BSTR IpTo,
              [out,retval] VARIANT_BOOL* pIsRangeContained);
        
    
};
	
[
object,
uuid(B8849553-6EEF-4B66-8A7F-392B7553BBDE),
dual,
nonextensible,
helpstring("Collection of network rules"),
pointer_default(unique)
]
interface IFPCNetworkRules : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCNetworkRule** pItem);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Adds a network rule to the collection")]
          HRESULT Add( BSTR Name,
              [out,retval] IFPCNetworkRule** ppNewNetworkRule);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a network rule from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[id(5), helpstring("Moves the specified rule up the ladder of execution")]
          HRESULT MoveUp( long index);
        
    
	[id(6), helpstring("Moves the specified rule down the ladder of execution")]
          HRESULT MoveDown( long index);
        
    
};
	
[
object,
uuid(11AC59EA-AD42-464B-975E-E2D8E4A4DBB0),
dual,
helpstring("VPN tunnel settings"),
pointer_default(unique)
]
interface IFPCVpnConfiguration : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets a Boolean value that indicates whether access for remote VPN clients is enabled.")]
    HRESULT EnableVpnClients([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets a Boolean value that indicates whether access for remote VPN clients is enabled.")]
    HRESULT EnableVpnClients([in] VARIANT_BOOL newVal);
	
	[propget, id(2), helpstring("Gets or sets the maximum number of concurrent VPN clients")]
    HRESULT MaximumVpnClients([out, retval] long *pVal);
    [propput, id(2), helpstring("Gets or sets the maximum number of concurrent VPN clients")]
    HRESULT MaximumVpnClients([in] long newVal);
	
	[propget, id(3), helpstring("Gets an IP range set that represents the static address pool for the VPN")]
    HRESULT StaticAddressPool([out, retval] IFPCIpRangeSet **pVal);
	
	[propget, id(4), helpstring("Gets or sets a Boolean value that indicates whether DHCP is used for address assignment")]
    HRESULT UseDHCPForAddressAssignment([out, retval] VARIANT_BOOL *pVal);
    [propput, id(4), helpstring("Gets or sets a Boolean value that indicates whether DHCP is used for address assignment")]
    HRESULT UseDHCPForAddressAssignment([in] VARIANT_BOOL newVal);
	
	[propget, id(5), helpstring("Gets or sets a Boolean value that indicates whether DHCP is used for DNS servers")]
    HRESULT UseDHCPForDNS([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(6), helpstring("Gets or sets a Boolean value that indicates whether DHCP is used for WINS servers")]
    HRESULT UseDHCPForWINS([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(7), helpstring("Gets the name of the primary Domain Name System (DNS) server.")]
    HRESULT PrimaryDNSServer([out, retval] BSTR *pVal);
	
	[propget, id(8), helpstring("Gets the name of the backup Domain Name System (DNS) server.")]
    HRESULT BackupDNSServer([out, retval] BSTR *pVal);
	
	[propget, id(9), helpstring("Gets the name of the primary Windows Internet Name System (WINS) server.")]
    HRESULT PrimaryWINSServer([out, retval] BSTR *pVal);
	
	[propget, id(10), helpstring("Gets the name of the backup Windows Internet Name System (WINS) server.")]
    HRESULT BackupWINSServer([out, retval] BSTR *pVal);
	
	[propget, id(11), helpstring("Gets the Point-to-Point Protocol (PPP) settings for the VPN")]
    HRESULT PPPSettings([out, retval] IFPCVpnPPPSettings **pVal);
	
	[propget, id(12), helpstring("Gets an FPCVpnQuarantineSettings object that represents the quarantine settings for the VPN gateway.")]
    HRESULT QuarantineSettings([out, retval] IFPCVpnQuarantineSettings **pVal);
	
	[propget, id(13), helpstring("Gets or sets a Boolean value that indicates whether RADIUS authentication is enabled for the VPN gateway.")]
    HRESULT EnableRADIUSAuthentication([out, retval] VARIANT_BOOL *pVal);
    [propput, id(13), helpstring("Gets or sets a Boolean value that indicates whether RADIUS authentication is enabled for the VPN gateway.")]
    HRESULT EnableRADIUSAuthentication([in] VARIANT_BOOL newVal);
	
	[propget, id(14), helpstring("Gets or sets a Boolean value that indicates whether RADIUS accounting is enabled for the VPN gateway.")]
    HRESULT EnableRADIUSAccounting([out, retval] VARIANT_BOOL *pVal);
    [propput, id(14), helpstring("Gets or sets a Boolean value that indicates whether RADIUS accounting is enabled for the VPN gateway.")]
    HRESULT EnableRADIUSAccounting([in] VARIANT_BOOL newVal);
	
	[propget, id(15), helpstring("Gets an FPCUserMapping object that represents the RADIUS user mapping settings for the VPN gateway.")]
    HRESULT RADIUSUserMapping([out, retval] IFPCUserMapping **pVal);
	
	[propget, id(16), helpstring("Gets or sets a Boolean value that indicates whether IPSec policy for L2TP can be customized")]
    HRESULT AllowCustomIPSecPolicyForL2TP([out, retval] VARIANT_BOOL *pVal);
    [propput, id(16), helpstring("Gets or sets a Boolean value that indicates whether IPSec policy for L2TP can be customized")]
    HRESULT AllowCustomIPSecPolicyForL2TP([in] VARIANT_BOOL newVal);
	
	[propget, id(17), helpstring("Gets or sets a Boolean value that indicates whether PPTP is enabled")]
    HRESULT EnablePPTP([out, retval] VARIANT_BOOL *pVal);
    [propput, id(17), helpstring("Gets or sets a Boolean value that indicates whether PPTP is enabled")]
    HRESULT EnablePPTP([in] VARIANT_BOOL newVal);
	
	[propget, id(18), helpstring("Gets or sets a Boolean value that indicates whether L2TP is enabled")]
    HRESULT EnableL2TP([out, retval] VARIANT_BOOL *pVal);
    [propput, id(18), helpstring("Gets or sets a Boolean value that indicates whether L2TP is enabled")]
    HRESULT EnableL2TP([in] VARIANT_BOOL newVal);
	
	[propget, id(19), helpstring("Gets the preshared IP Security (IPSec) key")]
    HRESULT PreSharedIPSecKey([out, retval] BSTR *pVal);
    [propput, id(19), helpstring("Gets the preshared IP Security (IPSec) key")]
    HRESULT PreSharedIPSecKey([in] BSTR newVal);
	
	[propget, id(20), helpstring("Gets a collection of references to the network sets that are allowed access to VPN protocols")]
    HRESULT NetworkSetsToListenOn([out, retval] IFPCRefs **pVal);
	
	[propget, id(21), helpstring("Gets a collection of references to the networks that are allowed access to VPN protocols")]
    HRESULT NetworksToListenOn([out, retval] IFPCRefs **pVal);
	
	[id(22), helpstring("Sets the primary and backup DNS servers, or specifies that the DNS server name is obtained from a DHCP server.")]
          HRESULT SetDNSConfiguration([in] VARIANT_BOOL ObtainFromDHCP,
              [in,defaultvalue(NULL)] BSTR newPrimaryName,
              [in,defaultvalue(NULL)] BSTR newBackupName);
        
    
	[id(23), helpstring("Sets the primary and backup WINS servers, or specifies that the WINS server name is obtained from a DHCP server.")]
          HRESULT SetWINSConfiguration([in] VARIANT_BOOL ObtainFromDHCP,
              [in,defaultvalue(NULL)] BSTR newPrimaryName,
              [in,defaultvalue(NULL)] BSTR newBackupName);
        
    
	[propget, id(24), helpstring("Gets a reference to the network for obtaining DHCP services")]
    HRESULT NetworkToObtainDHCP([out, retval] IFPCRef **pVal);
	
	[id(25), helpstring("Sets the network name for obtaining DHCP services")]
          HRESULT SetNetworkToObtainDHCP( BSTR NetworkName);
        
    
	[propget, id(26), helpstring("Gets a collection of accounts representing domain groups")]
    HRESULT DomainGroups([out, retval] IFPCAccounts **pVal);
	
	[propget, id(27), helpstring("Gets or sets a Boolean value that indicates whether Windows is enabled for the VPN gateway")]
    HRESULT EnableWindowsAccounting([out, retval] VARIANT_BOOL *pVal);
    [propput, id(27), helpstring("Gets or sets a Boolean value that indicates whether Windows is enabled for the VPN gateway")]
    HRESULT EnableWindowsAccounting([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(2d86ff46-124e-4ca1-9703-d95e0b110095),
dual,
helpstring("VPN tunnel settings"),
pointer_default(unique)
]
interface IFPCEEVpnConfiguration : IFPCVpnConfiguration
{
	[propget, id(28), helpstring("Gets a collection of domain mappings representing the domains which may be replaced")]
    HRESULT DomainMappings([out, retval] IFPCEEDomainMappings **pVal);
	
};
	
[
object,
uuid(1DADB837-BB31-4949-BFCF-D7A79775812A),
dual,
nonextensible,
helpstring("VPN tunnel settings"),
pointer_default(unique)
]
interface IFPCVpnConfiguration2 : IFPCEEVpnConfiguration
{
	[propget, id(29), helpstring("Gets or sets a Boolean value that indicates whether access for remote IPv6 VPN clients is enabled."), hidden]
    HRESULT EnableIPv6VpnClients([out, retval] VARIANT_BOOL *pVal);
    [propput, id(29), helpstring("Gets or sets a Boolean value that indicates whether access for remote IPv6 VPN clients is enabled."), hidden]
    HRESULT EnableIPv6VpnClients([in] VARIANT_BOOL newVal);
	
	[propget, id(30), helpstring("Gets or sets a Boolean value that indicates whether SSTP is enabled")]
    HRESULT EnableSSTP([out, retval] VARIANT_BOOL *pVal);
    [propput, id(30), helpstring("Gets or sets a Boolean value that indicates whether SSTP is enabled")]
    HRESULT EnableSSTP([in] VARIANT_BOOL newVal);
	
	[propget, id(31), helpstring("Gets The Weblistener to be used for SSTP access")]
    HRESULT SSTPListener([out, retval] IFPCRef **pVal);
	
	[id(32), helpstring("Sets the Weblistener to be used for SSTP access")]
          HRESULT SetSSTPListener( BSTR WebListenerName);
        
    
	[propget, id(33), helpstring("Gets or sets a Boolean value that indicates whether SSTP will be intercepted by the Forefront TMG Web listener"), hidden]
    HRESULT InterceptSSTP([out, retval] VARIANT_BOOL *pVal);
    [propput, id(33), helpstring("Gets or sets a Boolean value that indicates whether SSTP will be intercepted by the Forefront TMG Web listener"), hidden]
    HRESULT InterceptSSTP([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(D36E2156-DF5F-4E91-8EA5-B7CB6A2C4FF1),
dual,
nonextensible,
helpstring("VPN quarantine settings"),
pointer_default(unique)
]
interface IFPCVpnQuarantineSettings : IDispatch
{
	[propget, id(1), helpstring("Gets or sets the VPN quarantine mode")]
    HRESULT QuarantineMode([out, retval] FpcVpnQuarantineMode *pVal);
    [propput, id(1), helpstring("Gets or sets the VPN quarantine mode")]
    HRESULT QuarantineMode([in] FpcVpnQuarantineMode newVal);
	
	[propget, id(2), helpstring("Gets or sets the time in seconds that the connection can remain in a restricted state before disconnecting")]
    HRESULT QuarantineTimeout([out, retval] long *pVal);
    [propput, id(2), helpstring("Gets or sets the time in seconds that the connection can remain in a restricted state before disconnecting")]
    HRESULT QuarantineTimeout([in] long newVal);
	
	[propget, id(3), helpstring("Gets or sets whether the VPN quarantine timeout is enabled")]
    HRESULT QuarantineTimeoutEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(3), helpstring("Gets or sets whether the VPN quarantine timeout is enabled")]
    HRESULT QuarantineTimeoutEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(4), helpstring("Gets a reference to the collection of references to the user sets to which the quarantine is not applied")]
    HRESULT UserSetsExcluded([out, retval] IFPCRefs **pVal);
	
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
};
	
[
object,
uuid(E99F3088-C372-4DD1-BEF7-314516E5F1F4),
dual,
nonextensible,
helpstring("VPN PPP settings"),
pointer_default(unique)
]
interface IFPCVpnPPPSettings : IDispatch
{
	[propget, id(1), helpstring("Gets or sets whether Shiva password authentication protocol is enabled")]
    HRESULT EnableShivaPAP([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets whether Shiva password authentication protocol is enabled")]
    HRESULT EnableShivaPAP([in] VARIANT_BOOL newVal);
	
	[propget, id(2), helpstring("Gets or sets whether challenge handshake authentication protocol is enabled")]
    HRESULT EnableCHAP([out, retval] VARIANT_BOOL *pVal);
    [propput, id(2), helpstring("Gets or sets whether challenge handshake authentication protocol is enabled")]
    HRESULT EnableCHAP([in] VARIANT_BOOL newVal);
	
	[propget, id(3), helpstring("Gets or sets whether Microsoft challenge handshake authentication protocol (MS-CHAP) is enabled")]
    HRESULT EnableMSCHAP([out, retval] VARIANT_BOOL *pVal);
    [propput, id(3), helpstring("Gets or sets whether Microsoft challenge handshake authentication protocol (MS-CHAP) is enabled")]
    HRESULT EnableMSCHAP([in] VARIANT_BOOL newVal);
	
	[propget, id(4), helpstring("Gets or sets whether Microsoft challenge handshake authentication protocol version 2 is enabled")]
    HRESULT EnableMSCHAPv2([out, retval] VARIANT_BOOL *pVal);
    [propput, id(4), helpstring("Gets or sets whether Microsoft challenge handshake authentication protocol version 2 is enabled")]
    HRESULT EnableMSCHAPv2([in] VARIANT_BOOL newVal);
	
	[propget, id(5), helpstring("Gets or sets whether password authentication protocol is enabled")]
    HRESULT EnablePAP([out, retval] VARIANT_BOOL *pVal);
    [propput, id(5), helpstring("Gets or sets whether password authentication protocol is enabled")]
    HRESULT EnablePAP([in] VARIANT_BOOL newVal);
	
	[propget, id(6), helpstring("Gets or sets whether extensible authentication protocol is enabled")]
    HRESULT EnableEAP([out, retval] VARIANT_BOOL *pVal);
    [propput, id(6), helpstring("Gets or sets whether extensible authentication protocol is enabled")]
    HRESULT EnableEAP([in] VARIANT_BOOL newVal);
	
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
};
	
[
object,
uuid(4208177F-8BE5-4d32-91C7-B1B26EC69AA7),
dual,
helpstring("VPN site to site Network Configuration"),
pointer_default(unique)
]
interface IFPCVpnNetworkConfiguration : IDispatch
{
	[propget, id(1), helpstring("Gets or sets a Boolean value that indicates whether the site-to-site VPN connection is enabled")]
    HRESULT Enable([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets a Boolean value that indicates whether the site-to-site VPN connection is enabled")]
    HRESULT Enable([in] VARIANT_BOOL newVal);
	
	[propget, id(2), helpstring("Gets the L2TP and PPTP settings for the site-to-site VPN connection")]
    HRESULT L2tpPptpSettings([out, retval] IFPCVpnNetworkL2tpPptpSettings **pVal);
	
	[propget, id(3), helpstring("Gets the IPSec settings for the site-to-site VPN connection")]
    HRESULT IPSecSettings([out, retval] IFPCVpnNetworkIPSecSettings **pVal);
	
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
};
	
[
object,
uuid(8E869344-8CB0-447E-9316-6C270540CF1F),
dual,
nonextensible,
helpstring("VPN site to site Network Configuration"),
pointer_default(unique)
]
interface IFPCEEVpnNetworkConfiguration : IFPCVpnNetworkConfiguration
{
	[propget, id(4), helpstring("Gets a reference to the dedicated IP addresses of the remote VPN servers")]
    HRESULT RemoteServersDedicatedAddresses([out, retval] IFPCIpRangeSet **pVal);
	
	[propget, id(5), helpstring("Gets a reference to the server that assigned to this site-to-site network")]
    HRESULT AssignedServer([out, retval] IFPCRef **pVal);
	
	[id(6), helpstring("Sets the name of the assigned server")]
          HRESULT SetAssignedServer([in] BSTR bstrServerName);
        
    
};
	
[
object,
uuid(D1786554-6A6C-4a40-BE05-E39CEB82B730),
dual,
nonextensible,
helpstring("VPN site to site Network L2TP and PPTP settings"),
pointer_default(unique)
]
interface IFPCVpnNetworkL2tpPptpSettings : IDispatch
{
	[propget, id(1), helpstring("Gets or sets the name or IP address of the remote site")]
    HRESULT RemoteServerAddress([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the name or IP address of the remote site")]
    HRESULT RemoteServerAddress([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets a Boolean value that indicates whether the local site can initiate a connection to the remote site")]
    HRESULT AllowOutgoingConnection([out, retval] VARIANT_BOOL *pVal);
    [propput, id(2), helpstring("Gets or sets a Boolean value that indicates whether the local site can initiate a connection to the remote site")]
    HRESULT AllowOutgoingConnection([in] VARIANT_BOOL newVal);
	
	[propget, id(3), helpstring("Gets the user name, including the domain name, and the password that are presented to the remote site for authentication")]
    HRESULT RemoteCredentials([out, retval] IFPCCredentials **pVal);
	
	[propget, id(4), helpstring("Gets or sets a Boolean value that indicates whether an inactive connection will be closed after the time specified in the IdleDisconnectTime property elapses")]
    HRESULT UseIdleDisconnectTime([out, retval] VARIANT_BOOL *pVal);
    [propput, id(4), helpstring("Gets or sets a Boolean value that indicates whether an inactive connection will be closed after the time specified in the IdleDisconnectTime property elapses")]
    HRESULT UseIdleDisconnectTime([in] VARIANT_BOOL newVal);
	
	[propget, id(5), helpstring("Gets or sets the time, in seconds, after which an inactive connection is closed")]
    HRESULT IdleDisconnectTime([out, retval] long *pVal);
    [propput, id(5), helpstring("Gets or sets the time, in seconds, after which an inactive connection is closed")]
    HRESULT IdleDisconnectTime([in] long newVal);
	
	[propget, id(6), helpstring("Gets or sets which VPN protocol is used")]
    HRESULT Protocol([out, retval] FpcVpnProtocol *pVal);
    [propput, id(6), helpstring("Gets or sets which VPN protocol is used")]
    HRESULT Protocol([in] FpcVpnProtocol newVal);
	
	[propget, id(7), helpstring("Gets or sets a Boolean value that indicates whether a preshared key is to be used for authenticating L2TP connections")]
    HRESULT UsePresharedKey([out, retval] VARIANT_BOOL *pVal);
    [propput, id(7), helpstring("Gets or sets a Boolean value that indicates whether a preshared key is to be used for authenticating L2TP connections")]
    HRESULT UsePresharedKey([in] VARIANT_BOOL newVal);
	
	[propget, id(8), helpstring("Gets or sets the preshared key for L2TP connections")]
    HRESULT PresharedKey([out, retval] BSTR *pVal);
    [propput, id(8), helpstring("Gets or sets the preshared key for L2TP connections")]
    HRESULT PresharedKey([in] BSTR newVal);
	
	[propget, id(9), helpstring("Gets or sets a Boolean value that indicates whether the Microsoft Challenge Handshake Authentication Protocol version 2 (MS-CHAP v2) can be used for outgoing authentication")]
    HRESULT EnableMSCHAPv2([out, retval] VARIANT_BOOL *pVal);
    [propput, id(9), helpstring("Gets or sets a Boolean value that indicates whether the Microsoft Challenge Handshake Authentication Protocol version 2 (MS-CHAP v2) can be used for outgoing authentication")]
    HRESULT EnableMSCHAPv2([in] VARIANT_BOOL newVal);
	
	[propget, id(10), helpstring("Gets or sets a Boolean value that indicates whether the Extensible Authentication Protocol (EAP) can be used for outgoing authentication")]
    HRESULT EnableEAP([out, retval] VARIANT_BOOL *pVal);
    [propput, id(10), helpstring("Gets or sets a Boolean value that indicates whether the Extensible Authentication Protocol (EAP) can be used for outgoing authentication")]
    HRESULT EnableEAP([in] VARIANT_BOOL newVal);
	
	[propget, id(11), helpstring("Gets or sets a Boolean value that indicates whether the Microsoft Challenge Handshake Authentication Protocol version 1 (MS-CHAP) can be used for outgoing authentication")]
    HRESULT EnableMSCHAP([out, retval] VARIANT_BOOL *pVal);
    [propput, id(11), helpstring("Gets or sets a Boolean value that indicates whether the Microsoft Challenge Handshake Authentication Protocol version 1 (MS-CHAP) can be used for outgoing authentication")]
    HRESULT EnableMSCHAP([in] VARIANT_BOOL newVal);
	
	[propget, id(12), helpstring("Gets or sets a Boolean value that indicates whether the Challenge Handshake Authentication Protocol (CHAP) can be used for outgoing authentication")]
    HRESULT EnableCHAP([out, retval] VARIANT_BOOL *pVal);
    [propput, id(12), helpstring("Gets or sets a Boolean value that indicates whether the Challenge Handshake Authentication Protocol (CHAP) can be used for outgoing authentication")]
    HRESULT EnableCHAP([in] VARIANT_BOOL newVal);
	
	[propget, id(13), helpstring("Gets or sets a Boolean value that indicates whether the Shiva Password Authentication Protocol (SPAP) can be used for outgoing authentication")]
    HRESULT EnableShivaPAP([out, retval] VARIANT_BOOL *pVal);
    [propput, id(13), helpstring("Gets or sets a Boolean value that indicates whether the Shiva Password Authentication Protocol (SPAP) can be used for outgoing authentication")]
    HRESULT EnableShivaPAP([in] VARIANT_BOOL newVal);
	
	[propget, id(14), helpstring("Gets or sets a Boolean value that indicates whether the Password Authentication Protocol (PAP) can be used for outgoing authentication")]
    HRESULT EnablePAP([out, retval] VARIANT_BOOL *pVal);
    [propput, id(14), helpstring("Gets or sets a Boolean value that indicates whether the Password Authentication Protocol (PAP) can be used for outgoing authentication")]
    HRESULT EnablePAP([in] VARIANT_BOOL newVal);
	
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
};
	
[
object,
uuid(9B5D4518-89C9-4785-95B3-A488D8587FAA),
dual,
nonextensible,
helpstring("VPN site to site Network IPSec settings"),
pointer_default(unique)
]
interface IFPCVpnNetworkIPSecSettings : IDispatch
{
	[propget, id(1), helpstring("Gets or sets the IP address of the remote VPN tunnel endpoint")]
    HRESULT RemoteServerAddress([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the IP address of the remote VPN tunnel endpoint")]
    HRESULT RemoteServerAddress([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets the IP address of the local VPN tunnel endpoint")]
    HRESULT LocalServerAddress([out, retval] BSTR *pVal);
    [propput, id(2), helpstring("Gets or sets the IP address of the local VPN tunnel endpoint")]
    HRESULT LocalServerAddress([in] BSTR newVal);
	
	[propget, id(3), helpstring("Gets or sets the IPSec authentication method")]
    HRESULT AuthenticationMethod([out, retval] FpcVpnAuthenticationMethod *pVal);
    [propput, id(3), helpstring("Gets or sets the IPSec authentication method")]
    HRESULT AuthenticationMethod([in] FpcVpnAuthenticationMethod newVal);
	
	[propget, id(4), helpstring("Gets or sets the name of the certification authority (CA) for the certificates used for IPSec authentication")]
    HRESULT CertificateAuthority([out, retval] BSTR *pVal);
    [propput, id(4), helpstring("Gets or sets the name of the certification authority (CA) for the certificates used for IPSec authentication")]
    HRESULT CertificateAuthority([in] BSTR newVal);
	
	[propget, id(5), helpstring("Gets or sets the preshared key for IPSec authentication")]
    HRESULT PresharedKey([out, retval] BSTR *pVal);
    [propput, id(5), helpstring("Gets or sets the preshared key for IPSec authentication")]
    HRESULT PresharedKey([in] BSTR newVal);
	
	[propget, id(6), helpstring("Gets or sets the Phase 1 encryption algorithm")]
    HRESULT Phase1Encryption([out, retval] FpcVpnEncryptionAlgorithm *pVal);
    [propput, id(6), helpstring("Gets or sets the Phase 1 encryption algorithm")]
    HRESULT Phase1Encryption([in] FpcVpnEncryptionAlgorithm newVal);
	
	[propget, id(7), helpstring("Gets or sets the Phase 1 integrity algorithm")]
    HRESULT Phase1Integrity([out, retval] FpcVpnIntegrityAlgorithm *pVal);
    [propput, id(7), helpstring("Gets or sets the Phase 1 integrity algorithm")]
    HRESULT Phase1Integrity([in] FpcVpnIntegrityAlgorithm newVal);
	
	[propget, id(8), helpstring("Gets or sets the Phase 1 Diffie-Hellman group")]
    HRESULT Phase1DHGroup([out, retval] FpcVpnDiffieHellmanGroup *pVal);
    [propput, id(8), helpstring("Gets or sets the Phase 1 Diffie-Hellman group")]
    HRESULT Phase1DHGroup([in] FpcVpnDiffieHellmanGroup newVal);
	
	[propget, id(9), helpstring("Gets or sets the Phase 1 rekeying time, in seconds")]
    HRESULT Phase1RekeyingTime([out, retval] long *pVal);
    [propput, id(9), helpstring("Gets or sets the Phase 1 rekeying time, in seconds")]
    HRESULT Phase1RekeyingTime([in] long newVal);
	
	[propget, id(10), helpstring("Gets or sets the Phase 2 encryption algorithm")]
    HRESULT Phase2Encryption([out, retval] FpcVpnEncryptionAlgorithm *pVal);
    [propput, id(10), helpstring("Gets or sets the Phase 2 encryption algorithm")]
    HRESULT Phase2Encryption([in] FpcVpnEncryptionAlgorithm newVal);
	
	[propget, id(11), helpstring("Gets or sets the Phase 2 integrity algorithm")]
    HRESULT Phase2Integrity([out, retval] FpcVpnIntegrityAlgorithm *pVal);
    [propput, id(11), helpstring("Gets or sets the Phase 2 integrity algorithm")]
    HRESULT Phase2Integrity([in] FpcVpnIntegrityAlgorithm newVal);
	
	[propget, id(12), helpstring("Gets or sets a Boolean value that indicates whether Phase 2 time-based rekeying is to be used")]
    HRESULT Phase2UseTimeRekeying([out, retval] VARIANT_BOOL *pVal);
    [propput, id(12), helpstring("Gets or sets a Boolean value that indicates whether Phase 2 time-based rekeying is to be used")]
    HRESULT Phase2UseTimeRekeying([in] VARIANT_BOOL newVal);
	
	[propget, id(13), helpstring("Gets or sets the Phase 2 rekeying time, in seconds")]
    HRESULT Phase2RekeyingTime([out, retval] long *pVal);
    [propput, id(13), helpstring("Gets or sets the Phase 2 rekeying time, in seconds")]
    HRESULT Phase2RekeyingTime([in] long newVal);
	
	[propget, id(14), helpstring("Gets or sets a Boolean value that indicates whether Phase 2 KB rekeying is to be used")]
    HRESULT Phase2UseKBRekeying([out, retval] VARIANT_BOOL *pVal);
    [propput, id(14), helpstring("Gets or sets a Boolean value that indicates whether Phase 2 KB rekeying is to be used")]
    HRESULT Phase2UseKBRekeying([in] VARIANT_BOOL newVal);
	
	[propget, id(15), helpstring("Gets or sets the amount of data transferred before Phase 2 rekeying, in kilobytes")]
    HRESULT Phase2KBRekeying([out, retval] long *pVal);
    [propput, id(15), helpstring("Gets or sets the amount of data transferred before Phase 2 rekeying, in kilobytes")]
    HRESULT Phase2KBRekeying([in] long newVal);
	
	[propget, id(16), helpstring("Gets or sets a Boolean value that indicates whether Perfect Forward Secrecy (PFS) is to be used for Phase 2")]
    HRESULT Phase2UsePFS([out, retval] VARIANT_BOOL *pVal);
    [propput, id(16), helpstring("Gets or sets a Boolean value that indicates whether Perfect Forward Secrecy (PFS) is to be used for Phase 2")]
    HRESULT Phase2UsePFS([in] VARIANT_BOOL newVal);
	
	[propget, id(17), helpstring("Gets or sets the Phase 2 Diffie-Hellman group")]
    HRESULT Phase2DHGroup([out, retval] FpcVpnDiffieHellmanGroup *pVal);
    [propput, id(17), helpstring("Gets or sets the Phase 2 Diffie-Hellman group")]
    HRESULT Phase2DHGroup([in] FpcVpnDiffieHellmanGroup newVal);
	
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
};
	
[
object,
uuid(F47F3850-72C2-49D3-BA83-D72BE7239CF2),
dual,
nonextensible,
helpstring("An IP range entry"),
pointer_default(unique)
]
interface IFPCIpRangeEntry : IDispatch
{
	[propget, id(1), helpstring("Gets the lower bound of the IP range entry")]
    HRESULT IP_From([out, retval] BSTR *pVal);
	
	[propget, id(2), helpstring("Gets the upper bound of the IP range entry")]
    HRESULT IP_To([out, retval] BSTR *pVal);
	
	[id(3), helpstring("Sets the bounds of the IP range entry")]
          HRESULT SetIps( BSTR newFrom,
               BSTR newTo);
        
    
};
	
[
object,
uuid(DE264712-F66F-426B-A721-F0E56393424B),
dual,
nonextensible,
helpstring("An IP range set"),
pointer_default(unique)
]
interface IFPCIpRangeSet : IFPCPersist
{
	[id(DISPID_ADD), helpstring("Adds an IP range entry to the collection")]
          HRESULT Add( BSTR IP_From,
               BSTR IP_To,
              [out,retval] IFPCIpRangeEntry** ppNewObj);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item([in] VARIANT IndexOrIP_From,
              [in,defaultvalue(NULL)] BSTR IP_To,
              [out,retval] IFPCIpRangeEntry** pItem);
        
    
	[id(DISPID_REMOVE), helpstring("Removes an IP range entry from the collection")]
          HRESULT Remove([in] VARIANT IndexOrIP_From,
              [in,defaultvalue(NULL)] BSTR IP_To);
        
    
	[id(3), helpstring("Removes all of the IP range entries")]
          HRESULT RemoveAll();
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(4), helpstring("Determines if an IP address is included in the collection")]
          HRESULT IsIpInSet([in] BSTR IpStr,
              [out,retval] VARIANT_BOOL* pIsIpInSet);
        
    
	[id(5), helpstring("Determines if an IP range intersects with IP addresses that are in use")]
          HRESULT IsRangeIntersect( BSTR IpFrom,
               BSTR IpTo,
              [out,retval] VARIANT_BOOL* pIsRangeIntersect);
        
    
	[id(6), helpstring("Determines if an IP range is contained within the IP addresses that are in use")]
          HRESULT IsRangeContained( BSTR IpFrom,
               BSTR IpTo,
              [out,retval] VARIANT_BOOL* pIsRangeContained);
        
    
};
	
[
object,
uuid(D6EF2C9A-EA67-48A1-98EB-F304E350EA06),
dual,
helpstring("Listener properties for Web forward and reverse Proxy"),
pointer_default(unique)
]
interface IFPCWebListenerProperties : IDispatch
{
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[propget, id(1), helpstring("Gets or sets whether the object will get the requested URL from the current array (False) or another array (True)")]
    HRESULT ResolveInArray([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets whether the object will get the requested URL from the current array (False) or another array (True)")]
    HRESULT ResolveInArray([in] VARIANT_BOOL newVal);
	
	[propget, id(2), helpstring("Gets or sets whether the Web proxy has an unlimited number of connections")]
    HRESULT UnlimitedNumberOfConnections([out, retval] VARIANT_BOOL *pVal);
    [propput, id(2), helpstring("Gets or sets whether the Web proxy has an unlimited number of connections")]
    HRESULT UnlimitedNumberOfConnections([in] VARIANT_BOOL newVal);
	
	[propget, id(3), helpstring("Gets or sets the number of simultaneous connections with the Internet")]
    HRESULT NumberOfConnections([out, retval] long *pVal);
    [propput, id(3), helpstring("Gets or sets the number of simultaneous connections with the Internet")]
    HRESULT NumberOfConnections([in] long newVal);
	
	[propget, id(4), helpstring("Gets or sets the time-out of a connection")]
    HRESULT ConnectionTimeout([out, retval] long *pVal);
    [propput, id(4), helpstring("Gets or sets the time-out of a connection")]
    HRESULT ConnectionTimeout([in] long newVal);
	
	[propget, id(5), helpstring("Gets or sets the TCP port")]
    HRESULT TCPPort([out, retval] long *pVal);
    [propput, id(5), helpstring("Gets or sets the TCP port")]
    HRESULT TCPPort([in] long newVal);
	
	[propget, id(6), helpstring("Gets or sets the SSL port")]
    HRESULT SSLPort([out, retval] long *pVal);
    [propput, id(6), helpstring("Gets or sets the SSL port")]
    HRESULT SSLPort([in] long newVal);
	
	[propget, id(7), helpstring("Gets or sets whether the Web proxy always authenticates a request even when the policy does not require it")]
    HRESULT AlwaysAuthenticate([out, retval] VARIANT_BOOL *pVal);
    [propput, id(7), helpstring("Gets or sets whether the Web proxy always authenticates a request even when the policy does not require it")]
    HRESULT AlwaysAuthenticate([in] VARIANT_BOOL newVal);
	
	[propget, id(8), helpstring("Gets the SSL server certificates collection used to authenticate the Forefront TMG when a client connects to this Web listener through SSL port")]
    HRESULT AppliedSSLCertificates([out, retval] IFPCAppliedSSLCertificates **pVal);
	
	[propget, id(9), helpstring("Gets or sets whether basic authentication is used")]
    HRESULT BasicAuthentication([out, retval] VARIANT_BOOL *pVal);
    [propput, id(9), helpstring("Gets or sets whether basic authentication is used")]
    HRESULT BasicAuthentication([in] VARIANT_BOOL newVal);
	
	[propget, id(10), helpstring("Gets or sets the whether digest authentication is used")]
    HRESULT DigestAuthentication([out, retval] VARIANT_BOOL *pVal);
    [propput, id(10), helpstring("Gets or sets the whether digest authentication is used")]
    HRESULT DigestAuthentication([in] VARIANT_BOOL newVal);
	
	[propget, id(11), helpstring("Gets or sets whether integrated Windows authentication is used")]
    HRESULT IntegratedWindowsAuthentication([out, retval] VARIANT_BOOL *pVal);
    [propput, id(11), helpstring("Gets or sets whether integrated Windows authentication is used")]
    HRESULT IntegratedWindowsAuthentication([in] VARIANT_BOOL newVal);
	
	[propget, id(12), helpstring("Gets or sets whether SSL certificate authentication is used")]
    HRESULT SSLCertificateAuthentication([out, retval] VARIANT_BOOL *pVal);
    [propput, id(12), helpstring("Gets or sets whether SSL certificate authentication is used")]
    HRESULT SSLCertificateAuthentication([in] VARIANT_BOOL newVal);
	
	[propget, id(13), helpstring("Gets or sets the domain for basic or digest authentication")]
    HRESULT DomainForAuthentication([out, retval] BSTR *pVal);
    [propput, id(13), helpstring("Gets or sets the domain for basic or digest authentication")]
    HRESULT DomainForAuthentication([in] BSTR newVal);
	
	[propget, id(16), helpstring("Gets a reference to the FPCAuthenticationSchemes collection of authentication schemes for the listen entry")]
    HRESULT AuthenticationSchemes([out, retval] IFPCRefs **pVal);
	
	[propget, id(17), helpstring("Gets or sets whether basic authentication is per single request")]
    HRESULT BasicAuthPersistSingleRequest([out, retval] VARIANT_BOOL *pVal);
    [propput, id(17), helpstring("Gets or sets whether basic authentication is per single request")]
    HRESULT BasicAuthPersistSingleRequest([in] VARIANT_BOOL newVal);
	
	[propget, id(18), helpstring("Gets or sets whether digest authentication is per single request")]
    HRESULT DigestAuthPersistSingleRequest([out, retval] VARIANT_BOOL *pVal);
    [propput, id(18), helpstring("Gets or sets whether digest authentication is per single request")]
    HRESULT DigestAuthPersistSingleRequest([in] VARIANT_BOOL newVal);
	
	[propget, id(19), helpstring("Gets or sets whether integrated authentication is per single request")]
    HRESULT IntegratedAuthPersistSingleRequest([out, retval] VARIANT_BOOL *pVal);
    [propput, id(19), helpstring("Gets or sets whether integrated authentication is per single request")]
    HRESULT IntegratedAuthPersistSingleRequest([in] VARIANT_BOOL newVal);
	
	[propget, id(20), helpstring("Gets or sets whether RADIUS authentication is per single request")]
    HRESULT SingleRadiusServerAuthPerSession([out, retval] VARIANT_BOOL *pVal);
    [propput, id(20), helpstring("Gets or sets whether RADIUS authentication is per single request")]
    HRESULT SingleRadiusServerAuthPerSession([in] VARIANT_BOOL newVal);
	
	[propget, id(21), helpstring("Gets or sets whether to return an authorization required message if the user was authenticated but couldn't pass the rules (Default is to return a denied message, which will not give the user an option to authenticate with other credentials)")]
    HRESULT ReturnAuthRequiredIfAuthUserDenied([out, retval] VARIANT_BOOL *pVal);
    [propput, id(21), helpstring("Gets or sets whether to return an authorization required message if the user was authenticated but couldn't pass the rules (Default is to return a denied message, which will not give the user an option to authenticate with other credentials)")]
    HRESULT ReturnAuthRequiredIfAuthUserDenied([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(F5537DFF-D3F2-41BA-A86A-75CEAB173151),
dual,
helpstring("Listener properties for Web forward and reverse Proxy"),
pointer_default(unique)
]
interface IFPCWebListenerProperties2 : IFPCWebListenerProperties
{
	[propget, id(22), helpstring("Gets or sets a Boolean value that indicates whether single sign on (SSO) is enabled")]
    HRESULT SSOEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(22), helpstring("Gets or sets a Boolean value that indicates whether single sign on (SSO) is enabled")]
    HRESULT SSOEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(23), helpstring("Gets an FPCDomainNameSet object that holds the domain names used for single sign on (SSO)")]
    HRESULT SSODomainNames([out, retval] IFPCDomainNameSet **pVal);
	
	[propget, id(24), helpstring("Gets an FPCFormsBasedAuthenticationProperties object that holds the properties of forms-based authentication")]
    HRESULT FormsBasedAuthenticationProperties([out, retval] IFPCFormsBasedAuthenticationProperties **pVal);
	
	[propget, id(25), helpstring("Gets or sets the SSL accelerator port for the Web listener")]
    HRESULT SSLAcceleratorPort([out, retval] long *pVal);
    [propput, id(25), helpstring("Gets or sets the SSL accelerator port for the Web listener")]
    HRESULT SSLAcceleratorPort([in] long newVal);
	
	[propget, id(26), helpstring("Gets or sets a Boolean value that indicates whether client credentials are validated for every HTTP request")]
    HRESULT ValidateCredentialsForEveryHTTPRequest([out, retval] VARIANT_BOOL *pVal);
    [propput, id(26), helpstring("Gets or sets a Boolean value that indicates whether client credentials are validated for every HTTP request")]
    HRESULT ValidateCredentialsForEveryHTTPRequest([in] VARIANT_BOOL newVal);
	
	[propget, id(27), helpstring("Gets or sets the client credentials time-out period")]
    HRESULT ClientCredentialsTimeout([out, retval] long *pVal);
    [propput, id(27), helpstring("Gets or sets the client credentials time-out period")]
    HRESULT ClientCredentialsTimeout([in] long newVal);
	
	[propget, id(28), helpstring("Gets or sets a Boolean value that indicates whether the SSL client certificate time-out period is enabled")]
    HRESULT SSLClientCertificateTimeoutEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(28), helpstring("Gets or sets a Boolean value that indicates whether the SSL client certificate time-out period is enabled")]
    HRESULT SSLClientCertificateTimeoutEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(29), helpstring("Gets or sets the SSL client certificate time-out period")]
    HRESULT SSLClientCertificateTimeout([out, retval] long *pVal);
    [propput, id(29), helpstring("Gets or sets the SSL client certificate time-out period")]
    HRESULT SSLClientCertificateTimeout([in] long newVal);
	
	[propget, id(30), helpstring("Gets or sets a Boolean value that indicates whether the Web proxy allows authentication over HTTP")]
    HRESULT AllowAuthenticationOverHTTP([out, retval] VARIANT_BOOL *pVal);
    [propput, id(30), helpstring("Gets or sets a Boolean value that indicates whether the Web proxy allows authentication over HTTP")]
    HRESULT AllowAuthenticationOverHTTP([in] VARIANT_BOOL newVal);
	
	[propget, id(31), helpstring("Gets or sets a value from the FpcRedirectHTTPAsHTTPS enumerated type that specifies whether the Web proxy should redirect HTTP requests to HTTPS")]
    HRESULT RedirectHTTPAsHTTPS([out, retval] FpcRedirectHTTPAsHTTPS *pVal);
    [propput, id(31), helpstring("Gets or sets a value from the FpcRedirectHTTPAsHTTPS enumerated type that specifies whether the Web proxy should redirect HTTP requests to HTTPS")]
    HRESULT RedirectHTTPAsHTTPS([in] FpcRedirectHTTPAsHTTPS newVal);
	
	[propget, id(32), helpstring("Gets or sets a Boolean value that indicates whether only certificates from the specified trusted root certification authorities will be accepted")]
    HRESULT UseSSLClientCertificatesTrustList([out, retval] VARIANT_BOOL *pVal);
    [propput, id(32), helpstring("Gets or sets a Boolean value that indicates whether only certificates from the specified trusted root certification authorities will be accepted")]
    HRESULT UseSSLClientCertificatesTrustList([in] VARIANT_BOOL newVal);
	
	[propget, id(33), helpstring("Gets a collection that contains the SSL certificates of the trusted root certification authorities")]
    HRESULT SSLClientCertificatesRootTrustList([out, retval] IFPCAppliedSSLCertificates **pVal);
	
	[propget, id(34), helpstring("Gets a collection that contains the SSL certificates of the intermediate certificate authorities")]
    HRESULT SSLClientCertificatesIntermediateTrustList([out, retval] IFPCAppliedSSLCertificates **pVal);
	
	[propget, id(35), helpstring("Gets or sets a Boolean value that indicates whether the SSL client certificate restrictions are enabled")]
    HRESULT SSLClientCertificateRestrictionsEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(35), helpstring("Gets or sets a Boolean value that indicates whether the SSL client certificate restrictions are enabled")]
    HRESULT SSLClientCertificateRestrictionsEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(36), helpstring("Gets the collection of SSL client certificate restrictions for the Web listener")]
    HRESULT SSLClientCertificateRestrictions([out, retval] IFPCSSLClientCertificateRestrictions **pVal);
	
};
	
[
object,
uuid(820752BE-CE2C-4BE6-9DBE-1FDBEA51C690),
dual,
nonextensible,
helpstring("Listener properties for Web forward and reverse Proxy"),
pointer_default(unique)
]
interface IFPCWebListenerProperties3 : IFPCWebListenerProperties2
{
	[propget, id(37), helpstring("Gets or sets a value from the FpcSSLTerminationMode enumerated type that specifies how SSL connections are terminated")]
    HRESULT SSLTerminationMode([out, retval] FpcSSLTerminationMode *pVal);
    [propput, id(37), helpstring("Gets or sets a value from the FpcSSLTerminationMode enumerated type that specifies how SSL connections are terminated")]
    HRESULT SSLTerminationMode([in] FpcSSLTerminationMode newVal);
	
	[propget, id(38), helpstring("Gets a Boolean value that indicates whether this is an SSTP Web listener")]
    HRESULT IsSSTPListener([out, retval] VARIANT_BOOL *pVal);
	
};
	
[
object,
uuid(7350CF63-4F04-4492-8529-D863C204167B),
dual,
nonextensible,
helpstring("Listener properties for forms based authentication (FBA)"),
pointer_default(unique)
]
interface IFPCFormsBasedAuthenticationProperties : IDispatch
{
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[propget, id(1), helpstring("Gets or sets the type of client computer for which persistent cookies are allowed")]
    HRESULT UsePersistentCookies([out, retval] FpcUsePersistentCookiesComputerType *pVal);
    [propput, id(1), helpstring("Gets or sets the type of client computer for which persistent cookies are allowed")]
    HRESULT UsePersistentCookies([in] FpcUsePersistentCookiesComputerType newVal);
	
	[propget, id(2), helpstring("Gets or sets the session time-out period for trusted computers")]
    HRESULT SessionTimeOutForTrustedComputers([out, retval] long *pVal);
    [propput, id(2), helpstring("Gets or sets the session time-out period for trusted computers")]
    HRESULT SessionTimeOutForTrustedComputers([in] long newVal);
	
	[propget, id(3), helpstring("Gets or sets the time units of the session time-out period for trusted computers")]
    HRESULT SessionTimeOutUnitsForTrustedComputers([out, retval] FpcTimeScale *pVal);
    [propput, id(3), helpstring("Gets or sets the time units of the session time-out period for trusted computers")]
    HRESULT SessionTimeOutUnitsForTrustedComputers([in] FpcTimeScale newVal);
	
	[propget, id(4), helpstring("Gets or sets the session time-out period for public computers")]
    HRESULT SessionTimeOutForPublicComputers([out, retval] long *pVal);
    [propput, id(4), helpstring("Gets or sets the session time-out period for public computers")]
    HRESULT SessionTimeOutForPublicComputers([in] long newVal);
	
	[propget, id(5), helpstring("Gets or sets the time units of the session time-out period for public computers")]
    HRESULT SessionTimeOutUnitsForPublicComputers([out, retval] FpcTimeScale *pVal);
    [propput, id(5), helpstring("Gets or sets the time units of the session time-out period for public computers")]
    HRESULT SessionTimeOutUnitsForPublicComputers([in] FpcTimeScale newVal);
	
	[propget, id(6), helpstring("Gets or sets a Boolean value that indicates whether the session timeouts for private and public computers are treated as absolute")]
    HRESULT UseAbsoluteCookieExpiration([out, retval] VARIANT_BOOL *pVal);
    [propput, id(6), helpstring("Gets or sets a Boolean value that indicates whether the session timeouts for private and public computers are treated as absolute")]
    HRESULT UseAbsoluteCookieExpiration([in] VARIANT_BOOL newVal);
	
	[propget, id(7), helpstring("Gets or sets the cookie name used for forms-based authentication")]
    HRESULT FBACookieName([out, retval] BSTR *pVal);
    [propput, id(7), helpstring("Gets or sets the cookie name used for forms-based authentication")]
    HRESULT FBACookieName([in] BSTR newVal);
	
	[propget, id(8), helpstring("Gets or sets a Boolean value that indicates whether the client IP address is used for cookie validation")]
    HRESULT ClientIPAddressSigningEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(8), helpstring("Gets or sets a Boolean value that indicates whether the client IP address is used for cookie validation")]
    HRESULT ClientIPAddressSigningEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(10), helpstring("Gets or sets a Boolean value that indicates whether logon form should include credentials for delegation to the published server")]
    HRESULT IncludeDelegationCredentialsInLogonForm([out, retval] VARIANT_BOOL *pVal);
    [propput, id(10), helpstring("Gets or sets a Boolean value that indicates whether logon form should include credentials for delegation to the published server")]
    HRESULT IncludeDelegationCredentialsInLogonForm([in] VARIANT_BOOL newVal);
	
	[propget, id(11), helpstring("Gets or sets a Boolean value that indicates whether Basic authentication can be used for non-browser clients")]
    HRESULT UseBasicAuthenticationForNonBrowserClients([out, retval] VARIANT_BOOL *pVal);
    [propput, id(11), helpstring("Gets or sets a Boolean value that indicates whether Basic authentication can be used for non-browser clients")]
    HRESULT UseBasicAuthenticationForNonBrowserClients([in] VARIANT_BOOL newVal);
	
	[propget, id(12), helpstring("Gets an FPCSecurIDAuthenticationProperties object that holds the properties of RSA SecurID authentication")]
    HRESULT SecurIDAuthenticationProperties([out, retval] IFPCSecurIDAuthenticationProperties **pVal);
	
	[propget, id(13), helpstring("Gets or sets the name of the directory with custom HTML forms")]
    HRESULT CustomFormsDirectory([out, retval] BSTR *pVal);
    [propput, id(13), helpstring("Gets or sets the name of the directory with custom HTML forms")]
    HRESULT CustomFormsDirectory([in] BSTR newVal);
	
	[propget, id(14), helpstring("Gets or sets the preferred language of HTML forms")]
    HRESULT FormsLanguage([out, retval] BSTR *pVal);
    [propput, id(14), helpstring("Gets or sets the preferred language of HTML forms")]
    HRESULT FormsLanguage([in] BSTR newVal);
	
	[propget, id(15), helpstring("Gets or sets a Boolean value that indicates whether clients using forms-based authentication may change their password")]
    HRESULT ChangePasswordAllowed([out, retval] VARIANT_BOOL *pVal);
    [propput, id(15), helpstring("Gets or sets a Boolean value that indicates whether clients using forms-based authentication may change their password")]
    HRESULT ChangePasswordAllowed([in] VARIANT_BOOL newVal);
	
	[propget, id(16), helpstring("Gets or sets a Boolean value that indicates whether clients will be warned if their password is about to expire")]
    HRESULT PasswordExpirationWarningEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(16), helpstring("Gets or sets a Boolean value that indicates whether clients will be warned if their password is about to expire")]
    HRESULT PasswordExpirationWarningEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(17), helpstring("Gets or sets the password expiration warning period, in days")]
    HRESULT PasswordExpirationWarningPeriod([out, retval] long *pVal);
    [propput, id(17), helpstring("Gets or sets the password expiration warning period, in days")]
    HRESULT PasswordExpirationWarningPeriod([in] long newVal);
	
	[propget, id(18), helpstring("Gets or sets a Boolean value that indicates whether to apply session timeout to non-browser clients")]
    HRESULT ApplySessionTimeoutToNonBrowserClients([out, retval] VARIANT_BOOL *pVal);
    [propput, id(18), helpstring("Gets or sets a Boolean value that indicates whether to apply session timeout to non-browser clients")]
    HRESULT ApplySessionTimeoutToNonBrowserClients([in] VARIANT_BOOL newVal);
	
	[propget, id(19), helpstring("Gets or sets a Boolean value that indicates whether HTTPS requests sent without a client certificate will be denied before the HTML form is presented to the user")]
    HRESULT RequireSSLClientCertificate([out, retval] VARIANT_BOOL *pVal);
    [propput, id(19), helpstring("Gets or sets a Boolean value that indicates whether HTTPS requests sent without a client certificate will be denied before the HTML form is presented to the user")]
    HRESULT RequireSSLClientCertificate([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(302E0628-9A1C-4FBA-B55E-14B763B6068F),
dual,
nonextensible,
helpstring("Listener properties for RSA SecurID authentication"),
pointer_default(unique)
]
interface IFPCSecurIDAuthenticationProperties : IDispatch
{
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[propget, id(1), helpstring("Gets or sets a Boolean value that indicates whether the RSA ACE/Server Name Locking feature is enabled")]
    HRESULT SecurIDNameLockEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets a Boolean value that indicates whether the RSA ACE/Server Name Locking feature is enabled")]
    HRESULT SecurIDNameLockEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(2), helpstring("Gets or sets a Boolean value that indicates whether the use of separate user name and PASSCODE pages is enabled")]
    HRESULT SeparateUserNameAndPasscodeEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(2), helpstring("Gets or sets a Boolean value that indicates whether the use of separate user name and PASSCODE pages is enabled")]
    HRESULT SeparateUserNameAndPasscodeEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(3), helpstring("Gets or sets the cookie name for RSA SecurID authentication")]
    HRESULT SecurIDCookieName([out, retval] BSTR *pVal);
    [propput, id(3), helpstring("Gets or sets the cookie name for RSA SecurID authentication")]
    HRESULT SecurIDCookieName([in] BSTR newVal);
	
	[id(4), helpstring("Exports the domain secret for RSA ACE/Server to a file")]
          HRESULT ExportSecurIDDomainSecret([in] BSTR FileName,
              [in] BSTR Password);
        
    
	[id(5), helpstring("Imports the domain secret for RSA ACE/Server from a file")]
          HRESULT ImportSecurIDDomainSecret([in] BSTR FileName,
              [in] BSTR Password);
        
    
	[id(6), helpstring("Generate a new domain secret for RSA ACE/Server, and export it to a file")]
          HRESULT GenerateSecurIDDomainSecret([in] BSTR FileName,
              [in] BSTR Password);
        
    
};
	
[
object,
uuid(05A5FA96-3AB5-4EDC-B5C5-1AEF9EA11B25),
dual,
nonextensible,
helpstring("Listener for Incoming Web Requests"),
pointer_default(unique)
]
interface IFPCWebListener : IFPCPersist
{
	[propget, id(1), helpstring("Gets a reference to the IFPCWebListenerProperty")]
    HRESULT Properties([out, retval] IFPCWebListenerProperties **pVal);
	
	[propget, id(3), helpstring("Gets a reference to the collection of references to the network sets the Web listener listens to")]
    HRESULT SourceNetworkSets([out, retval] IFPCRefs **pVal);
	
	[propget, id(5), helpstring("Gets a reference to the collection of IPs and Servers to listen on")]
    HRESULT IPsOnNetworks([out, retval] IFPCIPsOnNetworks **pVal);
	
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the Web listener")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the Web listener")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(6), helpstring("Gets or sets the description of the Web listener")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(6), helpstring("Gets or sets the description of the Web listener")]
    HRESULT Description([in] BSTR newVal);
	
};
	
[
object,
uuid(DFCF8DC1-0533-40CF-86D0-A987AF6C845C),
dual,
nonextensible,
helpstring("A Web Listeners collection for incoming Web requests"),
pointer_default(unique)
]
interface IFPCWebListeners : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCWebListener** pItem);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Adds a new Web listener")]
          HRESULT Add( BSTR Name,
              [out,retval] IFPCWebListener** pItem);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a Web listener")]
          HRESULT Remove( VARIANT v);
        
    
};
	
[
object,
uuid(167629C9-1DBA-4154-B728-BA4A8140E9AA),
dual,
nonextensible,
helpstring("An SSL client certificate restriction"),
pointer_default(unique)
]
interface IFPCSSLClientCertificateRestriction : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the SSL client certificate restriction")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the SSL client certificate restriction")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the description of the SSL client certificate restriction")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the description of the SSL client certificate restriction")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets a value from the FpcCertificateRestrictionField enumerated type that specifies the certificate field to which the restriction applies")]
    HRESULT CertificateRestrictionField([out, retval] FpcCertificateRestrictionField *pVal);
    [propput, id(2), helpstring("Gets or sets a value from the FpcCertificateRestrictionField enumerated type that specifies the certificate field to which the restriction applies")]
    HRESULT CertificateRestrictionField([in] FpcCertificateRestrictionField newVal);
	
	[propget, id(3), helpstring("Gets or sets a value from the FpcOIDMatchType enumerated type that specifies the type of match required for the object identifier (OID) of the field by the restriction")]
    HRESULT OIDMatchType([out, retval] FpcOIDMatchType *pVal);
    [propput, id(3), helpstring("Gets or sets a value from the FpcOIDMatchType enumerated type that specifies the type of match required for the object identifier (OID) of the field by the restriction")]
    HRESULT OIDMatchType([in] FpcOIDMatchType newVal);
	
	[propget, id(4), helpstring("Gets or sets the object identifier (OID) used for determining a match")]
    HRESULT OID([out, retval] BSTR *pVal);
    [propput, id(4), helpstring("Gets or sets the object identifier (OID) used for determining a match")]
    HRESULT OID([in] BSTR newVal);
	
	[propget, id(5), helpstring("Gets or sets a value from the FpcValueMatchType enumerated type that specifies the type of match required for the field value")]
    HRESULT ValueMatchType([out, retval] FpcValueMatchType *pVal);
    [propput, id(5), helpstring("Gets or sets a value from the FpcValueMatchType enumerated type that specifies the type of match required for the field value")]
    HRESULT ValueMatchType([in] FpcValueMatchType newVal);
	
	[propget, id(6), helpstring("Gets or sets the string that will be used to determine a match with the field value")]
    HRESULT Value([out, retval] BSTR *pVal);
    [propput, id(6), helpstring("Gets or sets the string that will be used to determine a match with the field value")]
    HRESULT Value([in] BSTR newVal);
	
};
	
[
object,
uuid(4A4FADD8-93AF-4B72-ADFC-C48F6AE17754),
dual,
nonextensible,
helpstring("A collection of SSL client certificate restrictions"),
pointer_default(unique)
]
interface IFPCSSLClientCertificateRestrictions : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Retrieves the requested FPCSSLClientCertificateRestriction object from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCSSLClientCertificateRestriction** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Creates a new FPCSSLClientCertificateRestriction object in the collection")]
          HRESULT Add( BSTR Name,
              [out,retval] IFPCSSLClientCertificateRestriction** pItem);
        
    
	[id(DISPID_REMOVE), helpstring("Removes the specified FPCSSLClientCertificateRestriction object from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(1), helpstring("Removes all of the FPCSSLClientCertificateRestriction objects from the collection")]
          HRESULT RemoveAll();
        
    
};
	
[
object,
uuid(E6D04BD9-E0E0-4561-AEDA-1253BB5E57E5),
dual,
nonextensible,
helpstring("A collection of IP addresses on a Network"),
pointer_default(unique)
]
interface IFPCIPsOnNetworks : IDispatch
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item([in] VARIANT IndexOrNetwork,
              [out,retval] IFPCIPOnNetwork** ppIPOnNetwork);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[id(DISPID_ADD), helpstring("Adds a new IP on a Network to the collection")]
          HRESULT Add([in] BSTR Network,
              [in,defaultvalue(fpcAllIPAddresses)] FpcIPSelectionMethods IPSelectionMethod,
              [in,defaultvalue("")] BSTR IP,
              [out,retval] IFPCIPOnNetwork** ppIPOnNetwork);
        
    
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_REMOVE), helpstring("Removes an IP on a Network from the collection")]
          HRESULT Remove([in] VARIANT IndexOrNetwork);
        
    
};
	
[
object,
uuid(1FEC9795-FBA3-4F56-8495-585BE19BB81A),
dual,
nonextensible,
helpstring("IP Address collection"),
pointer_default(unique)
]
interface IFPCIPAddresses : IDispatch
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] BSTR* pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_ADD), helpstring("Adds a IP to the object")]
          HRESULT Add( BSTR IP);
        
    
	[id(DISPID_REMOVE), helpstring("Removes an IP  from the object")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(1), helpstring("Removes all of the IP addresses from the object")]
          HRESULT RemoveAll();
        
    
};
	
[
object,
uuid(0A4883D1-C1C3-4B80-8B2D-A49DE22474DE),
dual,
nonextensible,
helpstring("IP address on a Network"),
pointer_default(unique)
]
interface IFPCIPOnNetwork : IDispatch
{
	[id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
          HRESULT Save([in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
              [in,defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);
        
    
	[id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
          HRESULT Refresh();
        
    
	[propget, id(1), helpstring("Gets or Sets the IP address to listen on")]
    HRESULT IPSelectionMethod([out, retval] FpcIPSelectionMethods *pVal);
    [propput, id(1), helpstring("Gets or Sets the IP address to listen on")]
    HRESULT IPSelectionMethod([in] FpcIPSelectionMethods newVal);
	
	[propget, id(2), helpstring("Gets a reference to the Network")]
    HRESULT Network([out, retval] IFPCRef **pVal);
	
	[propget, id(3), helpstring("Gets IP addresses collection")]
    HRESULT IpAddresses([out, retval] IFPCIPAddresses **pVal);
	
};
	
[
object,
uuid(3257E9F4-12CE-450C-83CA-C0542260951A),
dual,
nonextensible,
helpstring("A collection of applied SSL server certificate"),
pointer_default(unique)
]
interface IFPCAppliedSSLCertificates : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( long lIndex,
              [out,retval] IFPCAppliedSSLCertificate** ppAppliedSSLCertificate);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Adds a new SSL server certificate to be applied by the Web server listener")]
          HRESULT Add([in] VARIANT Hash,
              [in,defaultvalue("")] BSTR Server,
              [out,retval] IFPCAppliedSSLCertificate** ppAppliedSSLCertificate);
        
    
	[id(DISPID_REMOVE), helpstring("Remove SSL server certificate from the collection")]
          HRESULT Remove( long lIndex);
        
    
};
	
[
object,
uuid(7AB935DD-FE4B-4568-9902-7FADA9541B4E),
dual,
helpstring("A SSL server certificate in a server used to authenticate the Forefront TMG when a client connects to this Web listener through SSL port"),
pointer_default(unique)
]
interface IFPCAppliedSSLCertificate : IFPCPersist
{
	[propget, id(2), helpstring("Gets a reference to the server")]
    HRESULT Server([out, retval] IFPCRef **pVal);
	
	[propget, id(3), helpstring("Returns the FPCCertificate object")]
    HRESULT SSLCertificate([out, retval] IFPCCertificate **pVal);
	
};
	
[
object,
uuid(4852274A-5421-432c-8277-688CEA601DF0),
dual,
nonextensible,
helpstring("A SSL server certificate in a server used to authenticate the Forefront TMG when a client connects to this Web listener through SSL port"),
pointer_default(unique)
]
interface IFPCAppliedSSLCertificate2 : IFPCAppliedSSLCertificate
{
	[propget, id(4), helpstring("Gets the IP address associated with this certificate")]
    HRESULT IPAddress([out, retval] BSTR *pVal);
    [propput, id(4), helpstring("Gets the IP address associated with this certificate")]
    HRESULT IPAddress([in] BSTR newVal);
	
};
	
[
object,
uuid(E10A0378-F44D-4B05-B0E1-602C58933691),
dual,
helpstring("Collection of report jobs"),
pointer_default(unique)
]
interface IFPCReportJobs : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCReportJob** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Adds a prefetch task to the collection")]
          HRESULT Add([in] BSTR Name,
              [in] BSTR ServerName,
              [out,retval] IFPCReportJob** ppNewReportJob);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a prefetch task from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[propget, id(1), helpstring("Gets properties of all of the report jobs")]
    HRESULT ReportsProperties([out, retval] IFPCReportsProperties **pVal);
	
};
	
[
object,
uuid(182D5C98-CF3A-4FCA-BB22-1CFB6A7E33BF),
dual,
nonextensible,
helpstring("Collection of report jobs"),
pointer_default(unique)
]
interface IFPCReportJobs2 : IFPCReportJobs
{
	[id(2), helpstring("Adds a prefetch task to the collection")]
          HRESULT Add( BSTR Name,
              [out,retval] IFPCReportJob** ppNewReportJob);
        
    
};
	
[
object,
uuid(2D4B3A33-C2B6-440B-A03B-249766A975E2),
dual,
helpstring("A report job"),
pointer_default(unique)
]
interface IFPCReportJob : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the report job")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the report job")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the description of the report job")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the description of the report job")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets whether the report job is enabled")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(2), helpstring("Gets or sets whether the report job is enabled")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(3), helpstring("Gets or sets the categories of the report job"), hidden]
    HRESULT Categories([out, retval] FpcReportJobCategory *pVal);
    [propput, id(3), helpstring("Gets or sets the categories of the report job"), hidden]
    HRESULT Categories([in] FpcReportJobCategory newVal);
	
	[propget, id(4), helpstring("Gets the period type of the report job")]
    HRESULT PeriodType([out, retval] FpcReportJobPeriodType *pVal);
	
	[propget, id(5), helpstring("Gets the start date of the report job period")]
    HRESULT RunOnceReportJobPeriodStart([out, retval] DATE *pVal);
	
	[propget, id(6), helpstring("Gets the end date of the report job period")]
    HRESULT RunOnceReportJobPeriodEnd([out, retval] DATE *pVal);
	
	[id(7), helpstring("Sets the report job to run only once on a specified period")]
          HRESULT SetAsRunOnceReportJob([in] DATE PeriodStart,
              [in] DATE dPeriodEnd);
        
    
	[propget, id(8), helpstring("Gets the reoccurrence type of the report job")]
    HRESULT RecurrenceType([out, retval] FpcScheduledTaskRunningPeriod *pVal);
	
	[propget, id(9), helpstring("Gets the start date of the report job")]
    HRESULT RecurringReportJobStartDate([out, retval] DATE *pVal);
	
	[propget, id(10), helpstring("Gets the days on which the report job will run")]
    HRESULT RecurringReportJobDaysOfWeek([out, retval] FpcDaysOfWeek *pVal);
	
	[propget, id(11), helpstring("Gets the day of the month on which the report job will run")]
    HRESULT RecurringReportJobDayOfMonth([out, retval] long *pVal);
	
	[id(12), helpstring("Sets the report job to run every day starting from a specified date")]
          HRESULT SetAsDailyReportJob([in] FpcReportJobPeriodType PeriodType,
              [in,defaultvalue(0)] DATE StartDate);
        
    
	[id(13), helpstring("Sets the report job to run on several week days starting from a specified date")]
          HRESULT SetAsMultipleDaysReportJob([in] FpcDaysOfWeek Days,
              [in] FpcReportJobPeriodType PeriodType,
              [in,defaultvalue(0)] DATE StartDate);
        
    
	[id(14), helpstring("Sets the report job to run once a month starting from a specified date")]
          HRESULT SetAsOncePerMonthReportJob([in] long DayOfMonth,
              [in] FpcReportJobPeriodType PeriodType,
              [in,defaultvalue(0)] DATE StartDate);
        
    
	[propget, id(15), helpstring("Gets a reference to the server that generates the report"), hidden]
    HRESULT Server([out, retval] IFPCRef **pVal);
	
	[id(16), helpstring("Sets the name of the server that generates the report"), hidden]
          HRESULT SetServer([in] BSTR bstrServerName);
        
    
	[propget, id(17), helpstring("Gets the credentials needed to generate the report")]
    HRESULT Credentials([out, retval] IFPCCredentials **pVal);
	
	[propget, id(18), helpstring("Gets whether to send an email when the report is ready")]
    HRESULT EnableEmailing([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(19), helpstring("Gets the SMTP server used to send the email")]
    HRESULT SmtpServer([out, retval] BSTR *pVal);
	
	[propget, id(20), helpstring("Gets the email address from which the email will be sent")]
    HRESULT EmailFrom([out, retval] BSTR *pVal);
	
	[propget, id(21), helpstring("Gets the email address to which the email will be sent")]
    HRESULT EmailTo([out, retval] BSTR *pVal);
	
	[propget, id(22), helpstring("Gets the email address to which the email will be sent as a CC")]
    HRESULT EmailCC([out, retval] BSTR *pVal);
	
	[propget, id(23), helpstring("Gets the email body")]
    HRESULT EmailBody([out, retval] BSTR *pVal);
	
	[propget, id(24), helpstring("Gets whether to add a link to the published report in the email body")]
    HRESULT AddLinkToPublishedReport([out, retval] VARIANT_BOOL *pVal);
	
	[id(25), helpstring("Sets report emailing properties")]
          HRESULT SetEmailing([in] VARIANT_BOOL fEnableEmailing,
              [in,defaultvalue(NULL)] BSTR bstrSmtpServer,
              [in,defaultvalue(NULL)] BSTR bstrEmailFrom,
              [in,defaultvalue(NULL)] BSTR bstrEmailTo,
              [in,defaultvalue(NULL)] BSTR bstrEmailCC,
              [in,defaultvalue(NULL)] BSTR bstrEmailBody,
              [in,defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fAddLinkToPublishedReport);
        
    
	[propget, id(26), helpstring("Gets whether report publishing is enabled")]
    HRESULT EnablePublishing([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(27), helpstring("Gets whether report publishing credentilas are used")]
    HRESULT UsePublishingCredentials([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(28), helpstring("Gets the publishing directory of the report job")]
    HRESULT PublishDirectory([out, retval] BSTR *pVal);
	
	[propget, id(29), helpstring("Gets the credentials needed for publishing the report job")]
    HRESULT PublishCredentials([out, retval] IFPCCredentials **pVal);
	
	[id(30), helpstring("Sets report publishing properties")]
          HRESULT SetPublishing([in] VARIANT_BOOL fEnablePublishing,
              [in,defaultvalue(NULL)] BSTR bstrPublishingDirectory);
        
    
	[id(31), helpstring("Sets report publishing credentials properties")]
          HRESULT SetPublishingCredentials([in] VARIANT_BOOL fUsePublishingCredentials,
              [in,defaultvalue(NULL)] BSTR UserName,
              [in,defaultvalue(NULL)] BSTR Password);
        
    
	[id(32), helpstring("Runs the report job")]
          HRESULT Run();
        
    
};
	
[
object,
uuid(6E7F54ED-08A5-4f75-8972-A1676DC60C26),
dual,
helpstring("A report job"),
pointer_default(unique)
]
interface IFPCEEReportJob : IFPCReportJob
{
	[propget, id(33), helpstring("Gets or sets the RunASAP flag"), hidden]
    HRESULT RunAsSoonAsPossible([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(34), helpstring("Gets the Guid of the ready report for this ad-hoc report job"), hidden]
    HRESULT GuidForAdHocReport([out, retval] BSTR *pVal);
	
};
	
[
object,
uuid(33FCE7D7-3119-4427-BAB9-FBCD274D39AC),
dual,
nonextensible,
helpstring("A report job"),
pointer_default(unique)
]
interface IFPCEEReportJob2 : IFPCEEReportJob
{
	[id(35), helpstring("Generates the report defined in the report job")]
          HRESULT CreateReport([in] BSTR bstrReportStorageFolder,
              [in,defaultvalue(NULL)] BSTR bstrReportFormat);
        
    
	[id(36), helpstring("Sets the report job to run only once")]
          HRESULT SetAsRunOnce([in] FpcReportJobPeriodType reportType,
              [in] DATE PeriodStart,
              [in] DATE dPeriodEnd);
        
    
	[propget, id(37), helpstring("Gets an FPCRefs collection that contains objects representing the categories included for this report")]
    HRESULT ReportCategories([out, retval] IFPCRefs **pVal);
	
	[propget, id(38), helpstring("Gets an FPCRdlReportParameterInstances collection that contains objects representing the Report Definition Language (RDL) parameterss for this report")]
    HRESULT ReportParameters([out, retval] IFPCRdlReportParameterInstances **pVal);
	
	[id(39), helpstring("Adds a category to the report job")]
          HRESULT AddCategory([in] BSTR bstrCategoryName);
        
    
	[id(40), helpstring("Removes all categories from the report job")]
          HRESULT RemoveAllCategories();
        
    
	[id(41), helpstring("Adds a parameter instance to the report job")]
          HRESULT AddParameterInstance([in] BSTR bstrName,
              [in] BSTR bstrCategoryName,
              [in] BSTR bstrRdlName,
              [in] BSTR bstrParameterName,
              [in] BSTR bstrParameterValue);
        
    
	[id(42), helpstring("Removes all categories from the report job")]
          HRESULT RemoveAllParameterInstances();
        
    
};
	
[
object,
uuid(A2430A9A-CCA3-4091-B2A8-038EC34EABC7),
dual,
helpstring("Reports related configuration"),
pointer_default(unique)
]
interface IFPCReports : IFPCPersist
{
	[propget, id(1), helpstring("Gets an object that holds all report jobs configuration for the array")]
    HRESULT ReportJobs([out, retval] IFPCReportJobs **pVal);
	
	[propget, id(2), helpstring("Gets an object that holds all ready reports for the array"), hidden]
    HRESULT ReadyReports([out, retval] IFPCReadyReports **pVal);
	
	[propget, id(3), helpstring("Gets daily summary configuration")]
    HRESULT LogSummaryConfiguration([out, retval] IFPCLogSummaryConfiguration **pVal);
	
};
	
[
object,
uuid(77E831AA-7FEF-44d6-BAB1-169B24C3432C),
dual,
nonextensible,
helpstring("Reports related configuration"),
pointer_default(unique)
]
interface IFPCReports2 : IFPCReports
{
	[propget, id(4), helpstring("Gets an FPCReportSummaryDefinitions collection that contains the report summary definitions")]
    HRESULT ReportSummaryDefinitions([out, retval] IFPCReportSummaryDefinitions **pVal);
	
	[propget, id(5), helpstring("Gets an FPCRdlReportDefinitions collection that contains objects representing the Report Definition Language (RDL) definitions of the reports")]
    HRESULT RdlReportDefinitions([out, retval] IFPCRdlReportDefinitions **pVal);
	
	[propget, id(6), helpstring("Gets an FPCReportingServicesProperties object that holds the SQL Server Reporting Services configuration settings")]
    HRESULT ReportingServicesProperties([out, retval] IFPCReportingServicesProperties **pVal);
	
	[propget, id(7), helpstring("Gets an FPCRdlReportCategories collection that contains objects representing the categories of the reports")]
    HRESULT RdlReportCategories([out, retval] IFPCRdlReportCategories **pVal);
	
	[propget, id(8), helpstring("Gets an FPCRdlReportParameters collection that contains objects representing the parameters of the reports")]
    HRESULT RdlReportParameters([out, retval] IFPCRdlReportParameters **pVal);
	
};
	
[
object,
uuid(2197EB64-182F-4FB3-A397-A1CF6B725305),
dual,
nonextensible,
helpstring("Daily summaries configuration"),
pointer_default(unique)
]
interface IFPCLogSummaryConfiguration : IFPCPersist
{
	[propget, id(3), helpstring("Gets or sets daily summaries generation job enable/disable property")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(3), helpstring("Gets or sets daily summaries generation job enable/disable property")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(4), helpstring("Gets or sets daily summaries generation start property")]
    HRESULT StartHour([out, retval] long *pVal);
    [propput, id(4), helpstring("Gets or sets daily summaries generation start property")]
    HRESULT StartHour([in] long newVal);
	
	[propget, id(5), helpstring("Gets or sets daily summaries generation start property")]
    HRESULT StartMinutes([out, retval] long *pVal);
    [propput, id(5), helpstring("Gets or sets daily summaries generation start property")]
    HRESULT StartMinutes([in] long newVal);
	
	[propget, id(6), helpstring("Gets or sets daily summaries directory type property")]
    HRESULT DirectoryType([out, retval] FpcLogFileDirectoryType *pVal);
	
	[propget, id(7), helpstring("Gets or sets daily summaries directory type property")]
    HRESULT DirectoryName([out, retval] BSTR *pVal);
	
	[id(8), helpstring("sets daily summaries directory properties")]
          HRESULT SetDirectory([in] FpcLogFileDirectoryType type,
              [in] BSTR dirName);
        
    
	[propget, id(9), helpstring("Gets or sets number of old daily summaries to keep")]
    HRESULT KeepOldDailySummaries([out, retval] long *pVal);
    [propput, id(9), helpstring("Gets or sets number of old daily summaries to keep")]
    HRESULT KeepOldDailySummaries([in] long newVal);
	
	[propget, id(10), helpstring("Gets or sets number of old Monthly summaries to keep")]
    HRESULT KeepOldMonthlySummaries([out, retval] long *pVal);
    [propput, id(10), helpstring("Gets or sets number of old Monthly summaries to keep")]
    HRESULT KeepOldMonthlySummaries([in] long newVal);
	
};
	
[
object,
uuid(4EF49809-B5D0-434d-9D32-16CBBEF00A2C),
dual,
nonextensible,
helpstring("SQL Server Reporting Services configuration settings"),
pointer_default(unique)
]
interface IFPCReportingServicesProperties : IFPCPersist
{
	[propget, id(0), helpstring("Gets or sets a value from the FpcSQLAuthType enumerated type that specifies the type of authentication that will be used to connect to the SQL Server database"), hidden]
    HRESULT SQLAuthType([out, retval] FpcSQLAuthType *pVal);
    [propput, id(0), helpstring("Gets or sets a value from the FpcSQLAuthType enumerated type that specifies the type of authentication that will be used to connect to the SQL Server database"), hidden]
    HRESULT SQLAuthType([in] FpcSQLAuthType newVal);
	
	[propget, id(1), helpstring("Gets or sets the name of the SQL Server computer used for reporting"), hidden]
    HRESULT SQLServerName([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the name of the SQL Server computer used for reporting"), hidden]
    HRESULT SQLServerName([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets the SQL Server port used for reporting"), hidden]
    HRESULT SQLServerPort([out, retval] long *pVal);
    [propput, id(2), helpstring("Gets or sets the SQL Server port used for reporting"), hidden]
    HRESULT SQLServerPort([in] long newVal);
	
	[propget, id(3), helpstring("Gets or sets the name of the SQL Server database used for reporting"), hidden]
    HRESULT SQLDatabase([out, retval] BSTR *pVal);
    [propput, id(3), helpstring("Gets or sets the name of the SQL Server database used for reporting"), hidden]
    HRESULT SQLDatabase([in] BSTR newVal);
	
	[propget, id(4), helpstring("Gets or sets a Boolean value that indicates whether a secure channel that enforces encryption is to be used when connecting to the SQL Server database"), hidden]
    HRESULT SQLForceEncryption([out, retval] VARIANT_BOOL *pVal);
    [propput, id(4), helpstring("Gets or sets a Boolean value that indicates whether a secure channel that enforces encryption is to be used when connecting to the SQL Server database"), hidden]
    HRESULT SQLForceEncryption([in] VARIANT_BOOL newVal);
	
	[propget, id(5), helpstring("Gets or sets the Report Server execution endpoint URL"), hidden]
    HRESULT ReportServerExecutionUrl([out, retval] BSTR *pVal);
    [propput, id(5), helpstring("Gets or sets the Report Server execution endpoint URL"), hidden]
    HRESULT ReportServerExecutionUrl([in] BSTR newVal);
	
	[propget, id(6), helpstring("Gets or sets the Report Server management endpoint URL"), hidden]
    HRESULT ReportServerManagementUrl([out, retval] BSTR *pVal);
    [propput, id(6), helpstring("Gets or sets the Report Server management endpoint URL"), hidden]
    HRESULT ReportServerManagementUrl([in] BSTR newVal);
	
	[propget, id(7), helpstring("Gets or sets the Report Server virtual directory name"), hidden]
    HRESULT ReportServerVirtualDirectoryName([out, retval] BSTR *pVal);
    [propput, id(7), helpstring("Gets or sets the Report Server virtual directory name"), hidden]
    HRESULT ReportServerVirtualDirectoryName([in] BSTR newVal);
	
	[propget, id(8), helpstring("Gets or sets the Reporting Services configuration identifier")]
    HRESULT ReportingServicesConfigurationId([out, retval] BSTR *pVal);
    [propput, id(8), helpstring("Gets or sets the Reporting Services configuration identifier")]
    HRESULT ReportingServicesConfigurationId([in] BSTR newVal);
	
	[propget, id(9), helpstring("Gets or sets a Boolean value that indicates whether Forefront TMG uses a user-defined configuration for the Reporting Services"), hidden]
    HRESULT ReportingServicesConfigurationUserDefined([out, retval] VARIANT_BOOL *pVal);
    [propput, id(9), helpstring("Gets or sets a Boolean value that indicates whether Forefront TMG uses a user-defined configuration for the Reporting Services"), hidden]
    HRESULT ReportingServicesConfigurationUserDefined([in] VARIANT_BOOL newVal);
	
	[propget, id(10), helpstring("Gets or sets the reporting data source connection string"), hidden]
    HRESULT ReportingDataSourceConnectionString([out, retval] BSTR *pVal);
    [propput, id(10), helpstring("Gets or sets the reporting data source connection string"), hidden]
    HRESULT ReportingDataSourceConnectionString([in] BSTR newVal);
	
	[propget, id(11), helpstring("Gets the credentials needed to connect to the report database of the Report Server")]
    HRESULT Credentials([out, retval] IFPCCredentials **pVal);
	
	[propget, id(12), helpstring("Gets an FPCRef object that references the FPCServer object representing the Forefront TMG computer that manages the Reporting Services configuration")]
    HRESULT ReportingServicesManagerServer([out, retval] IFPCRef **pVal);
	
	[id(13), helpstring("Sets the name of the FPCServer object representing the Forefront TMG computer that manages the Reporting Services configuration")]
          HRESULT SetReportingServicesManagerServer([in] BSTR bstrServerName);
        
    
	[id(14), helpstring("Gets a Boolean value that indicates whether the local computer is the manager server"), hidden]
          HRESULT IsManagerServerCurrentMachine([out,retval] VARIANT_BOOL* pLocal);
        
    
	[propget, id(15), helpstring("Gets the credentials needed to configure the Report Server"), hidden]
    HRESULT ConfigurationCredentials([out, retval] IFPCCredentials **pVal);
	
};
	
[
object,
uuid(F98A4FBC-A290-408E-9170-FED1CC4DB403),
dual,
nonextensible,
helpstring("A ready report"),
pointer_default(unique)
]
interface IFPCReadyReport : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the ready report")]
    HRESULT Name([out, retval] BSTR *pVal);
	
	[propget, id(1), helpstring("Gets the period type of the ready report")]
    HRESULT PeriodType([out, retval] FpcReportJobPeriodType *pVal);
	
	[propget, id(2), helpstring("Gets the start date of the ready report")]
    HRESULT StartDate([out, retval] DATE *pVal);
	
	[propget, id(3), helpstring("Gets the end date of the ready report")]
    HRESULT EndDate([out, retval] DATE *pVal);
	
	[propget, id(4), helpstring("Gets the Status of the ready report")]
    HRESULT Status([out, retval] FpcReportStatus *pVal);
	
	[propget, id(5), helpstring("Gets the time the report was created")]
    HRESULT CreatedTime([out, retval] DATE *pVal);
	
	[id(6), helpstring("Save the report in an HTML format to the specified directory"), hidden]
          HRESULT SaveAsHTML([in] BSTR bstrDirectory,
              [in,defaultvalue(NULL)] BSTR UserName,
              [in,defaultvalue(NULL)] BSTR Password);
        
    
};
	
[
object,
uuid(9A858BD8-B826-47E8-BA2F-2A15091E07A0),
dual,
nonextensible,
helpstring("Collection of ready reports"),
pointer_default(unique)
]
interface IFPCReadyReports : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( long Index,
              [out,retval] IFPCReadyReport** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_REMOVE), helpstring("Removes a ready report from the collection")]
          HRESULT Remove( long Index);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
};
	
[
object,
uuid(CA75F94A-1382-4385-B6A6-44B421A4C3BC),
dual,
helpstring("A report summary definition"),
pointer_default(unique)
]
interface IFPCReportSummaryDefinition : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the report summary definition")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the report summary definition")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the SQL table creation statement for the report summary definition")]
    HRESULT TableCreationStatement([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the SQL table creation statement for the report summary definition")]
    HRESULT TableCreationStatement([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets the SQL summary generation statement for the report summary definition")]
    HRESULT DataGenerationStatement([out, retval] BSTR *pVal);
    [propput, id(2), helpstring("Gets or sets the SQL summary generation statement for the report summary definition")]
    HRESULT DataGenerationStatement([in] BSTR newVal);
	
	[propget, id(3), helpstring("Gets or sets the SQL execution statement for the report summary definition")]
    HRESULT ExecutionStatement([out, retval] BSTR *pVal);
    [propput, id(3), helpstring("Gets or sets the SQL execution statement for the report summary definition")]
    HRESULT ExecutionStatement([in] BSTR newVal);
	
	[propget, id(4), helpstring("Gets or sets the SQL summary cleanup statement for the report summary definition")]
    HRESULT CleanupStatement([out, retval] BSTR *pVal);
    [propput, id(4), helpstring("Gets or sets the SQL summary cleanup statement for the report summary definition")]
    HRESULT CleanupStatement([in] BSTR newVal);
	
	[propget, id(5), helpstring("Gets or sets the SQL summary aggregation statement for the report summary definition")]
    HRESULT AggregationStatement([out, retval] BSTR *pVal);
    [propput, id(5), helpstring("Gets or sets the SQL summary aggregation statement for the report summary definition")]
    HRESULT AggregationStatement([in] BSTR newVal);
	
};
	
[
object,
uuid(F72E5526-BABA-4fdf-8B42-4D5358BAABA9),
dual,
nonextensible,
helpstring("A Report Definition Language (RDL) report definition"),
pointer_default(unique)
]
interface IFPCReportSummaryDefinition2 : IFPCReportSummaryDefinition
{
	[propget, id(6), helpstring("Gets or sets the SQL summary aggregation cleanup statement for the report summary definition")]
    HRESULT AggregationCleanupStatement([out, retval] BSTR *pVal);
    [propput, id(6), helpstring("Gets or sets the SQL summary aggregation cleanup statement for the report summary definition")]
    HRESULT AggregationCleanupStatement([in] BSTR newVal);
	
};
	
[
object,
uuid(1EAFD18B-38A8-4896-BD48-2AB6DD7F7185),
dual,
nonextensible,
helpstring("Collection of report summary definitions"),
pointer_default(unique)
]
interface IFPCReportSummaryDefinitions : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns the requested FPCReportSummaryDefinition object from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCReportSummaryDefinition** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Adds a new FPCReportSummaryDefinition object to the collection")]
          HRESULT Add([in] BSTR Name,
              [out,retval] IFPCReportSummaryDefinition** ppNewReportSummaryDefinition);
        
    
	[id(DISPID_REMOVE), helpstring("Removes the specified FPCReportSummaryDefinition object from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
};
	
[
object,
uuid(83457E76-61D6-11DB-8373-B622A1EF5492),
dual,
nonextensible,
helpstring("A Report Definition Language (RDL) report definition"),
pointer_default(unique)
]
interface IFPCRdlReportDefinition : IDispatch
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the Report Definition Language (RDL) report definition")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the Report Definition Language (RDL) report definition")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the display name of the Report Definition Language (RDL) report definition")]
    HRESULT DisplayName([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the display name of the Report Definition Language (RDL) report definition")]
    HRESULT DisplayName([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets the contents of the Report Definition Language (RDL) report definition")]
    HRESULT Contents([out, retval] BSTR *pVal);
    [propput, id(2), helpstring("Gets or sets the contents of the Report Definition Language (RDL) report definition")]
    HRESULT Contents([in] BSTR newVal);
	
	[propget, id(3), helpstring("Gets or sets the SQL data generation statement for the Report Definition Language (RDL) report definition")]
    HRESULT DataGenerationStatement([out, retval] BSTR *pVal);
    [propput, id(3), helpstring("Gets or sets the SQL data generation statement for the Report Definition Language (RDL) report definition")]
    HRESULT DataGenerationStatement([in] BSTR newVal);
	
	[propget, id(4), helpstring("Gets or sets the SQL metadata generation statement for the Report Definition Language (RDL) report definition")]
    HRESULT MetadataGenerationStatement([out, retval] BSTR *pVal);
    [propput, id(4), helpstring("Gets or sets the SQL metadata generation statement for the Report Definition Language (RDL) report definition")]
    HRESULT MetadataGenerationStatement([in] BSTR newVal);
	
	[propget, id(5), helpstring("Gets or sets the SQL cleanup statement for the Report Definition Language (RDL) report definition")]
    HRESULT CleanupStatement([out, retval] BSTR *pVal);
    [propput, id(5), helpstring("Gets or sets the SQL cleanup statement for the Report Definition Language (RDL) report definition")]
    HRESULT CleanupStatement([in] BSTR newVal);
	
	[propget, id(6), helpstring("Gets an FPCRefs collection that contains objects representing the Report Definition Language (RDL) parameterss for this report")]
    HRESULT ReportParameters([out, retval] IFPCRefs **pVal);
	
};
	
[
object,
uuid(7BD5F954-61D6-11DB-8373-B622A1EF5492),
dual,
nonextensible,
helpstring("Collection of objects representing Report Definition Language (RDL) report definitions"),
pointer_default(unique)
]
interface IFPCRdlReportDefinitions : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns requested FPCRdlReportDefinition object from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCRdlReportDefinition** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Adds a new FPCRdlReportDefinition object to the collection")]
          HRESULT Add([in] BSTR Name,
              [out,retval] IFPCRdlReportDefinition** ppNewRdlReportDefinition);
        
    
	[id(DISPID_REMOVE), helpstring("Removes the specified FPCRdlReportDefinition object from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
};
	
[
object,
uuid(35558990-88CD-481c-860E-3D3459BF5B95),
dual,
nonextensible,
helpstring("A report parameter reference object"),
pointer_default(unique)
]
interface IFPCRdlReportParameterInstance : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the report ref object")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the report ref object")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the value of the Report Definition Language (RDL) report parameter")]
    HRESULT Value([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the value of the Report Definition Language (RDL) report parameter")]
    HRESULT Value([in] BSTR newVal);
	
	[id(2), helpstring("Sets the name of the Rdl parameter that is referenced by this object")]
          HRESULT SetReportParameter([in] BSTR CategoryName,
              [in] BSTR RdlName,
              [in] BSTR ParameterName);
        
    
	[propget, id(3), helpstring("Gets an FPCRef object representing the Report Definition Language (RDL) parameter of this objects")]
    HRESULT RdlReportParameter([out, retval] IFPCRef **pVal);
	
	[propget, id(4), helpstring("Gets an FPCRef object representing the Report Definition Language (RDL) definition of this objects")]
    HRESULT RdlReportDefinition([out, retval] IFPCRef **pVal);
	
	[propget, id(5), helpstring("Gets an FPCRef object representing the Report Definition Language (RDL) category of this objects")]
    HRESULT RdlReportCategory([out, retval] IFPCRef **pVal);
	
};
	
[
object,
uuid(DB208634-B163-4EAE-B6FD-2A96F4440534),
dual,
nonextensible,
helpstring("Collection of report parameter reference objects"),
pointer_default(unique)
]
interface IFPCRdlReportParameterInstances : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns requested FPCRdlReportParameterInstance object from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCRdlReportParameterInstance** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Adds a new FPCRdlReportParameterInstance object to the collection")]
          HRESULT Add([in] BSTR Name,
              [in] BSTR RdlCategoryName,
              [in] BSTR RdlReportName,
              [in] BSTR RdlParameterName,
              [out,retval] IFPCRdlReportParameterInstance** ppNewRdlReportRef);
        
    
	[id(DISPID_REMOVE), helpstring("Removes the specified FPCRdlReportParameterInstance object from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(1), helpstring("Removes all of the RdlReportParameterInstance items from the object")]
          HRESULT RemoveAll();
        
    
};
	
[
object,
uuid(E2DA0F16-43C6-4989-87B4-1BFDD827B9D8),
dual,
nonextensible,
helpstring("A Report Definition Language (RDL) report parameter allowed value"),
pointer_default(unique)
]
interface IFPCRdlReportParameterPermittedValue : IDispatch
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the report parameter allowed value")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the report parameter allowed value")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the value of the report parameter allowed value")]
    HRESULT Value([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the value of the report parameter allowed value")]
    HRESULT Value([in] BSTR newVal);
	
};
	
[
object,
uuid(631C18F7-1C10-41ad-90E8-B5255E698EB4),
dual,
nonextensible,
helpstring("Collection of objects representing report parameter allowed values"),
pointer_default(unique)
]
interface IFPCRdlReportParameterPermittedValues : IDispatch
{
	[id(DISPID_VALUE), helpstring("Returns requested FPCRdlReportParameterPermittedValue object from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCRdlReportParameterPermittedValue** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Adds a new FPCRdlReportParameterPermittedValue object to the collection")]
          HRESULT Add([in] BSTR Name,
              [out,retval] IFPCRdlReportParameterPermittedValue** ppNewRdlReportParameterPermittedValue);
        
    
	[id(DISPID_REMOVE), helpstring("Removes the specified FPCRdlReportParameterPermittedValue object from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
};
	
[
object,
uuid(2C7B2534-DCE9-42C0-BF08-968A21C45D28),
dual,
nonextensible,
helpstring("A Report Definition Language (RDL) report parameter"),
pointer_default(unique)
]
interface IFPCRdlReportParameter : IDispatch
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the Report Definition Language (RDL) report parameter")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the Report Definition Language (RDL) report parameter")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the default value of the Report Definition Language (RDL) report parameter")]
    HRESULT DefaultValue([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the default value of the Report Definition Language (RDL) report parameter")]
    HRESULT DefaultValue([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets the display name of the Report Definition Language (RDL) report parameter")]
    HRESULT DisplayName([out, retval] BSTR *pVal);
    [propput, id(2), helpstring("Gets or sets the display name of the Report Definition Language (RDL) report parameter")]
    HRESULT DisplayName([in] BSTR newVal);
	
	[propget, id(3), helpstring("Gets or sets the description of the Report Definition Language (RDL) report parameter")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(3), helpstring("Gets or sets the description of the Report Definition Language (RDL) report parameter")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(4), helpstring("Gets or sets the data type of the parameter")]
    HRESULT DataType([out, retval] FpcReportParameterDataType *pVal);
    [propput, id(4), helpstring("Gets or sets the data type of the parameter")]
    HRESULT DataType([in] FpcReportParameterDataType newVal);
	
	[propget, id(5), helpstring("Gets an RdlReportParameterPermittedValues collection that contains objects representing allowed values for this parameter")]
    HRESULT RdlReportParameterPermittedValues([out, retval] IFPCRdlReportParameterPermittedValues **pVal);
	
};
	
[
object,
uuid(92CC51C6-3E3E-4143-AEBE-1C2432617B15),
dual,
nonextensible,
helpstring("Collection of objects representing Report Definition Language (RDL) report parameters"),
pointer_default(unique)
]
interface IFPCRdlReportParameters : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns requested FPCRdlReportParameter object from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCRdlReportParameter** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Adds a new FPCRdlReportDefinition object to the collection")]
          HRESULT Add([in] BSTR Name,
              [out,retval] IFPCRdlReportParameter** ppNewRdlReportParameter);
        
    
	[id(DISPID_REMOVE), helpstring("Removes the specified FPCRdlReportParameter object from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
};
	
[
object,
uuid(854505E1-E6E5-4142-8DFF-C573C0085A78),
dual,
nonextensible,
helpstring("A report category"),
pointer_default(unique)
]
interface IFPCRdlReportCategory : IDispatch
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the report category")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the report category")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the display name of the report category")]
    HRESULT DisplayName([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the display name of the report category")]
    HRESULT DisplayName([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets an FPCRdlReportRefs collection that contains objects representing the Report Definition Language (RDL) definitions of the reports within this category")]
    HRESULT RdlReportRefs([out, retval] IFPCRdlReportRefs **pVal);
	
};
	
[
object,
uuid(F00525F3-9658-4E6E-8C91-C3C7A134956E),
dual,
nonextensible,
helpstring("Collection of objects representing report categories"),
pointer_default(unique)
]
interface IFPCRdlReportCategories : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns requested FPCRdlReportCategory object from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCRdlReportCategory** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Adds a new FPCRdlReportCategory object to the collection")]
          HRESULT Add([in] BSTR Name,
              [out,retval] IFPCRdlReportCategory** ppNewRdlReportCategory);
        
    
	[id(DISPID_REMOVE), helpstring("Removes the specified FPCRdlReportCategory object from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
};
	
[
object,
uuid(E8CF331B-1BA6-4389-8D4E-A96EE27AB188),
dual,
nonextensible,
helpstring("A report reference object"),
pointer_default(unique)
]
interface IFPCRdlReportRef : IDispatch
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the report ref object")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the report ref object")]
    HRESULT Name([in] BSTR newVal);
	
	[id(1), helpstring("Sets the name of the Rdl report definition that is referenced by this object")]
          HRESULT SetReportRdl([in] BSTR bstrRdlName);
        
    
	[propget, id(2), helpstring("Gets an FPCRef object representing the Report Definition Language (RDL) definition of this objects")]
    HRESULT RdlReportDefinition([out, retval] IFPCRef **pVal);
	
};
	
[
object,
uuid(F254C606-B8A2-4cb1-ADFE-ACED5E77DEBF),
dual,
nonextensible,
helpstring("Collection of report reference objects"),
pointer_default(unique)
]
interface IFPCRdlReportRefs : IDispatch
{
	[id(DISPID_VALUE), helpstring("Returns requested FPCRdlReportRef object from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCRdlReportRef** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Adds a new FPCRdlReportRef object to the collection")]
          HRESULT Add([in] BSTR Name,
              [out,retval] IFPCRdlReportRef** ppNewRdlReportRef);
        
    
	[id(DISPID_REMOVE), helpstring("Removes the specified FPCRdlReportRef object from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
};
	
[
object,
uuid(3481F751-AFDE-40C8-A61B-FFFC99234550),
dual,
helpstring("Report properties of all reports"),
pointer_default(unique)
]
interface IFPCReportsProperties : IFPCPersist
{
	[propget, id(1), helpstring("Summary reports properties")]
    HRESULT SummaryReports([out, retval] IFPCSummaryReports **pVal);
	
	[propget, id(2), helpstring("WebUsage reports properties")]
    HRESULT WebUsageReports([out, retval] IFPCWebUsageReports **pVal);
	
	[propget, id(3), helpstring("ApplicationUsage reports properties")]
    HRESULT ApplicationUsageReports([out, retval] IFPCApplicationUsageReports **pVal);
	
	[propget, id(4), helpstring("Traffic reports properties")]
    HRESULT TrafficReports([out, retval] IFPCTrafficReports **pVal);
	
	[propget, id(5), helpstring("Security reports properties")]
    HRESULT SecurityReports([out, retval] IFPCSecurityReports **pVal);
	
};
	
[
hidden,
object,
uuid(C37A7295-BBB3-48c7-A4C0-DCA7873B5336),
dual,
nonextensible,
helpstring("Daily summaries configuration"),
pointer_default(unique)
]
interface IFPCEEReportsProperties : IFPCReportsProperties
{
	[propget, id(6), helpstring("Gets or sets number of reports to keep per period type")]
    HRESULT KeepOldReportsPerPeriodType([out, retval] long *pVal);
    [propput, id(6), helpstring("Gets or sets number of reports to keep per period type")]
    HRESULT KeepOldReportsPerPeriodType([in] long newVal);
	
};
	
[
object,
uuid(E06ECF1C-813B-40DB-AF24-3B33E8E57269),
dual,
nonextensible,
helpstring("Summary reports properties"),
pointer_default(unique)
]
interface IFPCSummaryReports : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets report top protcols number")]
    HRESULT ProtocolsReportTopNumber([out, retval] long *pVal);
    [propput, id(1), helpstring("Gets or sets report top protcols number")]
    HRESULT ProtocolsReportTopNumber([in] long newVal);
	
	[propget, id(2), helpstring("Gets or sets report top sites sort order property")]
    HRESULT SitesReportSortOrder([out, retval] FpcTopSitesReportSortOrder *pVal);
    [propput, id(2), helpstring("Gets or sets report top sites sort order property")]
    HRESULT SitesReportSortOrder([in] FpcTopSitesReportSortOrder newVal);
	
	[propget, id(3), helpstring("Gets or sets report top sites number")]
    HRESULT SitesReportTopNumber([out, retval] long *pVal);
    [propput, id(3), helpstring("Gets or sets report top sites number")]
    HRESULT SitesReportTopNumber([in] long newVal);
	
	[propget, id(4), helpstring("Gets or sets report top users sort order property")]
    HRESULT UsersReportSortOrder([out, retval] FpcTopUsersReportSortOrder *pVal);
    [propput, id(4), helpstring("Gets or sets report top users sort order property")]
    HRESULT UsersReportSortOrder([in] FpcTopUsersReportSortOrder newVal);
	
	[propget, id(5), helpstring("Gets or sets report top users number")]
    HRESULT UsersReportTopNumber([out, retval] long *pVal);
    [propput, id(5), helpstring("Gets or sets report top users number")]
    HRESULT UsersReportTopNumber([in] long newVal);
	
	[propget, id(6), helpstring("Gets or sets cache report sort order property")]
    HRESULT CacheReportSortOrder([out, retval] FpcCacheReportSortOrder *pVal);
    [propput, id(6), helpstring("Gets or sets cache report sort order property")]
    HRESULT CacheReportSortOrder([in] FpcCacheReportSortOrder newVal);
	
};
	
[
object,
uuid(BDDE9736-DEF9-47B0-8F44-367C23B08BED),
dual,
nonextensible,
helpstring("Web Usage reports properties"),
pointer_default(unique)
]
interface IFPCWebUsageReports : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets report top protcols sort order property")]
    HRESULT ProtocolsReportSortOrder([out, retval] FpcTopWebProtocolReportSortOrder *pVal);
    [propput, id(1), helpstring("Gets or sets report top protcols sort order property")]
    HRESULT ProtocolsReportSortOrder([in] FpcTopWebProtocolReportSortOrder newVal);
	
	[propget, id(2), helpstring("Gets or sets report top protcols number")]
    HRESULT ProtocolsReportTopNumber([out, retval] long *pVal);
    [propput, id(2), helpstring("Gets or sets report top protcols number")]
    HRESULT ProtocolsReportTopNumber([in] long newVal);
	
	[propget, id(3), helpstring("Gets or sets report top sites sort order property")]
    HRESULT SitesReportSortOrder([out, retval] FpcTopSitesReportSortOrder *pVal);
    [propput, id(3), helpstring("Gets or sets report top sites sort order property")]
    HRESULT SitesReportSortOrder([in] FpcTopSitesReportSortOrder newVal);
	
	[propget, id(4), helpstring("Gets or sets report top sites number")]
    HRESULT SitesReportTopNumber([out, retval] long *pVal);
    [propput, id(4), helpstring("Gets or sets report top sites number")]
    HRESULT SitesReportTopNumber([in] long newVal);
	
	[propget, id(5), helpstring("Gets or sets report top users sort order property")]
    HRESULT UsersReportSortOrder([out, retval] FpcTopUsersReportSortOrder *pVal);
    [propput, id(5), helpstring("Gets or sets report top users sort order property")]
    HRESULT UsersReportSortOrder([in] FpcTopUsersReportSortOrder newVal);
	
	[propget, id(6), helpstring("Gets or sets report top users number")]
    HRESULT UsersReportTopNumber([out, retval] long *pVal);
    [propput, id(6), helpstring("Gets or sets report top users number")]
    HRESULT UsersReportTopNumber([in] long newVal);
	
	[propget, id(7), helpstring("Gets or sets object types report sort order property")]
    HRESULT ObjectTypesReportSortOrder([out, retval] FpcObjectTypesReportSortOrder *pVal);
    [propput, id(7), helpstring("Gets or sets object types report sort order property")]
    HRESULT ObjectTypesReportSortOrder([in] FpcObjectTypesReportSortOrder newVal);
	
	[propget, id(8), helpstring("Gets or sets object types report number")]
    HRESULT ObjectTypesReportTopNumber([out, retval] long *pVal);
    [propput, id(8), helpstring("Gets or sets object types report number")]
    HRESULT ObjectTypesReportTopNumber([in] long newVal);
	
	[propget, id(9), helpstring("Gets or sets browsers report sort order property")]
    HRESULT BrowsersReportSortOrder([out, retval] FpcBrowsersReportSortOrder *pVal);
    [propput, id(9), helpstring("Gets or sets browsers report sort order property")]
    HRESULT BrowsersReportSortOrder([in] FpcBrowsersReportSortOrder newVal);
	
	[propget, id(10), helpstring("Gets or sets browsers report number")]
    HRESULT BrowsersReportTopNumber([out, retval] long *pVal);
    [propput, id(10), helpstring("Gets or sets browsers report number")]
    HRESULT BrowsersReportTopNumber([in] long newVal);
	
	[propget, id(11), helpstring("Gets or sets operating systems report sort order property")]
    HRESULT OperatingSystemsReportSortOrder([out, retval] FpcOperatingSystemsReportSortOrder *pVal);
    [propput, id(11), helpstring("Gets or sets operating systems report sort order property")]
    HRESULT OperatingSystemsReportSortOrder([in] FpcOperatingSystemsReportSortOrder newVal);
	
	[propget, id(12), helpstring("Gets or sets operating systems report number")]
    HRESULT OperatingSystemsReportTopNumber([out, retval] long *pVal);
    [propput, id(12), helpstring("Gets or sets operating systems report number")]
    HRESULT OperatingSystemsReportTopNumber([in] long newVal);
	
};
	
[
object,
uuid(B87DF456-0174-4A76-B9FB-BC3D09757EAF),
dual,
nonextensible,
helpstring("Applications Usage reports properties"),
pointer_default(unique)
]
interface IFPCApplicationUsageReports : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets report top protcols sort order property")]
    HRESULT ProtocolsReportSortOrder([out, retval] FpcTopAppProtocolReportSortOrder *pVal);
    [propput, id(1), helpstring("Gets or sets report top protcols sort order property")]
    HRESULT ProtocolsReportSortOrder([in] FpcTopAppProtocolReportSortOrder newVal);
	
	[propget, id(2), helpstring("Gets or sets report top protcols number")]
    HRESULT ProtocolsReportTopNumber([out, retval] long *pVal);
    [propput, id(2), helpstring("Gets or sets report top protcols number")]
    HRESULT ProtocolsReportTopNumber([in] long newVal);
	
	[propget, id(3), helpstring("Gets or sets report top users sort order property")]
    HRESULT UsersReportSortOrder([out, retval] FpcTopUsersReportSortOrder *pVal);
    [propput, id(3), helpstring("Gets or sets report top users sort order property")]
    HRESULT UsersReportSortOrder([in] FpcTopUsersReportSortOrder newVal);
	
	[propget, id(4), helpstring("Gets or sets report top users number")]
    HRESULT UsersReportTopNumber([out, retval] long *pVal);
    [propput, id(4), helpstring("Gets or sets report top users number")]
    HRESULT UsersReportTopNumber([in] long newVal);
	
	[propget, id(6), helpstring("Gets or sets applications report sort order property")]
    HRESULT ApplicationsReportSortOrder([out, retval] FpcTopAppsReportSortOrder *pVal);
    [propput, id(6), helpstring("Gets or sets applications report sort order property")]
    HRESULT ApplicationsReportSortOrder([in] FpcTopAppsReportSortOrder newVal);
	
	[propget, id(7), helpstring("Gets or sets applications report number")]
    HRESULT ApplicationsReportTopNumber([out, retval] long *pVal);
    [propput, id(7), helpstring("Gets or sets applications report number")]
    HRESULT ApplicationsReportTopNumber([in] long newVal);
	
	[propget, id(8), helpstring("Gets or sets destinations report sort order property")]
    HRESULT DestinationsReportSortOrder([out, retval] FpcTopDestinationsReportSortOrder *pVal);
    [propput, id(8), helpstring("Gets or sets destinations report sort order property")]
    HRESULT DestinationsReportSortOrder([in] FpcTopDestinationsReportSortOrder newVal);
	
	[propget, id(9), helpstring("Gets or sets destinations report number")]
    HRESULT DestinationsReportTopNumber([out, retval] long *pVal);
    [propput, id(9), helpstring("Gets or sets destinations report number")]
    HRESULT DestinationsReportTopNumber([in] long newVal);
	
	[propget, id(10), helpstring("Gets or sets operating systems report sort order property")]
    HRESULT OperatingSystemsReportSortOrder([out, retval] FpcOperatingSystemsReportSortOrder *pVal);
    [propput, id(10), helpstring("Gets or sets operating systems report sort order property")]
    HRESULT OperatingSystemsReportSortOrder([in] FpcOperatingSystemsReportSortOrder newVal);
	
	[propget, id(11), helpstring("Gets or sets operating systems report number")]
    HRESULT OperatingSystemsReportTopNumber([out, retval] long *pVal);
    [propput, id(11), helpstring("Gets or sets operating systems report number")]
    HRESULT OperatingSystemsReportTopNumber([in] long newVal);
	
};
	
[
object,
uuid(0EE990E1-C774-420F-8DE0-04F52D944BE0),
dual,
nonextensible,
helpstring("Traffic & Utilization reports properties"),
pointer_default(unique)
]
interface IFPCTrafficReports : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets report top protcols number")]
    HRESULT ProtocolsReportTopNumber([out, retval] long *pVal);
    [propput, id(1), helpstring("Gets or sets report top protcols number")]
    HRESULT ProtocolsReportTopNumber([in] long newVal);
	
	[propget, id(2), helpstring("Gets or sets cache report sort order property")]
    HRESULT CacheReportSortOrder([out, retval] FpcCacheReportSortOrder *pVal);
    [propput, id(2), helpstring("Gets or sets cache report sort order property")]
    HRESULT CacheReportSortOrder([in] FpcCacheReportSortOrder newVal);
	
};
	
[
object,
uuid(E2DA8773-9216-4C96-BE44-AD644889499E),
dual,
nonextensible,
helpstring("Security reports properties"),
pointer_default(unique)
]
interface IFPCSecurityReports : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets dropped packets report number")]
    HRESULT DroppedPacketsReportTopNumber([out, retval] long *pVal);
    [propput, id(1), helpstring("Gets or sets dropped packets report number")]
    HRESULT DroppedPacketsReportTopNumber([in] long newVal);
	
	[propget, id(2), helpstring("Gets or sets authorization failures report top  number")]
    HRESULT AuthorizationFailuresReportTopNumber([out, retval] long *pVal);
    [propput, id(2), helpstring("Gets or sets authorization failures report top  number")]
    HRESULT AuthorizationFailuresReportTopNumber([in] long newVal);
	
};
	
[
object,
uuid(754B6D8E-41CC-4E52-94B8-3F3E70742BC1),
dual,
nonextensible,
helpstring("A computer"),
pointer_default(unique)
]
interface IFPCComputer : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the computer")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the computer")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the description of the computer")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the description of the computer")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets the IP address")]
    HRESULT IPAddress([out, retval] BSTR *pVal);
    [propput, id(2), helpstring("Gets or sets the IP address")]
    HRESULT IPAddress([in] BSTR newVal);
	
};
	
[
object,
uuid(83EF2164-4F86-4FC5-B8B4-BCBB2BFADB7F),
dual,
nonextensible,
helpstring("Collection of computers"),
pointer_default(unique)
]
interface IFPCComputers : IFPCPersist
{
	[id(DISPID_ADD), helpstring("Adds a computer to the collection")]
          HRESULT Add([in] BSTR Name,
              [in] BSTR IPAddress,
              [out,retval] IFPCComputer** ppNewItem);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a computer from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCComputer** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

};
	
[
object,
uuid(D06BE508-1017-4FD2-8505-AD567482BD08),
dual,
helpstring("An address range"),
pointer_default(unique)
]
interface IFPCAddressRange : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the address range")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the address range")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the description of the address range")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the description of the address range")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets the lower bound of the IP range")]
    HRESULT IP_From([out, retval] BSTR *pVal);
	
	[propget, id(3), helpstring("Gets the upper bound of the IP range")]
    HRESULT IP_To([out, retval] BSTR *pVal);
	
	[id(4), helpstring("Sets the bounds of the IP range")]
          HRESULT SetIps( BSTR IP_From,
               BSTR IP_To);
        
    
};
	
[
object,
uuid(B09E0423-9542-42f2-9E92-E6E3DBFB4DDE),
dual,
nonextensible,
helpstring("An address range"),
pointer_default(unique)
]
interface IFPCAddressRange2 : IFPCAddressRange
{
	[propget, id(5), helpstring("Gets whether the computer set is a preinstalled rule element that cannot be deleted")]
    HRESULT Predefined([out, retval] VARIANT_BOOL *pVal);
	
};
	
[
object,
uuid(167A0427-7119-48A9-8B7B-A8E47715643E),
dual,
nonextensible,
helpstring("Collection of address ranges"),
pointer_default(unique)
]
interface IFPCAddressRanges : IFPCPersist
{
	[id(DISPID_ADD), helpstring("Adds an address range to the collection")]
          HRESULT Add([in] BSTR Name,
              [in] BSTR IP_From,
              [in] BSTR IP_To,
              [out,retval] IFPCAddressRange** ppNewItem);
        
    
	[id(DISPID_REMOVE), helpstring("Removes an address range from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCAddressRange** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

};
	
[
object,
uuid(89487DE7-1887-4F49-B981-608035808C2A),
dual,
nonextensible,
helpstring("A subnet"),
pointer_default(unique)
]
interface IFPCSubnet : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the subnet")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the subnet")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the description of the subnet")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the description of the subnet")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets the IP address")]
    HRESULT IPAddress([out, retval] BSTR *pVal);
    [propput, id(2), helpstring("Gets or sets the IP address")]
    HRESULT IPAddress([in] BSTR newVal);
	
	[propget, id(3), helpstring("Gets or sets the IP mask")]
    HRESULT IPMask([out, retval] BSTR *pVal);
    [propput, id(3), helpstring("Gets or sets the IP mask")]
    HRESULT IPMask([in] BSTR newVal);
	
};
	
[
object,
uuid(BC46F650-7B5E-486D-B0D5-1A71670B912F),
dual,
nonextensible,
helpstring("Collection of subnets"),
pointer_default(unique)
]
interface IFPCSubnets : IFPCPersist
{
	[id(DISPID_ADD), helpstring("Adds a subnet to the collection")]
          HRESULT Add([in] BSTR Name,
              [in] BSTR IPAddress,
              [in] BSTR IPMask,
              [out,retval] IFPCSubnet** ppNewItem);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a subnet from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCSubnet** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

};
	
[
object,
uuid(9226C896-D0BE-4A58-ADF3-5B4132BE47D9),
dual,
nonextensible,
helpstring("Collection of Internet service providers (ISPs)"),
pointer_default(unique)
]
interface IFPCISPs : IFPCPersist
{
	[id(DISPID_ADD), helpstring("Adds an Internet service provider (ISP) to the collection")]
          HRESULT Add([in] BSTR Name,
              [in] BSTR GatewayIPAddress,
              [in] BSTR GatewaySubnetMask,
              [out,retval] IFPCISP** ppNewItem);
        
    
	[id(DISPID_REMOVE), helpstring("Removes an Internet service provider (ISP) from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Returns the requested Internet service provider (ISP) from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCISP** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

};
	
[
object,
uuid(FF24989E-E7EB-43B8-AD0D-DD9159652828),
dual,
nonextensible,
helpstring("An Internet service provider (ISP)"),
pointer_default(unique)
]
interface IFPCISP : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the Internet service provider (ISP)")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the Internet service provider (ISP)")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the description of the Internet service provider (ISP)")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the description of the Internet service provider (ISP)")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets the gateway IP address")]
    HRESULT GatewayIPAddress([out, retval] BSTR *pVal);
    [propput, id(2), helpstring("Gets or sets the gateway IP address")]
    HRESULT GatewayIPAddress([in] BSTR newVal);
	
	[propget, id(3), helpstring("Gets or sets the subnet mask of the gateway")]
    HRESULT GatewaySubnetMask([out, retval] BSTR *pVal);
    [propput, id(3), helpstring("Gets or sets the subnet mask of the gateway")]
    HRESULT GatewaySubnetMask([in] BSTR newVal);
	
	[propget, id(4), helpstring("Gets or sets the load balancing factor")]
    HRESULT LoadBalancingFactor([out, retval] long *pVal);
    [propput, id(4), helpstring("Gets or sets the load balancing factor")]
    HRESULT LoadBalancingFactor([in] long newVal);
	
	[propget, id(5), helpstring("Gets or sets a value from the FpcIspLinkPriority enumerated type that specifies the link priority")]
    HRESULT LinkPriority([out, retval] FpcIspLinkPriority *pVal);
    [propput, id(5), helpstring("Gets or sets a value from the FpcIspLinkPriority enumerated type that specifies the link priority")]
    HRESULT LinkPriority([in] FpcIspLinkPriority newVal);
	
	[propget, id(6), helpstring("Get the IP address range exceptions")]
    HRESULT ExplicitRoute([out, retval] IFPCSelectionIPs **pVal);
	
	[propget, id(7), helpstring("Gets or sets a value from the FpcIspLinkStatus enumerated type that specifies the link connectivity status")]
    HRESULT LinkConnectivityStatus([out, retval] FpcIspLinkStatus *pVal);
    [propput, id(7), helpstring("Gets or sets a value from the FpcIspLinkStatus enumerated type that specifies the link connectivity status")]
    HRESULT LinkConnectivityStatus([in] FpcIspLinkStatus newVal);
	
	[propget, id(8), helpstring("Gets a value from the FpcLinkStatus enumerated type that specifies the link online connectivity status")]
    HRESULT OnlineConnectivityStatus([out, retval] FpcLinkStatus *pVal);
	
	[propget, id(9), helpstring("Gets the link up time in milliseconds")]
    HRESULT UpTime([out, retval] LONGLONG *pVal);
	
	[propget, id(10), helpstring("Gets the link transfer rate in bytes per second")]
    HRESULT TransferRate([out, retval] LONGLONG *pVal);
	
};
	
[
object,
uuid(79E3357B-C5E5-43B1-A953-6406722D77E6),
dual,
nonextensible,
helpstring("Internet service provider (ISP) redundancy configuration"),
pointer_default(unique)
]
interface IFPCISPRedundancyConfig : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets a value from the FpcIspRedundancyPolicy enumerated type that specifies the Internet service provider (ISP) redundancy policy")]
    HRESULT IspRedundancyPolicy([out, retval] FpcIspRedundancyPolicy *pVal);
    [propput, id(1), helpstring("Gets or sets a value from the FpcIspRedundancyPolicy enumerated type that specifies the Internet service provider (ISP) redundancy policy")]
    HRESULT IspRedundancyPolicy([in] FpcIspRedundancyPolicy newVal);
	
	[propget, id(2), helpstring("Gets or sets the minimal time before Forefront TMG will resume using an Internet service provider (ISP) link")]
    HRESULT MinimalResumeTime([out, retval] long *pVal);
    [propput, id(2), helpstring("Gets or sets the minimal time before Forefront TMG will resume using an Internet service provider (ISP) link")]
    HRESULT MinimalResumeTime([in] long newVal);
	
	[propget, id(3), helpstring("Gets or sets the time between two successive connectivity verification tests when an Internet service provider (ISP) link is available")]
    HRESULT TestIntervalLinkAvailable([out, retval] long *pVal);
    [propput, id(3), helpstring("Gets or sets the time between two successive connectivity verification tests when an Internet service provider (ISP) link is available")]
    HRESULT TestIntervalLinkAvailable([in] long newVal);
	
	[propget, id(4), helpstring("Gets or sets the time between two successive connectivity verification tests when an Internet service provider (ISP) link is unavailable")]
    HRESULT TestIntervalLinkUnavailable([out, retval] long *pVal);
    [propput, id(4), helpstring("Gets or sets the time between two successive connectivity verification tests when an Internet service provider (ISP) link is unavailable")]
    HRESULT TestIntervalLinkUnavailable([in] long newVal);
	
	[propget, id(5), helpstring("Gets or sets the number of successive connectivity verification successes before an Internet service provider (ISP) link is considered available")]
    HRESULT SuccessesToAvailable([out, retval] long *pVal);
    [propput, id(5), helpstring("Gets or sets the number of successive connectivity verification successes before an Internet service provider (ISP) link is considered available")]
    HRESULT SuccessesToAvailable([in] long newVal);
	
	[propget, id(6), helpstring("Gets or sets the number of successive connectivity verification failures before an Internet service provider (ISP) link is considered unavailable")]
    HRESULT FailuresToUnavailable([out, retval] long *pVal);
    [propput, id(6), helpstring("Gets or sets the number of successive connectivity verification failures before an Internet service provider (ISP) link is considered unavailable")]
    HRESULT FailuresToUnavailable([in] long newVal);
	
	[propget, id(7), helpstring("Gets or sets the remote port for checking connectivity")]
    HRESULT ConnectivityVerificationRemotePort([out, retval] long *pVal);
    [propput, id(7), helpstring("Gets or sets the remote port for checking connectivity")]
    HRESULT ConnectivityVerificationRemotePort([in] long newVal);
	
	[propget, id(8), helpstring("Gets the collection of Internet service provider (ISP) links"), hidden]
    HRESULT ISPs([out, retval] IFPCISPs **pVal);
	
	[propget, id(9), helpstring("Gets an FPCIPAddresses collection that contains the list of remote IP addresses for checking connectivity")]
    HRESULT ConnectivityVerificationRemoteIpAddresses([out, retval] IFPCIPAddresses **pVal);
	
};
	
[
object,
uuid(D107A6AA-BFBC-4A5D-970D-BCF37D6EFDA2),
dual,
helpstring("A computer set"),
pointer_default(unique)
]
interface IFPCComputerSet : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the computer set")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the computer set")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets the description of the computer set")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(2), helpstring("Gets or sets the description of the computer set")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(3), helpstring("Gets whether the computer set is a preinstalled rule element that cannot be deleted")]
    HRESULT Predefined([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(4), helpstring("Gets the collection of computers")]
    HRESULT Computers([out, retval] IFPCComputers **pVal);
	
	[propget, id(5), helpstring("Gets the collection of address ranges")]
    HRESULT AddressRanges([out, retval] IFPCAddressRanges **pVal);
	
	[propget, id(6), helpstring("Gets the collection of subnets")]
    HRESULT Subnets([out, retval] IFPCSubnets **pVal);
	
};
	
[
object,
uuid(8D513181-0E72-4c1f-9754-C463D7EB6B99),
dual,
nonextensible,
helpstring("A computer set"),
pointer_default(unique)
]
interface IFPCComputerSet2 : IFPCComputerSet
{
	[propget, id(7), helpstring("Gets a Boolean value that indicates whether the computer set is dynamic")]
    HRESULT Dynamic([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(8), helpstring("Gets or sets a reference to the server that holds this dynamic computer set")]
    HRESULT DynamicPolicyServer([out, retval] IFPCServer **pVal);
    [propput, id(8), helpstring("Gets or sets a reference to the server that holds this dynamic computer set")]
    HRESULT DynamicPolicyServer([in] IFPCServer *newVal);
	
};
	
[
object,
uuid(C927C89B-C9D7-4E33-ACBC-A33C0EF27102),
dual,
helpstring("Collection of computer sets"),
pointer_default(unique)
]
interface IFPCComputerSets : IFPCPersist
{
	[id(DISPID_ADD), helpstring("Adds a computer set to the collection")]
          HRESULT Add( BSTR Name,
              [out,retval] IFPCComputerSet** ppNewTemplate);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a computer set from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCComputerSet** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

};
	
[
object,
uuid(1F678A84-9700-4987-A351-317A8BC86716),
dual,
nonextensible,
helpstring("Collection of computer sets"),
pointer_default(unique)
]
interface IFPCComputerSets2 : IFPCComputerSets
{
	[id(1), helpstring("Adds a dynamic computer set to the collection"), hidden]
          HRESULT AddDynamicSet( BSTR Name,
              [out,retval] IFPCComputerSet** ppNewSet);
        
    
};
	
[
object,
uuid(F27A1CF4-EB6F-4B51-8458-1AF6CF479410),
dual,
nonextensible,
helpstring("A URL category object"),
pointer_default(unique)
]
interface IFPCUrlCategory : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets the name of the URL category")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets the name of the URL category")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets the identifier of the URL category")]
    HRESULT CategoryId([out, retval] FpcUrlCategoryT *pVal);
	
	[propget, id(2), helpstring("Gets the description of the URL category")]
    HRESULT Description([out, retval] BSTR *pVal);
	
};
	
[
object,
uuid(614FC494-4F87-4084-8BD6-A0F38298A996),
dual,
nonextensible,
helpstring("Collection of URL categories"),
pointer_default(unique)
]
interface IFPCUrlCategories : IFPCPersist
{
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Returns the requested FPCUrlCategory object from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCUrlCategory** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(1), helpstring("Returns the requested FPCUrlCategory object from the collection based on its identifier")]
          HRESULT ItemByID( FpcUrlCategoryT CategoryId,
              [out,retval] IFPCUrlCategory** ppItem);
        
    
};
	
[
object,
uuid(6357147d-f8ff-4635-9094-c5992a059d8a),
dual,
nonextensible,
helpstring("A URL category set"),
pointer_default(unique)
]
interface IFPCUrlCategorySet : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the URL category set")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the URL category set")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the description of the URL category set")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the description of the URL category set")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets an FPCRefs collection that contains references to the URL categories that are included in or excluded from the set")]
    HRESULT UrlCategories([out, retval] IFPCRefs **pVal);
	
	[propget, id(3), helpstring("Gets a Boolean value that indicates whether the set is predefined according to third-party recommendations")]
    HRESULT Predefined([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(4), helpstring("Gets or sets a value from the FpcUrlCategorySetType enumerated type that indicates whether the URL category set includes only the URL categories specified in the URLCategories property or includes all URL categories except the URL categories specified in the URLCategories property")]
    HRESULT UrlCategorySetType([out, retval] FpcUrlCategorySetType *pVal);
    [propput, id(4), helpstring("Gets or sets a value from the FpcUrlCategorySetType enumerated type that indicates whether the URL category set includes only the URL categories specified in the URLCategories property or includes all URL categories except the URL categories specified in the URLCategories property")]
    HRESULT UrlCategorySetType([in] FpcUrlCategorySetType newVal);
	
};
	
[
object,
uuid(8181ab05-7af7-4e98-b9dd-fb0eb2de8284),
dual,
nonextensible,
helpstring("Collection of URL category sets"),
pointer_default(unique)
]
interface IFPCUrlCategorySets : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Retrieves the requested FPCUrlCategorySet object from the collection")]
          HRESULT Item([in] VARIANT v,
              [out,retval] IFPCUrlCategorySet** pItem);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Creates a new FPCUrlCategorySet object in the collection and returns a reference to it")]
          HRESULT Add([in] BSTR Name,
              [in,defaultvalue(fpcSelectedCategories)] FpcUrlCategorySetType CategorySetType,
              [out,retval] IFPCUrlCategorySet** ppNewUrlCategorySet);
        
    
	[id(DISPID_REMOVE), helpstring("Removes the specified FPCUrlCategorySet object from the collection")]
          HRESULT Remove( VARIANT v);
        
    
};
	
[
object,
uuid(C4BC4AB9-AB68-4D6F-AA26-C09E8BEB9EC5),
dual,
nonextensible,
helpstring("A URL set"),
pointer_default(unique)
]
interface IFPCURLSet : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the URL set")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the URL set")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the description of the URL set")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the description of the URL set")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets whether the URL set is a preinstalled element that cannot be deleted")]
    HRESULT Predefined([out, retval] VARIANT_BOOL *pVal);
	
	[id(3), helpstring("Returns a specific URL from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] BSTR* pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Adds a new URL to the object")]
          HRESULT Add( BSTR Name);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a URL from the object")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(4), helpstring("Returns URL set internal data"), hidden, restricted, local]
          HRESULT GetInternalData([in] HANDLE_PTR pArrData,
              [in,out] long* pSize);
        
    
};
	
[
object,
uuid(151B69DA-92A1-46CF-95A3-0DDEA8247AE4),
dual,
nonextensible,
helpstring("Collection of URL sets"),
pointer_default(unique)
]
interface IFPCURLSets : IFPCPersist
{
	[id(DISPID_ADD), helpstring("Adds a URL set to the collection")]
          HRESULT Add( BSTR Name,
              [out,retval] IFPCURLSet** ppNewTemplate);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a URL set from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCURLSet** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

};
	
[
object,
uuid(A08EC6CF-32F7-4717-9B47-7E1E9E3A05BC),
dual,
nonextensible,
helpstring("A domain name set"),
pointer_default(unique)
]
interface IFPCDomainNameSet : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the domain name set")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the domain name set")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the description of the domain name set")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the description of the domain name set")]
    HRESULT Description([in] BSTR newVal);
	
	[id(2), helpstring("Returns a specific domain name from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] BSTR* pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Adds a new domain name to the object")]
          HRESULT Add( BSTR Name);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a domain name from the object")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(3), helpstring("Returns domain names set internal data"), hidden, restricted, local]
          HRESULT GetInternalData([in] HANDLE_PTR pArrData,
              [in,out] long* pSize);
        
    
	[propget, id(4), helpstring("Gets whether the domain name set is a preinstalled element that cannot be deleted")]
    HRESULT Predefined([out, retval] VARIANT_BOOL *pVal);
	
};
	
[
object,
uuid(80CFCBCA-4F20-4c32-9F39-43D98E352BEE),
dual,
nonextensible,
helpstring("A published server in a load-balanced server farm"),
pointer_default(unique)
]
interface IFPCPublishedServer : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name or IP address of the published server")]
    HRESULT NameOrIP([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name or IP address of the published server")]
    HRESULT NameOrIP([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the description of the server farm")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the description of the server farm")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets a value that indicates whether the server should be drained and stopped")]
    HRESULT DrainStopped([out, retval] VARIANT_BOOL *pVal);
    [propput, id(2), helpstring("Gets or sets a value that indicates whether the server should be drained and stopped")]
    HRESULT DrainStopped([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(AB60314C-7E64-4b30-A0DD-FA550713EC36),
dual,
nonextensible,
helpstring("Load balancing configuration for a publishing rule"),
pointer_default(unique)
]
interface IFPCLoadBalancingConfig : IDispatch
{
	[propget, id(1), helpstring("Gets an FPCRef object that references the FPCServerFarm object representing the server farm associated with the rule")]
    HRESULT ServerFarm([out, retval] IFPCRef **pVal);
	
	[propget, id(2), helpstring("Gets or sets a FpcLoadBalancingAffinityType value that indicates the type of affinity")]
    HRESULT AffinityType([out, retval] FpcLoadBalancingAffinityType *pVal);
    [propput, id(2), helpstring("Gets or sets a FpcLoadBalancingAffinityType value that indicates the type of affinity")]
    HRESULT AffinityType([in] FpcLoadBalancingAffinityType newVal);
	
	[id(3), helpstring("Sets the server farm associated with the rule")]
          HRESULT SetServerFarm([in] BSTR ServerFarmName);
        
    
};
	
[
object,
uuid(62E213D4-C0D1-45ba-95BA-4C31ED1B9B23),
dual,
nonextensible,
helpstring("A load-balanced cluster of published servers"),
pointer_default(unique)
]
interface IFPCServerFarm : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the server farm")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the server farm")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the description of the server farm")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the description of the server farm")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets the collection of the published servers in the server farm")]
    HRESULT PublishedServers([out, retval] IFPCPublishedServers **pVal);
	
	[propget, id(3), helpstring("Gets the connectivity verifier definition associated with the server farm")]
    HRESULT ConnectivityVerifier([out, retval] IFPCConnectivityVerifier **pVal);
	
};
	
[
object,
uuid(3871C894-3920-41a8-84F2-4DD86F1B9F50),
dual,
nonextensible,
helpstring("Collection of server farms"),
pointer_default(unique)
]
interface IFPCServerFarms : IFPCPersist
{
	[id(DISPID_ADD), helpstring("Adds a server farm to the collection")]
          HRESULT Add( BSTR Name,
              [out,retval] IFPCServerFarm** ppNewFarm);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a server farm from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Returns the requested server farm from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCServerFarm** pFarm);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

};
	
[
object,
uuid(DEEED81E-25D6-4f20-B4D6-23CE3DB5B005),
dual,
nonextensible,
helpstring("Collection of published servers"),
pointer_default(unique)
]
interface IFPCPublishedServers : IFPCPersist
{
	[id(DISPID_ADD), helpstring("Adds a published server to the collection")]
          HRESULT Add( BSTR NameOrIP,
              [out,retval] IFPCPublishedServer** ppNewServer);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a published server from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Returns the requested published server from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCPublishedServer** pServer);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

};
	
[
object,
uuid(DCDB52F6-4EEF-4067-A72F-8FB05882F4C8),
dual,
nonextensible,
helpstring("Collection of domain name sets"),
pointer_default(unique)
]
interface IFPCDomainNameSets : IFPCPersist
{
	[id(DISPID_ADD), helpstring("Adds a domain name set to the collection")]
          HRESULT Add( BSTR Name,
              [out,retval] IFPCDomainNameSet** ppNewTemplate);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a domain name set from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCDomainNameSet** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

};
	
[
object,
uuid(EDCE2F1C-54A9-4090-A090-10E19F0A2C48),
dual,
helpstring("A selection IPs for rule"),
pointer_default(unique)
]
interface IFPCSelectionIPs : IFPCPersist
{
	[propget, id(1), helpstring("Gets a reference to the collection of references to the networks to which the rule related")]
    HRESULT Networks([out, retval] IFPCRefs **pVal);
	
	[propget, id(2), helpstring("Gets a reference to the collection of references to the network sets to which the rule related")]
    HRESULT NetworkSets([out, retval] IFPCRefs **pVal);
	
	[propget, id(3), helpstring("Gets a reference to the collection of references to the computers to which the rule related")]
    HRESULT Computers([out, retval] IFPCRefs **pVal);
	
	[propget, id(4), helpstring("Gets a reference to the collection of references to the address ranges to which the rule related")]
    HRESULT AddressRanges([out, retval] IFPCRefs **pVal);
	
	[propget, id(5), helpstring("Gets a reference to the collection of references to the subnets to which the rule related")]
    HRESULT Subnets([out, retval] IFPCRefs **pVal);
	
	[propget, id(6), helpstring("Gets a reference to the collection of references to the computer sets to which the rule related")]
    HRESULT ComputerSets([out, retval] IFPCRefs **pVal);
	
};
	
[
object,
uuid(5857a2ef-7209-4cac-b186-2a8306ca0e0f),
dual,
nonextensible,
helpstring("A selection IPs for rule"),
pointer_default(unique)
]
interface IFPCEESelectionIPs : IFPCSelectionIPs
{
	[propget, id(7), helpstring("Gets a reference to the collection of references to the enterprise networks to which the rule related")]
    HRESULT EnterpriseNetworks([out, retval] IFPCRefs **pVal);
	
};
	
[
object,
uuid(95C7FA44-82EB-4e1a-BCCF-807BD58D04B5),
dual,
nonextensible,
helpstring("Collection of mappings"),
pointer_default(unique)
]
interface IFPCExplicitLinkTranslationMappings : IFPCPersist
{
	[id(DISPID_ADD), helpstring("Adds an explicit mapping to the collection")]
          HRESULT Add([in] BSTR OriginalUrl,
              [in] BSTR TranslatedUrl,
              [out,retval] IFPCExplicitLinkTranslationMapping** ppNewMapping);
        
    
	[id(DISPID_REMOVE), helpstring("Removes the specified explicit mapping from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Retrieves the requested explicit mapping from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCExplicitLinkTranslationMapping** pExplicitLinkTranslationMapping);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

};
	
[
object,
uuid(91A7C372-0626-4fcb-AD09-59480B94EECE),
dual,
nonextensible,
helpstring("A mapping entry"),
pointer_default(unique)
]
interface IFPCExplicitLinkTranslationMapping : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the original URL")]
    HRESULT OriginalUrl([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the original URL")]
    HRESULT OriginalUrl([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the translated URL")]
    HRESULT TranslatedUrl([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the translated URL")]
    HRESULT TranslatedUrl([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets the description of the mapping")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(2), helpstring("Gets or sets the description of the mapping")]
    HRESULT Description([in] BSTR newVal);
	
};
	
[
object,
uuid(C91B434C-881F-4856-AC5A-762DD59633A0),
dual,
nonextensible,
helpstring("Collection of code pages"),
pointer_default(unique)
]
interface IFPCCodePages : IFPCPersist
{
	[id(DISPID_ADD), helpstring("Adds a code page to the collection")]
          HRESULT Add([in] BSTR CodePage,
              [out,retval] IFPCCodePage** ppNewCodePage);
        
    
	[id(DISPID_REMOVE), helpstring("Removes the specified code page from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Retrieve the requested code page from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCCodePage** pCodePage);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

};
	
[
object,
uuid(CD438DC7-3F47-4d72-830B-BB70596296ED),
dual,
nonextensible,
helpstring("A code page entry"),
pointer_default(unique)
]
interface IFPCCodePage : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets a string that specifies the code page number")]
    HRESULT Code([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets a string that specifies the code page number")]
    HRESULT Code([in] BSTR newVal);
	
};
	
[
object,
uuid(88E3E550-D687-4871-8B02-DD336C504B06),
dual,
helpstring("An access properties for policy rule"),
pointer_default(unique)
]
interface IFPCAccessProperties : IDispatch
{
	[propget, id(1), helpstring("Gets a reference to the selection destination IPs to which the rule applies")]
    HRESULT DestinationSelectionIPs([out, retval] IFPCSelectionIPs **pVal);
	
	[propget, id(2), helpstring("Gets a reference to the collection of references to the user sets to which the rule related")]
    HRESULT UserSets([out, retval] IFPCRefs **pVal);
	
	[propget, id(3), helpstring("Gets a reference to the collection of references to the destination domain name sets to which the rule applies")]
    HRESULT DestinationDomainNameSets([out, retval] IFPCRefs **pVal);
	
	[propget, id(4), helpstring("Gets or sets whether the rule applies to all IP traffic, all IP traffic exclusive of certain protocols, or to specified protocols")]
    HRESULT ProtocolSelectionMethod([out, retval] FpcProtocolSelectionType *pVal);
    [propput, id(4), helpstring("Gets or sets whether the rule applies to all IP traffic, all IP traffic exclusive of certain protocols, or to specified protocols")]
    HRESULT ProtocolSelectionMethod([in] FpcProtocolSelectionType newVal);
	
	[propget, id(5), helpstring("Gets reference to the collection of references to the protocols to which the rule applies")]
    HRESULT SpecifiedProtocols([out, retval] IFPCRefs **pVal);
	
	[propget, id(6), helpstring("Gets or sets the URL to redirect requests to")]
    HRESULT RedirectUrl([out, retval] BSTR *pVal);
    [propput, id(6), helpstring("Gets or sets the URL to redirect requests to")]
    HRESULT RedirectUrl([in] BSTR newVal);
	
	[propget, id(7), helpstring("Gets or sets the selection of content to which the rule applies")]
    HRESULT AppliesToContentMethod([out, retval] FpcAppliesToContentMethodType *pVal);
    [propput, id(7), helpstring("Gets or sets the selection of content to which the rule applies")]
    HRESULT AppliesToContentMethod([in] FpcAppliesToContentMethodType newVal);
	
	[propget, id(8), helpstring("Gets a reference to the collection of references to the content type sets to which the rule applies (HTTP only)")]
    HRESULT ContentTypeSetsUsed([out, retval] IFPCRefs **pVal);
	
	[propget, id(9), helpstring("Gets a reference to the collection of URL sets to which the rule applies")]
    HRESULT URLSets([out, retval] IFPCRefs **pVal);
	
};
	
[
object,
uuid(0F5835CB-AA77-4CA2-BEE5-8F5237D115AB),
dual,
nonextensible,
helpstring("Access properties for policy rule"),
pointer_default(unique)
]
interface IFPCAccessProperties2 : IFPCAccessProperties
{
	[propget, id(10), helpstring("Gets an FPCRefs collection that contains references to the FPCUrlCategory objects defining the URL categories to which the rule applies")]
    HRESULT UrlCategories([out, retval] IFPCRefs **pVal);
	
	[propget, id(11), helpstring("Gets or sets a Boolean value that indicates whether the text specified in the CustomMessageText property will be displayed in the access denied error page")]
    HRESULT DisplayCustomMessageText([out, retval] VARIANT_BOOL *pVal);
    [propput, id(11), helpstring("Gets or sets a Boolean value that indicates whether the text specified in the CustomMessageText property will be displayed in the access denied error page")]
    HRESULT DisplayCustomMessageText([in] VARIANT_BOOL newVal);
	
	[propget, id(12), helpstring("Gets or sets a Boolean value that indicates whether the URL category of the request will be displayed in the access denied error page")]
    HRESULT DisplayUrlCategory([out, retval] VARIANT_BOOL *pVal);
    [propput, id(12), helpstring("Gets or sets a Boolean value that indicates whether the URL category of the request will be displayed in the access denied error page")]
    HRESULT DisplayUrlCategory([in] VARIANT_BOOL newVal);
	
	[propget, id(13), helpstring("Gets or sets the text to be displayed in the access denied error page if displaying custom text is enabled")]
    HRESULT CustomMessageText([out, retval] BSTR *pVal);
    [propput, id(13), helpstring("Gets or sets the text to be displayed in the access denied error page if displaying custom text is enabled")]
    HRESULT CustomMessageText([in] BSTR newVal);
	
	[propget, id(14), helpstring("Gets an FPCRefs collection that contains references to the FPCUrlCategorySet collections defining the URL category sets to which the rule applies")]
    HRESULT UrlCategorySets([out, retval] IFPCRefs **pVal);
	
};
	
[
object,
uuid(8E0E5C06-B221-49F0-BEAA-4F9AF460599E),
dual,
helpstring("A server publishing properties for policy rule"),
pointer_default(unique)
]
interface IFPCServerPublishingProperties : IDispatch
{
	[propget, id(1), helpstring("Gets an IP address of published server")]
    HRESULT PublishedServerIP([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets an IP address of published server")]
    HRESULT PublishedServerIP([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets the port number for overriding the default port on the server published by the rule to which the Forefront TMG computer will forward requests (0 for the default defined in the protocol definition)")]
    HRESULT OverrideServerPort([out, retval] long *pVal);
    [propput, id(2), helpstring("Gets or sets the port number for overriding the default port on the server published by the rule to which the Forefront TMG computer will forward requests (0 for the default defined in the protocol definition)")]
    HRESULT OverrideServerPort([in] long newVal);
	
	[propget, id(3), helpstring("Gets or sets the port number for overriding the default port on which the Forefront TMG computer will listen for requests on behalf of the server published by the rule (0 for the default defined in the protocol definition)")]
    HRESULT OverridePublishPort([out, retval] long *pVal);
    [propput, id(3), helpstring("Gets or sets the port number for overriding the default port on which the Forefront TMG computer will listen for requests on behalf of the server published by the rule (0 for the default defined in the protocol definition)")]
    HRESULT OverridePublishPort([in] long newVal);
	
	[propget, id(4), helpstring("Gets or sets if using the firewall IP as source in connection to the server")]
    HRESULT UseFirewallIPAsSource([out, retval] VARIANT_BOOL *pVal);
    [propput, id(4), helpstring("Gets or sets if using the firewall IP as source in connection to the server")]
    HRESULT UseFirewallIPAsSource([in] VARIANT_BOOL newVal);
	
	[propget, id(5), helpstring("Gets a reference to the published protocol of the server publishing rule")]
    HRESULT PublishedProtocol([out, retval] IFPCRef **pVal);
	
	[id(6), helpstring("Sets the published protocol for the server publishing rule")]
          HRESULT SetPublishedProtocol([in] BSTR Name);
        
    
	[propget, id(7), helpstring("Gets a reference to the collection of networks with specific IPs to listen on to which the rule applies")]
    HRESULT IPsOnNetworks([out, retval] IFPCIPsOnNetworks **pVal);
	
	[propget, id(9), helpstring("Gets a reference to the collection of network sets to listen on to which the rule applies")]
    HRESULT IPsOnNetworkSets([out, retval] IFPCRefs **pVal);
	
};
	
[
object,
uuid(606cc61d-269a-4cbf-8083-e5f99e5c202b),
dual,
nonextensible,
helpstring("A server publishing properties for policy rule"),
pointer_default(unique)
]
interface IFPCEEServerPublishingProperties : IFPCServerPublishingProperties
{
	[id(10), helpstring("Sets the published protocol from specific scope for the server publishing rule")]
          HRESULT SetScopedPublishedProtocol([in] FpcItemScope Scope,
              [in] BSTR Name);
        
    
};
	
[
object,
uuid(463C8C4B-993D-4582-BADC-6FC6A2540CD7),
dual,
helpstring("A Web publishing properties for policy rule"),
pointer_default(unique)
]
interface IFPCWebPublishingProperties : IDispatch
{
	[propget, id(1), helpstring("Gets the URL to redirect requests to")]
    HRESULT WebSite([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets the URL to redirect requests to")]
    HRESULT WebSite([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets the type of published server to which the rule applies")]
    HRESULT PublishedServerType([out, retval] FpcPublishedServerType *pVal);
    [propput, id(2), helpstring("Gets or sets the type of published server to which the rule applies")]
    HRESULT PublishedServerType([in] FpcPublishedServerType newVal);
	
	[propget, id(3), helpstring("Gets or sets the port to redirect requests if redirecting as an HTTP request")]
    HRESULT HTTPRedirectPort([out, retval] long *pVal);
    [propput, id(3), helpstring("Gets or sets the port to redirect requests if redirecting as an HTTP request")]
    HRESULT HTTPRedirectPort([in] long newVal);
	
	[propget, id(4), helpstring("Gets or sets the port to redirect requests if redirecting as an SSL request")]
    HRESULT SSLRedirectPort([out, retval] long *pVal);
    [propput, id(4), helpstring("Gets or sets the port to redirect requests if redirecting as an SSL request")]
    HRESULT SSLRedirectPort([in] long newVal);
	
	[propget, id(5), helpstring("Gets or sets the port to redirect a request if the Web proxy service redirects it as an FTP request")]
    HRESULT FTPRedirectPort([out, retval] long *pVal);
    [propput, id(5), helpstring("Gets or sets the port to redirect a request if the Web proxy service redirects it as an FTP request")]
    HRESULT FTPRedirectPort([in] long newVal);
	
	[propget, id(6), helpstring("Gets or sets whether a secure channel is required")]
    HRESULT SSLRequireSecureChannel([out, retval] FpcSSLRequireSecureChannelMode *pVal);
    [propput, id(6), helpstring("Gets or sets whether a secure channel is required")]
    HRESULT SSLRequireSecureChannel([in] FpcSSLRequireSecureChannelMode newVal);
	
	[propget, id(7), helpstring("Gets or sets the client certificate to use when authenticating by using the publishing server")]
    HRESULT SSLClientCertificate([out, retval] IFPCCertificate **pVal);
    [propput, id(7), helpstring("Gets or sets the client certificate to use when authenticating by using the publishing server")]
    HRESULT SSLClientCertificate([in] IFPCCertificate *newVal);
	
	[propget, id(8), helpstring("Gets or sets whether Forefront TMG sends the original host header")]
    HRESULT SendOriginalHostHeader([out, retval] VARIANT_BOOL *pVal);
    [propput, id(8), helpstring("Gets or sets whether Forefront TMG sends the original host header")]
    HRESULT SendOriginalHostHeader([in] VARIANT_BOOL newVal);
	
	[propget, id(12), helpstring("Gets or sets whether links are translated to the public names recognized by the rule")]
    HRESULT TranslateLinks([out, retval] VARIANT_BOOL *pVal);
    [propput, id(12), helpstring("Gets or sets whether links are translated to the public names recognized by the rule")]
    HRESULT TranslateLinks([in] VARIANT_BOOL newVal);
	
	[propget, id(13), helpstring("Gets or sets whether basic credentials are delegated")]
    HRESULT DelegateBasicCredentials([out, retval] VARIANT_BOOL *pVal);
    [propput, id(13), helpstring("Gets or sets whether basic credentials are delegated")]
    HRESULT DelegateBasicCredentials([in] VARIANT_BOOL newVal);
	
	[propget, id(14), helpstring("Gets or sets whether any public name that resolves to the IP address of the internal Web site will be accepted in incoming requests")]
    HRESULT AllPublicNames([out, retval] VARIANT_BOOL *pVal);
    [propput, id(14), helpstring("Gets or sets whether any public name that resolves to the IP address of the internal Web site will be accepted in incoming requests")]
    HRESULT AllPublicNames([in] VARIANT_BOOL newVal);
	
	[propget, id(15), helpstring("Gets the object that contains the names that are resolved to the internal address")]
    HRESULT PublicNames([out, retval] IFPCPublicNames **pVal);
	
	[propget, id(16), helpstring("Gets the collection that maps published Web site names to the internal path of the Web site")]
    HRESULT PathMappings([out, retval] IFPCPathMappings **pVal);
	
	[propget, id(17), helpstring("Gets a reference to the outgoing Web listener used for the rule")]
    HRESULT WebListenerUsed([out, retval] IFPCRef **pVal);
	
	[id(18), helpstring("Sets the outgoing Web listener used for the rule")]
          HRESULT SetWebListener([in] BSTR WebListenerName);
        
    
	[propget, id(19), helpstring("Gets or sets if using the firewall IP as source in connection to the server")]
    HRESULT UseFirewallIPAsSource([out, retval] VARIANT_BOOL *pVal);
    [propput, id(19), helpstring("Gets or sets if using the firewall IP as source in connection to the server")]
    HRESULT UseFirewallIPAsSource([in] VARIANT_BOOL newVal);
	
	[propget, id(20), helpstring("Gets a reference to the collection of references to the user sets to which the rule applies")]
    HRESULT UserSets([out, retval] IFPCRefs **pVal);
	
	[propget, id(21), helpstring("Gets or sets whether the Web proxy will pass OPTIONS request to a published server")]
    HRESULT PassOptionsRequestsToServer([out, retval] VARIANT_BOOL *pVal);
    [propput, id(21), helpstring("Gets or sets whether the Web proxy will pass OPTIONS request to a published server")]
    HRESULT PassOptionsRequestsToServer([in] VARIANT_BOOL newVal);
	
	[propget, id(22), helpstring("Gets or sets a Boolean value that indicates whether Forefront TMG sends the original Accept-Encoding header received from the client to the published server")]
    HRESULT SendAcceptEncodingHeader([out, retval] VARIANT_BOOL *pVal);
    [propput, id(22), helpstring("Gets or sets a Boolean value that indicates whether Forefront TMG sends the original Accept-Encoding header received from the client to the published server")]
    HRESULT SendAcceptEncodingHeader([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(9AA67424-3527-4137-A08C-3604F5997425),
dual,
helpstring("Web publishing properties for a policy rule"),
pointer_default(unique)
]
interface IFPCWebPublishingProperties2 : IFPCWebPublishingProperties
{
	[propget, id(23), helpstring("Gets or sets a Boolean value that indicates whether the rule publishes a load balanced server farm")]
    HRESULT LoadBalancingEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(23), helpstring("Gets or sets a Boolean value that indicates whether the rule publishes a load balanced server farm")]
    HRESULT LoadBalancingEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(24), helpstring("Gets the load balancing configuration for the Web publishing rule.")]
    HRESULT LoadBalancingConfig([out, retval] IFPCLoadBalancingConfig **pVal);
	
	[propget, id(25), helpstring("Gets or sets the type of the credentials delegated to the published server")]
    HRESULT CredentialsDelegationType([out, retval] FpcCredentialsDelegationType *pVal);
    [propput, id(25), helpstring("Gets or sets the type of the credentials delegated to the published server")]
    HRESULT CredentialsDelegationType([in] FpcCredentialsDelegationType newVal);
	
	[propget, id(26), helpstring("Gets or sets the service principal name (SPN) that will be used for requesting a Kerberos ticket when delegation using the Simple and Protected Negotiation (SPNEGO) protocol or Kerberos constrained delegation is allowed")]
    HRESULT ServicePrincipalName([out, retval] BSTR *pVal);
    [propput, id(26), helpstring("Gets or sets the service principal name (SPN) that will be used for requesting a Kerberos ticket when delegation using the Simple and Protected Negotiation (SPNEGO) protocol or Kerberos constrained delegation is allowed")]
    HRESULT ServicePrincipalName([in] BSTR newVal);
	
	[propget, id(27), helpstring("Gets or sets a value from the FpcCredentialsDelegationPersistence enumerated type that specifies whether the credentials will be delegated to the published server for each request or only once for a connection")]
    HRESULT CredentialsDelegationPersistence([out, retval] FpcCredentialsDelegationPersistence *pVal);
    [propput, id(27), helpstring("Gets or sets a value from the FpcCredentialsDelegationPersistence enumerated type that specifies whether the credentials will be delegated to the published server for each request or only once for a connection")]
    HRESULT CredentialsDelegationPersistence([in] FpcCredentialsDelegationPersistence newVal);
	
	[propget, id(28), helpstring("Gets or sets the URL that will be used for logging off from the published application ")]
    HRESULT LogoffURL([out, retval] BSTR *pVal);
    [propput, id(28), helpstring("Gets or sets the URL that will be used for logging off from the published application ")]
    HRESULT LogoffURL([in] BSTR newVal);
	
	[propget, id(29), helpstring("Deprecated - use IFPCWebPublishingProperties3::SSLClientCertificateClaim instead")]
    HRESULT RequireSSLClientCertificate([out, retval] VARIANT_BOOL *pVal);
    [propput, id(29), helpstring("Deprecated - use IFPCWebPublishingProperties3::SSLClientCertificateClaim instead")]
    HRESULT RequireSSLClientCertificate([in] VARIANT_BOOL newVal);
	
	[propget, id(30), helpstring("Gets or sets the name of the directory with custom HTML forms")]
    HRESULT CustomFormsDirectory([out, retval] BSTR *pVal);
    [propput, id(30), helpstring("Gets or sets the name of the directory with custom HTML forms")]
    HRESULT CustomFormsDirectory([in] BSTR newVal);
	
	[propget, id(31), helpstring("Gets or sets the level of client logon type enforcement")]
    HRESULT LogonTypeEnforcement([out, retval] FpcLogonTypeEnforcement *pVal);
    [propput, id(31), helpstring("Gets or sets the level of client logon type enforcement")]
    HRESULT LogonTypeEnforcement([in] FpcLogonTypeEnforcement newVal);
	
	[propget, id(32), helpstring("Gets or sets the link translation operating mode")]
    HRESULT LinkTranslationMode([out, retval] FpcLinkTranslationMode *pVal);
    [propput, id(32), helpstring("Gets or sets the link translation operating mode")]
    HRESULT LinkTranslationMode([in] FpcLinkTranslationMode newVal);
	
	[propget, id(33), helpstring("Gets an FPCLinkTranslationPatterns collection that contains the pattern matching expressions for some link translation modes")]
    HRESULT LinkTranslationPatterns([out, retval] IFPCLinkTranslationPatterns **pVal);
	
	[propget, id(34), helpstring("Gets a collection of code pages")]
    HRESULT CodePages([out, retval] IFPCCodePages **pVal);
	
	[propget, id(35), helpstring("Gets or sets a Boolean value that indicates whether range requests are allowed with link translation")]
    HRESULT RangeRequestsAllowedWithLinkTranslation([out, retval] VARIANT_BOOL *pVal);
    [propput, id(35), helpstring("Gets or sets a Boolean value that indicates whether range requests are allowed with link translation")]
    HRESULT RangeRequestsAllowedWithLinkTranslation([in] VARIANT_BOOL newVal);
	
	[propget, id(36), helpstring("Gets or sets Boolean value that indicates whether forwarding of e-mail attachments will be blocked for trusted client computers")]
    HRESULT BlockAttachmentsForTrustedComputers([out, retval] VARIANT_BOOL *pVal);
    [propput, id(36), helpstring("Gets or sets Boolean value that indicates whether forwarding of e-mail attachments will be blocked for trusted client computers")]
    HRESULT BlockAttachmentsForTrustedComputers([in] VARIANT_BOOL newVal);
	
	[propget, id(37), helpstring("Gets or sets Boolean value that indicates whether forwarding of e-mail attachments will be blocked for public client computers")]
    HRESULT BlockAttachmentsForPublicComputers([out, retval] VARIANT_BOOL *pVal);
    [propput, id(37), helpstring("Gets or sets Boolean value that indicates whether forwarding of e-mail attachments will be blocked for public client computers")]
    HRESULT BlockAttachmentsForPublicComputers([in] VARIANT_BOOL newVal);
	
	[propget, id(38), helpstring("Gets or sets a Boolean value that indicates whether the Web proxy will deny TRACE requests to the published server")]
    HRESULT DenyTraceRequests([out, retval] VARIANT_BOOL *pVal);
    [propput, id(38), helpstring("Gets or sets a Boolean value that indicates whether the Web proxy will deny TRACE requests to the published server")]
    HRESULT DenyTraceRequests([in] VARIANT_BOOL newVal);
	
	[propget, id(39), helpstring("Gets or sets a value from the FpcLinkTranslationOptions enumerated type that specifies the link translation options for the rule")]
    HRESULT LinkTranslationOptions([out, retval] FpcLinkTranslationOptions *pVal);
    [propput, id(39), helpstring("Gets or sets a value from the FpcLinkTranslationOptions enumerated type that specifies the link translation options for the rule")]
    HRESULT LinkTranslationOptions([in] FpcLinkTranslationOptions newVal);
	
	[propget, id(40), helpstring("Gets or sets Boolean value that indicates whether the domain name will be stripped during credentials delegation")]
    HRESULT StripDomainFromCredentials([out, retval] VARIANT_BOOL *pVal);
    [propput, id(40), helpstring("Gets or sets Boolean value that indicates whether the domain name will be stripped during credentials delegation")]
    HRESULT StripDomainFromCredentials([in] VARIANT_BOOL newVal);
	
	[propget, id(41), helpstring("Gets or sets the types of client computers for which Forefront TMG will include a Cache-Control:No-Cache header to prevent the caching of protected content"), hidden]
    HRESULT PreventCachingComputerType([out, retval] FpcPreventCachingComputerType *pVal);
    [propput, id(41), helpstring("Gets or sets the types of client computers for which Forefront TMG will include a Cache-Control:No-Cache header to prevent the caching of protected content"), hidden]
    HRESULT PreventCachingComputerType([in] FpcPreventCachingComputerType newVal);
	
	[propget, id(42), helpstring("Gets or sets the URL to redirect requests to")]
    HRESULT RedirectUrl([out, retval] BSTR *pVal);
    [propput, id(42), helpstring("Gets or sets the URL to redirect requests to")]
    HRESULT RedirectUrl([in] BSTR newVal);
	
	[propget, id(43), helpstring("Gets or sets the name or IP address of the published server")]
    HRESULT PublishedServer([out, retval] BSTR *pVal);
    [propput, id(43), helpstring("Gets or sets the name or IP address of the published server")]
    HRESULT PublishedServer([in] BSTR newVal);
	
	[propget, id(44), helpstring("Gets or sets a Boolean value that indicates whether Alternate Access Mapping (AAM) is configured on the published SharePoint server")]
    HRESULT AlternateAccessMappingConfigured([out, retval] VARIANT_BOOL *pVal);
    [propput, id(44), helpstring("Gets or sets a Boolean value that indicates whether Alternate Access Mapping (AAM) is configured on the published SharePoint server")]
    HRESULT AlternateAccessMappingConfigured([in] VARIANT_BOOL newVal);
	
	[propget, id(45), helpstring("Gets or sets a value from the FpcPublishedServerApplication enumerated type that specifies the server application published by the rule")]
    HRESULT PublishedServerApplication([out, retval] FpcPublishedServerApplication *pVal);
    [propput, id(45), helpstring("Gets or sets a value from the FpcPublishedServerApplication enumerated type that specifies the server application published by the rule")]
    HRESULT PublishedServerApplication([in] FpcPublishedServerApplication newVal);
	
	[propget, id(46), helpstring("Gets or sets a Boolean value that indicates whether the Web proxy will pass the authorization response to client without replacing it with FBA logon form")]
    HRESULT PassAuthenticationResponseBodyToClient([out, retval] VARIANT_BOOL *pVal);
    [propput, id(46), helpstring("Gets or sets a Boolean value that indicates whether the Web proxy will pass the authorization response to client without replacing it with FBA logon form")]
    HRESULT PassAuthenticationResponseBodyToClient([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(56752e45-fca6-4235-9d6f-b73135ec4859),
dual,
helpstring("Web publishing properties for a policy rule"),
pointer_default(unique)
]
interface IFPCWebPublishingProperties3 : IFPCWebPublishingProperties2
{
	[propget, id(47), helpstring("Gets or sets a value that indicates whether an SSL client certificate is requested")]
    HRESULT SSLClientCertificateClaim([out, retval] FpcSSLClientCertificateClaim *pVal);
    [propput, id(47), helpstring("Gets or sets a value that indicates whether an SSL client certificate is requested")]
    HRESULT SSLClientCertificateClaim([in] FpcSSLClientCertificateClaim newVal);
	
};
	
[
object,
uuid(7dfeab99-23d7-4d8c-b0df-399c23d4e56a),
dual,
nonextensible,
helpstring("Web publishing properties for a policy rule"),
pointer_default(unique)
]
interface IFPCWebPublishingProperties4 : IFPCWebPublishingProperties3
{
	[id(48), helpstring("Performes connectivity test for the parent FPCPolicyRule object")]
          HRESULT TestConnectivity( [out,retval] BSTR* pbstrTestResult);
        
    
};
	
[
object,
uuid(1261594E-Ef3D-4980-867E-0AC4F83266B9),
dual,
nonextensible,
helpstring("Collection of policy groups"),
pointer_default(unique)
]
interface IFPCPolicyGroups : IFPCPersist
{
	[id(DISPID_ADD), helpstring("Creates a new FPCPolicyGroup object in the collection and returns a reference to it")]
          HRESULT Add( BSTR Name,
              [out,retval] IFPCPolicyGroup** ppNewGroup);
        
    
	[id(DISPID_REMOVE), helpstring("Removes the specified FPCPolicyGroup object from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Retrieves the requested FPCPolicyGroup object from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCPolicyGroup** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

};
	
[
object,
uuid(126154E1-9128-4CFA-A0D1-04907D6DC825),
dual,
nonextensible,
helpstring("A policy group"),
pointer_default(unique)
]
interface IFPCPolicyGroup : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the policy group")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the policy group")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets a value from the FpcPolicyRuleGroups enumerated type that specifies the group type")]
    HRESULT Type([out, retval] FpcPolicyRuleGroups *pVal);
    [propput, id(1), helpstring("Gets or sets a value from the FpcPolicyRuleGroups enumerated type that specifies the group type")]
    HRESULT Type([in] FpcPolicyRuleGroups newVal);
	
};
	
[
object,
uuid(23C40B62-78BC-4EF6-B60D-C651CC5E8A9C),
dual,
helpstring("Collection of policy rules"),
pointer_default(unique)
]
interface IFPCPolicyRules : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCPolicyRule** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_REMOVE), helpstring("Removes a policy rule from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(1), helpstring("Adds a access rule to the collection")]
          HRESULT AddAccessRule([in] BSTR Name,
              [out,retval] IFPCPolicyRule** ppNewRule);
        
    
	[id(2), helpstring("Adds a server publishing rule to the collection")]
          HRESULT AddServerPublishingRule([in] BSTR Name,
              [in] BSTR PublishedServerIP,
              [in] BSTR Protocol,
              [out,retval] IFPCPolicyRule** ppNewRule);
        
    
	[id(3), helpstring("Adds a Web publishing rule to the collection")]
          HRESULT AddWebPublishingRule([in] BSTR Name,
              [out,retval] IFPCPolicyRule** ppNewRule);
        
    
	[id(5), helpstring("Moves the specified rule up the ladder of execution")]
          HRESULT MoveUp( long index);
        
    
	[id(6), helpstring("Moves the specified rule down the ladder of execution")]
          HRESULT MoveDown( long index);
        
    
};
	
[
object,
uuid(D2310659-CAA0-4db4-BF40-A8B7FBB3B3BE),
dual,
nonextensible,
helpstring("Collection of policy rules"),
pointer_default(unique)
]
interface IFPCEEPolicyRules : IFPCPolicyRules
{
	[id(7), helpstring("Adds a server publishing rule to the collection with scoped protocol")]
          HRESULT AddServerPublishingRuleWithScopedProtocol([in] BSTR Name,
              [in] BSTR PublishedServerIP,
              [in] FpcItemScope ProtocolScope,
              [in] BSTR Protocol,
              [out,retval] IFPCPolicyRule** ppNewRule);
        
    
};
	
[
object,
uuid(DBC8BD1E-46D4-4904-9322-3E8565B192F6),
dual,
helpstring("Collection of system policy rules"),
pointer_default(unique)
]
interface IFPCSystemPolicyRules : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCPolicyRule** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
};
	
[
object,
uuid(5C145FC6-EA47-455D-B687-3F746586B7E7),
dual,
nonextensible,
helpstring("Collection of system policy rules"),
pointer_default(unique)
]
interface IFPCSystemPolicyRules2 : IFPCSystemPolicyRules
{
	[id(1), helpstring("Adds a vendor-defined system policy rule to the collection"), hidden]
          HRESULT AddVendorAccessSystemRule([in] BSTR Name,
              [in] BSTR RuleGuid,
              [out,retval] IFPCPolicyRule** ppNewRule);
        
    
	[id(2), helpstring("Removes the specified vendor-defined system policy rule from the collection"), hidden]
          HRESULT RemoveVendorAccessSystemRule([in] BSTR RuleGuid);
        
    
};
	
[
object,
uuid(C4B4D0AC-DCAE-43BE-B2C5-6E30D3DC9FFC),
dual,
helpstring("A policy rule"),
pointer_default(unique)
]
interface IFPCPolicyRule : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the rule")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the rule")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the description of the rule")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the description of the rule")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets a Boolean value that indicates whether the rule is enabled")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(2), helpstring("Gets or sets a Boolean value that indicates whether the rule is enabled")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(3), helpstring("Gets a Boolean value that indicates whether the rule is preinstalled, and cannot be deleted or have its position changed in the rule order")]
    HRESULT IsDefault([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(4), helpstring("Gets a Boolean value that indicates whether the rule is a system policy rule")]
    HRESULT System([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(5), helpstring("Gets the rule's ordinal position in the list of policy rules, which corresponds to their order of application")]
    HRESULT Order([out, retval] long *pVal);
	
	[propget, id(6), helpstring("Gets a value from the FpcPolicyRuleTypes enumerated type that indicates whether the policy rule is an access rule, a server publishing rule, or a Web publishing rule")]
    HRESULT Type([out, retval] FpcPolicyRuleTypes *pVal);
	
	[propget, id(7), helpstring("Gets or sets a value from the FpcPolicyRuleActions enumerated type that specifies whether the rule allows or denies requests")]
    HRESULT Action([out, retval] FpcPolicyRuleActions *pVal);
    [propput, id(7), helpstring("Gets or sets a value from the FpcPolicyRuleActions enumerated type that specifies whether the rule allows or denies requests")]
    HRESULT Action([in] FpcPolicyRuleActions newVal);
	
	[propget, id(8), helpstring("Gets or sets a Boolean value that indicates whether the rule is enabled for logging")]
    HRESULT EnableLogging([out, retval] VARIANT_BOOL *pVal);
    [propput, id(8), helpstring("Gets or sets a Boolean value that indicates whether the rule is enabled for logging")]
    HRESULT EnableLogging([in] VARIANT_BOOL newVal);
	
	[propget, id(9), helpstring("Gets an FPCSelectionIPs object that specifies the complete set of source IP addresses to which the rule applies ")]
    HRESULT SourceSelectionIPs([out, retval] IFPCSelectionIPs **pVal);
	
	[propget, id(10), helpstring("Gets a Boolean value that indicates whether the rule applies at all times")]
    HRESULT AppliesAlways([out, retval] VARIANT_BOOL *pVal);
	
	[id(11), helpstring("Sets the policy rule to apply at all times regardless of the ScheduleUsed property")]
          HRESULT SetAppliesAlways();
        
    
	[id(12), helpstring("Sets the schedule for the rule")]
          HRESULT SetSchedule( BSTR ScheduleName);
        
    
	[propget, id(13), helpstring("Gets an FPCRef object that references the FPCSchedule object used to define the times when the rule applies")]
    HRESULT ScheduleUsed([out, retval] IFPCRef **pVal);
	
	[propget, id(14), helpstring("Gets the lower limit of the range of source ports to which the rule applies")]
    HRESULT LimitSourcePortLow([out, retval] long *pVal);
	
	[propget, id(15), helpstring("Gets the upper limit of the range of source ports to which the rule applies")]
    HRESULT LimitSourcePortHigh([out, retval] long *pVal);
	
	[id(16), helpstring("Sets the lower and upper limits of the range of source ports to which the rule applies")]
          HRESULT SetLimitSourcePortRange([in] long PortLow,
              [in] long PortHi);
        
    
	[propget, id(17), helpstring("Gets an FPCAccessProperties object that specifies a set of properties of the policy rule when the rule is configured as an access rule")]
    HRESULT AccessProperties([out, retval] IFPCAccessProperties **pVal);
	
	[propget, id(18), helpstring("Gets an FPCServerPublishingProperties object that specifies a set of properties of the policy rule when the rule is configured as a server publishing rule")]
    HRESULT ServerPublishingProperties([out, retval] IFPCServerPublishingProperties **pVal);
	
	[propget, id(19), helpstring("Gets an FPCWebPublishingProperties object that specifies a set of properties of the policy rule when the rule is configured as a Web publishing rule")]
    HRESULT WebPublishingProperties([out, retval] IFPCWebPublishingProperties **pVal);
	
	[propget, id(20), helpstring("Gets a value from the FpcSystemPolicyConfigGroupEnum enumerated type that identifies the system policy configuration group to which the rule belongs")]
    HRESULT SystemPolicyGroupId([out, retval] FpcSystemPolicyConfigGroupEnum *pVal);
	
};
	
[
object,
uuid(54e3e838-22e0-4c0b-bf3c-cddd7b7fa5ae),
dual,
helpstring("A policy rule"),
pointer_default(unique)
]
interface IFPCEEPolicyRule : IFPCPolicyRule
{
	[id(21), helpstring("Sets the schedule from specific scope to which the rule applies")]
          HRESULT SetScopedSchedule([in] FpcItemScope Scope,
              [in] BSTR ScheduleName);
        
    
};
	
[
object,
uuid(E3BAE4BE-AAA8-409D-8046-CDA32D0DD4EF),
dual,
helpstring("A policy rule"),
pointer_default(unique)
]
interface IFPCPolicyRule2 : IFPCEEPolicyRule
{
	[propget, id(22), helpstring("Gets a Boolean value that indicates whether the rule is a system policy rule that was added by a vendor or a third-party filter")]
    HRESULT VendorSystemPolicyRule([out, retval] VARIANT_BOOL *pVal);
	
};
	
[
object,
uuid(608760A0-2E87-4A6D-AEE0-93247C1AE136),
dual,
helpstring("A policy rule"),
pointer_default(unique)
]
interface IFPCPolicyRule3 : IFPCPolicyRule2
{
	[propget, id(23), helpstring("Gets an FPCMalwareInspectionProperties object that contains the malware inspection settings for the rule")]
    HRESULT MalwareInspectionProperties([out, retval] IFPCMalwareInspectionProperties **pVal);
	
	[propget, id(24), helpstring("Gets or sets a value from the FpcPolicyRuleGroups enumerated type that specifies the group to which the policy rule belongs")]
    HRESULT Group([out, retval] FpcPolicyRuleGroups *pVal);
    [propput, id(24), helpstring("Gets or sets a value from the FpcPolicyRuleGroups enumerated type that specifies the group to which the policy rule belongs")]
    HRESULT Group([in] FpcPolicyRuleGroups newVal);
	
};
	
[
object,
uuid(D16687F9-D244-4428-8CB7-30E327AFAC75),
dual,
nonextensible,
helpstring("A policy rule"),
pointer_default(unique)
]
interface IFPCPolicyRule4 : IFPCPolicyRule3
{
	[propget, id(25), helpstring("Gets an FPCRef object that references the FPCPolicyGroup object representing the policy group to which the rule belongs")]
    HRESULT PolicyGroupUsed([out, retval] IFPCRef **pVal);
	
	[id(26), helpstring("Sets the policy group for the rule")]
          HRESULT SetPolicyGroup([in] BSTR policyGroupName);
        
    
	[id(27), helpstring("Finds matched elements")]
          HRESULT FindMatchedElements([in] BSTR searchCriteria, [out, retval] BSTR *pMatchedElements);
        
    
};
	
[
object,
uuid(2fb1d1cc-f601-4d58-85ea-4a319662e907),
dual,
nonextensible,
helpstring("Administration Security"),
pointer_default(unique)
]
interface IFPCAdminSecurity : IFPCPersist
{
	[propget, id(1), helpstring("Gets the security roles definitions container")]
    HRESULT SecurityRoles([out, retval] IFPCSecurityRoles **pVal);
	
	[propget, id(2), helpstring("Gets the delegated administrators container")]
    HRESULT DelegatedAdmins([out, retval] IFPCDelegatedAdmins **pVal);
	
};
	
[
object,
uuid(213213c2-c2c5-42a9-a4e6-6a7f37207334),
dual,
nonextensible,
helpstring("Security Roles"),
pointer_default(unique)
]
interface IFPCSecurityRoles : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCSecurityRole** pItem);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

};
	
[
object,
uuid(91a7a9b9-0345-493e-ae0a-e76b2815a9ff ),
dual,
nonextensible,
helpstring("Security Role"),
pointer_default(unique)
]
interface IFPCSecurityRole : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the security role")]
    HRESULT Name([out, retval] BSTR *pVal);
	
	[propget, id(1), helpstring("Gets or sets the description of the security role")]
    HRESULT Description([out, retval] BSTR *pVal);
	
	[propget, id(2), helpstring("Gets or sets the definition of the security role")]
    HRESULT Definition([out, retval] BSTR *pVal);
	
	[propget, id(3), helpstring("Gets whether the security role is a preinstalled element that cannot be deleted")]
    HRESULT Predefined([out, retval] VARIANT_BOOL *pVal);
	
};
	
[
object,
uuid(4c177d69-a850-4c34-97ff-6e9dc98b9903),
dual,
helpstring("Delegated Admins"),
pointer_default(unique)
]
interface IFPCDelegatedAdmins : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item([in] VARIANT IndexOrAccount,
              [in,defaultvalue(NULL)] BSTR Role,
              [out,retval] IFPCDelegatedAdmin** pItem);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Adds a user to the collection as administrator of management servers")]
          HRESULT Add([in] BSTR Account,
              [in] BSTR Role,
              [out,retval] IFPCDelegatedAdmin** ppVal);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a user from the collection")]
          HRESULT Remove([in] VARIANT IndexOrAccount,
              [in,defaultvalue(NULL)] BSTR Role);
        
    
	[id(6), helpstring("Removes all of the accounts from the collection")]
          HRESULT RemoveAll();
        
    
};
	
[
object,
uuid(12009C93-BBAC-4cda-9396-867417271974),
dual,
nonextensible,
helpstring("Delegated Admins"),
pointer_default(unique)
]
interface IFPCEEDelegatedAdmins : IFPCDelegatedAdmins
{
	[id(7), helpstring("Adds a user to the collection")]
          HRESULT AddWithType([in] BSTR Account,
              [in] BSTR Role,
              [in] long DelegatedAdminType,
              [out,retval] IFPCDelegatedAdmin** ppVal);
        
    
};
	
[
object,
uuid(3e65121f-8a78-4aa9-bd19-28add3aa9f87),
dual,
helpstring("Delegated admin"),
pointer_default(unique)
]
interface IFPCDelegatedAdmin : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets the trustee (sid or name)")]
    HRESULT Account([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets the trustee (sid or name)")]
    HRESULT Account([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets the trustee's role")]
    HRESULT Role([out, retval] IFPCRef **pVal);
	
	[propget, id(3), helpstring("Gets whether the delegated admin object is a preinstalled and cannot be deleted")]
    HRESULT Predefined([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(4), helpstring(""), hidden]
    HRESULT Sid([out, retval] BSTR *pVal);
	
};
	
[
object,
uuid(9336BB06-937F-483b-99E5-2EF3128240C1),
dual,
nonextensible,
helpstring("Delegated admin"),
pointer_default(unique)
]
interface IFPCEEDelegatedAdmin : IFPCDelegatedAdmin
{
	[propget, id(5), helpstring("Returns type of the delegated admin")]
    HRESULT Type([out, retval] long *pVal);
	
	[propget, id(6), helpstring("Returns name of the account"), hidden]
    HRESULT Name([out, retval] BSTR *pVal);
	
};
	
[
object,
uuid(4D78D9C8-7087-44DB-8344-1C8F48FC3579),
dual,
helpstring("Collection of connectivity Verifiers"),
pointer_default(unique)
]
interface IFPCConnectivityVerifiers : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCConnectivityVerifier** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Adds a connectivity Verifier to the collection")]
          HRESULT Add([in] BSTR Name,
              [out,retval] IFPCConnectivityVerifier** ppNewConnectivityVerifier);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a connectivity verifier from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[propget, id(1), helpstring("Gets or sets the refresh rate in seconds")]
    HRESULT RefreshRate([out, retval] long *pVal);
    [propput, id(1), helpstring("Gets or sets the refresh rate in seconds")]
    HRESULT RefreshRate([in] long newVal);
	
};
	
[
object,
uuid(e5d1f209-1e2c-4b02-8ddb-5a82d1545112),
dual,
nonextensible,
helpstring("Collection of connectivity Verifiers"),
pointer_default(unique)
]
interface IFPCConnectivityVerifiers2 : IFPCConnectivityVerifiers
{
	[propget, id(2), helpstring("Gets or sets the minimal number of consecutive successful connectivity verification attempts before the connectivity verifier can issue a Connectivity Restored alert")]
    HRESULT SuccessesBeforeReportingSuccess([out, retval] long *pVal);
    [propput, id(2), helpstring("Gets or sets the minimal number of consecutive successful connectivity verification attempts before the connectivity verifier can issue a Connectivity Restored alert")]
    HRESULT SuccessesBeforeReportingSuccess([in] long newVal);
	
	[propget, id(3), helpstring("Gets or sets the minimal number of consecutive failed connectivity verification attempts before the connectivity verifier can issue a No Connectivity alert")]
    HRESULT FailuresBeforeReportingFailure([out, retval] long *pVal);
    [propput, id(3), helpstring("Gets or sets the minimal number of consecutive failed connectivity verification attempts before the connectivity verifier can issue a No Connectivity alert")]
    HRESULT FailuresBeforeReportingFailure([in] long newVal);
	
};
	
[
object,
uuid(3F7E4B1C-176D-40C6-B2D3-1F507E7DBF00),
dual,
helpstring("A connectivity Verifier"),
pointer_default(unique)
]
interface IFPCConnectivityVerifier : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the connectivity verifier")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the connectivity verifier")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the description of the connectivity verifier")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the description of the connectivity verifier")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets the server address")]
    HRESULT ServerAddress([out, retval] BSTR *pVal);
	
	[propget, id(3), helpstring("Gets or sets the group that this connectivity verifier belongs to")]
    HRESULT GroupType([out, retval] FpcConnectivityGroupType *pVal);
    [propput, id(3), helpstring("Gets or sets the group that this connectivity verifier belongs to")]
    HRESULT GroupType([in] FpcConnectivityGroupType newVal);
	
	[propget, id(4), helpstring("Gets the request type")]
    HRESULT RequestType([out, retval] FpcRequestType *pVal);
	
	[propget, id(5), helpstring("Gets the server TCP port")]
    HRESULT TCPPort([out, retval] long *pVal);
	
	[propget, id(6), helpstring("Gets or sets whether the connectivity verifier is enabled")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(6), helpstring("Gets or sets whether the connectivity verifier is enabled")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(7), helpstring("Gets or sets the round trip time treshold")]
    HRESULT Threshold([out, retval] long *pVal);
    [propput, id(7), helpstring("Gets or sets the round trip time treshold")]
    HRESULT Threshold([in] long newVal);
	
	[propget, id(8), helpstring("Gets or sets whether an alert will be triggered according to the treshold")]
    HRESULT AlertEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(8), helpstring("Gets or sets whether an alert will be triggered according to the treshold")]
    HRESULT AlertEnabled([in] VARIANT_BOOL newVal);
	
	[id(9), helpstring("Sets connectivity request properties")]
          HRESULT SetConnectivityRequest([in] BSTR ServerAddress,
              [in] FpcRequestType RequestType,
              [in,defaultvalue(1)] long TCPPort);
        
    
};
	
[
object,
uuid(E96006EB-4466-4b97-A8A8-2CC033B2C00E),
dual,
nonextensible,
helpstring("A connectivity Verifier"),
pointer_default(unique)
]
interface IFPCConnectivityVerifier2 : IFPCConnectivityVerifier
{
	[propget, id(10), helpstring("Gets the server TCP port")]
    HRESULT HostHeader([out, retval] BSTR *pVal);
	
	[id(11), helpstring("Sets connectivity request properties")]
          HRESULT SetHTTPConnectivityRequest([in] BSTR ServerAddress,
              [in] BSTR AltHostHeader);
        
    
};
	
[
object,
uuid(ACFF755E-C93A-44e4-BA72-CCA48E4642CE),
dual,
helpstring("IFPCLowLevelSettings Interface"),
pointer_default(unique)
]
interface IFPCLowLevelSettings : IDispatch
{
	[propget, id(0), helpstring("Gets the maximum size of the DNS cache for the Firewall service ")]
    HRESULT DnsCacheSize([out, retval] long *pVal);
    [propput, id(0), helpstring("Gets the maximum size of the DNS cache for the Firewall service ")]
    HRESULT DnsCacheSize([in] long newVal);
	
	[propget, id(1), helpstring("Gets the Dns Cache Negative TTL ")]
    HRESULT DnsCacheNegativeTtl([out, retval] long *pVal);
    [propput, id(1), helpstring("Gets the Dns Cache Negative TTL ")]
    HRESULT DnsCacheNegativeTtl([in] long newVal);
	
	[propget, id(2), helpstring("Gets the size of buffers used by the Firewall service when transferring data for connections using the TCP protocol")]
    HRESULT TcpBufferSize([out, retval] long *pVal);
    [propput, id(2), helpstring("Gets the size of buffers used by the Firewall service when transferring data for connections using the TCP protocol")]
    HRESULT TcpBufferSize([in] long newVal);
	
	[propget, id(3), helpstring("Gets the size of buffers used by the Firewall service when transferring data for connections using the UDP protocol")]
    HRESULT UdpBufferSize([out, retval] long *pVal);
    [propput, id(3), helpstring("Gets the size of buffers used by the Firewall service when transferring data for connections using the UDP protocol")]
    HRESULT UdpBufferSize([in] long newVal);
	
	[propget, id(4), helpstring("Gets the maximum number of pending IOs of connections ")]
    HRESULT MaxNumberOfPendingIoOfConnections([out, retval] long *pVal);
    [propput, id(4), helpstring("Gets the maximum number of pending IOs of connections ")]
    HRESULT MaxNumberOfPendingIoOfConnections([in] long newVal);
	
	[propget, id(5), helpstring("Gets the maximum number of pending accepts ")]
    HRESULT FwxListenerMaxPendingAccepts([out, retval] long *pVal);
    [propput, id(5), helpstring("Gets the maximum number of pending accepts ")]
    HRESULT FwxListenerMaxPendingAccepts([in] long newVal);
	
	[propget, id(6), helpstring("Gets the maximum percentage for listeners ")]
    HRESULT FwxListenerMaxPercent([out, retval] long *pVal);
    [propput, id(6), helpstring("Gets the maximum percentage for listeners ")]
    HRESULT FwxListenerMaxPercent([in] long newVal);
	
	[propget, id(7), helpstring("Gets the minimal percentage for listeners ")]
    HRESULT FwxListenerMinPercent([out, retval] long *pVal);
    [propput, id(7), helpstring("Gets the minimal percentage for listeners ")]
    HRESULT FwxListenerMinPercent([in] long newVal);
	
	[propget, id(8), helpstring("Gets the listeners' percent to create ")]
    HRESULT FwxListenerToCreatePercent([out, retval] long *pVal);
    [propput, id(8), helpstring("Gets the listeners' percent to create ")]
    HRESULT FwxListenerToCreatePercent([in] long newVal);
	
	[propget, id(9), helpstring("Gets the listeners' percent to kill ")]
    HRESULT FwxListenerToKillPercent([out, retval] long *pVal);
    [propput, id(9), helpstring("Gets the listeners' percent to kill ")]
    HRESULT FwxListenerToKillPercent([in] long newVal);
	
	[propget, id(10), helpstring("Gets the maximum size of the DNS cache in KB ")]
    HRESULT DnsCacheRecordMaxKB([out, retval] long *pVal);
    [propput, id(10), helpstring("Gets the maximum size of the DNS cache in KB ")]
    HRESULT DnsCacheRecordMaxKB([in] long newVal);
	
	[propget, id(11), helpstring("Gets the default allowed addresses in BindForClient ")]
    HRESULT DefaultAllowedAddressesInBindForClient([out, retval] long *pVal);
    [propput, id(11), helpstring("Gets the default allowed addresses in BindForClient ")]
    HRESULT DefaultAllowedAddressesInBindForClient([in] long newVal);
	
	[propget, id(12), helpstring("Gets the default allowed addresses in AllowFutureConnect ")]
    HRESULT DefaultAllowedAddressesInAllowFutureConnect([out, retval] long *pVal);
    [propput, id(12), helpstring("Gets the default allowed addresses in AllowFutureConnect ")]
    HRESULT DefaultAllowedAddressesInAllowFutureConnect([in] long newVal);
	
};
	
[
object,
uuid(78AFA1EC-8648-4be1-9C0D-A2E8B27C258B),
dual,
helpstring("IFPCLowLevelSettings2 Interface"),
pointer_default(unique)
]
interface IFPCLowLevelSettings2 : IFPCLowLevelSettings
{
	[propget, id(13), helpstring("Gets or sets the default number of elements credential cache can hold")]
    HRESULT CredentialsCacheSize([out, retval] long *pVal);
    [propput, id(13), helpstring("Gets or sets the default number of elements credential cache can hold")]
    HRESULT CredentialsCacheSize([in] long newVal);
	
};
	
[
object,
uuid(04B8462F-5673-4222-95DE-708A738A1C19),
dual,
nonextensible,
helpstring("IFPCLowLevelSettings3 Interface"),
pointer_default(unique)
]
interface IFPCLowLevelSettings3 : IFPCLowLevelSettings2
{
	[propget, id(14), helpstring("Gets or sets the number of elements that can be stored in the cloned certificates cache"), hidden]
    HRESULT ClonedCertificatesCacheSize([out, retval] long *pVal);
    [propput, id(14), helpstring("Gets or sets the number of elements that can be stored in the cloned certificates cache"), hidden]
    HRESULT ClonedCertificatesCacheSize([in] long newVal);
	
	[propget, id(15), helpstring("Gets or sets a comma-delimited list of the GUIDs of the Windows Filtering Platform callouts that are trusted not to interfere Forefront TMG with functionality")]
    HRESULT TrustedWindowsFilteringPlatformCalloutGuids([out, retval] BSTR *pVal);
    [propput, id(15), helpstring("Gets or sets a comma-delimited list of the GUIDs of the Windows Filtering Platform callouts that are trusted not to interfere Forefront TMG with functionality")]
    HRESULT TrustedWindowsFilteringPlatformCalloutGuids([in] BSTR newVal);
	
};
	
[
object,
uuid(03D5392E-FDBC-46B2-8B34-D2306ECBC074),
dual,
helpstring("NLB Cluster"),
pointer_default(unique)
]
interface IFPCEENLBCluster : IDispatch
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets whether NLB is enabled on the network")]
    HRESULT NLBEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets whether NLB is enabled on the network")]
    HRESULT NLBEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(1), helpstring("Gets the VIP of the cluster")]
    HRESULT VIP([out, retval] BSTR *pVal);
	
	[propget, id(2), helpstring("Gets the mask for the VIP of the cluster")]
    HRESULT Mask([out, retval] BSTR *pVal);
	
	[id(3), helpstring("Sets the VIP and its mask")]
          HRESULT SetVIPAndMask([in] BSTR newIPAddress,
              [in] BSTR newIPMask);
        
    
	[propget, id(4), helpstring("Gets or sets the NLB operation mode")]
    HRESULT OperationMode([out, retval] FpcNLBOperationMode *pVal);
    [propput, id(4), helpstring("Gets or sets the NLB operation mode")]
    HRESULT OperationMode([in] FpcNLBOperationMode newVal);
	
};
	
[
object,
uuid(cfd33e64-006d-40e8-bfda-3b6f22c03944),
dual,
nonextensible,
helpstring("NLB Cluster"),
pointer_default(unique)
]
interface IFPCNLBCluster2 : IFPCEENLBCluster
{
	[propget, id(5), helpstring("Gets a reference to the additional VIPs of the cluster")]
    HRESULT AdditionalVIPs([out, retval] IFPCIPAddresses **pVal);
	
};
	
[
object,
uuid(FD6E6EE0-6FDB-4BC2-BDD9-E726813677E1),
dual,
helpstring("NLB config"),
pointer_default(unique)
]
interface IFPCEENLBConfiguration : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets a value from the FpcNLBAffinity enumerated type that specifies the type of affinity for the bidirectional affinity (BDA) team in the array")]
    HRESULT BDATeamAffinity([out, retval] FpcNLBAffinity *pVal);
    [propput, id(1), helpstring("Gets or sets a value from the FpcNLBAffinity enumerated type that specifies the type of affinity for the bidirectional affinity (BDA) team in the array")]
    HRESULT BDATeamAffinity([in] FpcNLBAffinity newVal);
	
	[propget, id(2), helpstring("Gets the name of the master cluster in the bidirectional affinity (BDA) team for the array")]
    HRESULT BDATeamMaster([out, retval] BSTR *pVal);
	
	[propget, id(3), helpstring("Gets or sets a Boolean value that indicates whether NLB integration is enabled in the array")]
    HRESULT NLBIntegrationEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(3), helpstring("Gets or sets a Boolean value that indicates whether NLB integration is enabled in the array")]
    HRESULT NLBIntegrationEnabled([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(b95cb69a-d340-49d7-ae7e-855c9e4cb56e),
dual,
nonextensible,
helpstring("NLB configuration"),
pointer_default(unique)
]
interface IFPCNLBConfiguration2 : IFPCEENLBConfiguration
{
	[propget, id(4), helpstring("Gets or sets a Boolean value that indicates whether the NLB settings will be cleared when NLB integration is disabled")]
    HRESULT NLBIntegrationClearUponDisable([out, retval] VARIANT_BOOL *pVal);
    [propput, id(4), helpstring("Gets or sets a Boolean value that indicates whether the NLB settings will be cleared when NLB integration is disabled")]
    HRESULT NLBIntegrationClearUponDisable([in] VARIANT_BOOL newVal);
	
	[propget, id(5), helpstring("Gets or sets the NLB Stickiness timeout"), hidden]
    HRESULT StickinessTimeoutInMinutes([out, retval] long *pVal);
    [propput, id(5), helpstring("Gets or sets the NLB Stickiness timeout"), hidden]
    HRESULT StickinessTimeoutInMinutes([in] long newVal);
	
};
	
[
object,
uuid(7ae72b46-b7da-47ad-9002-ab0f0786278d),
dual,
nonextensible,
helpstring("A domain mapping which maps domain name to other domain names"),
pointer_default(unique)
]
interface IFPCEEDomainMapping : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the domain that should be mapped")]
    HRESULT DomainName([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the domain that should be mapped")]
    HRESULT DomainName([in] BSTR newVal);
	
	[id(2), helpstring("Returns a specific domain name from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] BSTR* pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Adds a new domain name to the object")]
          HRESULT Add( BSTR Name);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a domain name from the object")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
};
	
[
object,
uuid(067f212e-b6a7-49e4-82bc-c7a4eb2cb984),
dual,
nonextensible,
helpstring("Collection of domain mappings"),
pointer_default(unique)
]
interface IFPCEEDomainMappings : IFPCPersist
{
	[id(DISPID_ADD), helpstring("Adds a domain mapping to the collection")]
          HRESULT Add( BSTR Name,
              [out,retval] IFPCEEDomainMapping** ppNewTemplate);
        
    
	[id(DISPID_REMOVE), helpstring("Removes a domain name set from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCEEDomainMapping** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

};
	
[
object,
uuid(2D33DE05-8B02-4F65-93CB-CF3686377A1D),
dual,
helpstring("Content delivery settings object"),
pointer_default(unique)
]
interface IFPCContentDeliverySettings : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets the time, in seconds, that will elapse after receiving a response from the server before content delivery is started")]
    HRESULT DeliveryDelay([out, retval] long *pVal);
    [propput, id(1), helpstring("Gets or sets the time, in seconds, that will elapse after receiving a response from the server before content delivery is started")]
    HRESULT DeliveryDelay([in] long newVal);
	
	[propget, id(2), helpstring("Gets or sets the time, in seconds, that will elapse before the progress information is refreshed")]
    HRESULT ProgressRefreshDelay([out, retval] long *pVal);
    [propput, id(2), helpstring("Gets or sets the time, in seconds, that will elapse before the progress information is refreshed")]
    HRESULT ProgressRefreshDelay([in] long newVal);
	
	[propget, id(3), helpstring("Gets or sets a Boolean value that indicates whether progress notification is enabled")]
    HRESULT ProgressNotificationEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(3), helpstring("Gets or sets a Boolean value that indicates whether progress notification is enabled")]
    HRESULT ProgressNotificationEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(4), helpstring("Gets or sets the maximum time, in seconds, during which inspected content will be available for retrieval from Forefront TMG")]
    HRESULT ProgressNotificationContentRetrievalTimeout([out, retval] long *pVal);
    [propput, id(4), helpstring("Gets or sets the maximum time, in seconds, during which inspected content will be available for retrieval from Forefront TMG")]
    HRESULT ProgressNotificationContentRetrievalTimeout([in] long newVal);
	
	[propget, id(5), helpstring("Gets or sets the maximum time, in seconds, during which inspected content will be available for repeated retrieval from Forefront TMG after the first download request")]
    HRESULT ProgressNotificationRepeatedRetrievalTimeout([out, retval] long *pVal);
    [propput, id(5), helpstring("Gets or sets the maximum time, in seconds, during which inspected content will be available for repeated retrieval from Forefront TMG after the first download request")]
    HRESULT ProgressNotificationRepeatedRetrievalTimeout([in] long newVal);
	
	[propget, id(6), helpstring("Gets or sets the preferred language for progress notifications")]
    HRESULT ProgressNotificationPagesLanguage([out, retval] BSTR *pVal);
    [propput, id(6), helpstring("Gets or sets the preferred language for progress notifications")]
    HRESULT ProgressNotificationPagesLanguage([in] BSTR newVal);
	
	[propget, id(7), helpstring("Gets or sets a Boolean value that indicates whether standard trickling is enabled")]
    HRESULT StandardTricklingEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(7), helpstring("Gets or sets a Boolean value that indicates whether standard trickling is enabled")]
    HRESULT StandardTricklingEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(8), helpstring("Gets or sets the size of the first portion of the content sent to the client when standard trickling is used")]
    HRESULT StandardTricklingInitialSize([out, retval] long *pVal);
    [propput, id(8), helpstring("Gets or sets the size of the first portion of the content sent to the client when standard trickling is used")]
    HRESULT StandardTricklingInitialSize([in] long newVal);
	
	[propget, id(9), helpstring("Gets or sets the size of subsequent portions of the content sent to the client when standard trickling is used")]
    HRESULT StandardTricklingSize([out, retval] long *pVal);
    [propput, id(9), helpstring("Gets or sets the size of subsequent portions of the content sent to the client when standard trickling is used")]
    HRESULT StandardTricklingSize([in] long newVal);
	
	[propget, id(10), helpstring("Gets or sets the time interval, in seconds, between successive portions, sent to the client when standard trickling is used")]
    HRESULT StandardTricklingInterval([out, retval] long *pVal);
    [propput, id(10), helpstring("Gets or sets the time interval, in seconds, between successive portions, sent to the client when standard trickling is used")]
    HRESULT StandardTricklingInterval([in] long newVal);
	
	[propget, id(11), helpstring("Gets or sets a Boolean value that indicates whether fast trickling is enabled")]
    HRESULT FastTricklingEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(11), helpstring("Gets or sets a Boolean value that indicates whether fast trickling is enabled")]
    HRESULT FastTricklingEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(12), helpstring("Gets or sets a value from the FpcFastTricklingMode enumerated type that specifies the tradeoff between user experience and performance for fast trickling")]
    HRESULT FastTricklingMode([out, retval] FpcFastTricklingMode *pVal);
    [propput, id(12), helpstring("Gets or sets a value from the FpcFastTricklingMode enumerated type that specifies the tradeoff between user experience and performance for fast trickling")]
    HRESULT FastTricklingMode([in] FpcFastTricklingMode newVal);
	
	[propget, id(13), helpstring("Gets an FPCContentTypeSet collection that holds a list of the MIME content types and file name extensions for which HTML comforting will be used")]
    HRESULT ProgressNotificationTypes([out, retval] IFPCContentTypeSet2 **pVal);
	
	[propget, id(14), helpstring("Gets an FPCContentTypeSet collection that holds a list of the MIME content types and file name extensions for which fast trickling will be used")]
    HRESULT FastTricklingTypes([out, retval] IFPCContentTypeSet2 **pVal);
	
	[propget, id(15), helpstring("Gets an FPCContentTypeSet collection that holds a list of the MIME content types and file name extensions for which no trickling will ever be used")]
    HRESULT NoTricklingTypes([out, retval] IFPCContentTypeSet2 **pVal);
	
};
	
[
object,
uuid(CEF496CD-E8A8-4A4C-9773-40F262205777),
dual,
nonextensible,
helpstring("Content delivery settings object"),
pointer_default(unique)
]
interface IFPCContentDeliverySettings2 : IFPCContentDeliverySettings
{
	[propget, id(16), helpstring("Gets or sets a value from the FpcMalwareInspectionContentDeliveryMethod enumerated type that specifies the default content delivery method")]
    HRESULT DefaultContentDeliveryMethod([out, retval] FpcMalwareInspectionContentDeliveryMethod *pVal);
    [propput, id(16), helpstring("Gets or sets a value from the FpcMalwareInspectionContentDeliveryMethod enumerated type that specifies the default content delivery method")]
    HRESULT DefaultContentDeliveryMethod([in] FpcMalwareInspectionContentDeliveryMethod newVal);
	
};
	
[
object,
uuid(C29D8822-0B4D-4651-AE0B-6952DB0320D5),
dual,
helpstring("Outbound HTTPS inspection configuration object"),
pointer_default(unique)
]
interface IFPCOutboundHTTPSInspectionConfiguration : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets a Boolean value that indicates whether outbound HTTPS inspection is enabled")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets a Boolean value that indicates whether outbound HTTPS inspection is enabled")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(2), helpstring("Gets or sets a value from the FpcKeySizeType enumerated type that specifies the size of the public and private keys for locally generated certificates")]
    HRESULT KeySize([out, retval] FpcKeySizeType *pVal);
    [propput, id(2), helpstring("Gets or sets a value from the FpcKeySizeType enumerated type that specifies the size of the public and private keys for locally generated certificates")]
    HRESULT KeySize([in] FpcKeySizeType newVal);
	
	[propget, id(3), helpstring("Gets an FPCRefs collection that contains references to the FPCDomainNameSet collections defining the domain name sets that are included in the exception list")]
    HRESULT DomainNameSetsExceptionList([out, retval] IFPCRefs **pVal);
	
	[id(4), helpstring("Creates a new self-signed root certification authority certificate that will be used for re-signing certificates by Forefront TMG")]
          HRESULT CreateNewRootCACertificate([in] BSTR IssuerName,
              [in] DATE ExpiredDate,
              [in] BSTR IssuerStatement);
        
    
	[id(5), helpstring("Exports the root certification authority certificate currently used by Forefront TMG to a file")]
          HRESULT ExportRootCACertificateFile([in] BSTR FileName);
        
    
	[id(6), helpstring("Exports the root certification authority certificate currently used by Forefront TMG to a blob in physical memory"), hidden]
          HRESULT ExportRootCACertificateBin([out,size_is(*pBlobSize)] BYTE** pBlob,
              [in,out] DWORD* pBlobSize);
        
    
	[propget, id(7), helpstring("Gets or sets a Boolean value that indicates whether users will be notified that HTTPS inspection is performed")]
    HRESULT NotifyUsers([out, retval] VARIANT_BOOL *pVal);
    [propput, id(7), helpstring("Gets or sets a Boolean value that indicates whether users will be notified that HTTPS inspection is performed")]
    HRESULT NotifyUsers([in] VARIANT_BOOL newVal);
	
	[propget, id(8), helpstring("Gets or sets a Boolean value that indicates whether server certificate revocation will be checked")]
    HRESULT CheckServerCertificateRevocation([out, retval] VARIANT_BOOL *pVal);
    [propput, id(8), helpstring("Gets or sets a Boolean value that indicates whether server certificate revocation will be checked")]
    HRESULT CheckServerCertificateRevocation([in] VARIANT_BOOL newVal);
	
	[propget, id(9), helpstring("Gets or sets a Boolean value that indicates whether a server certificate that is not yet valid will be blocked")]
    HRESULT BlockNotYetValidServerCertificate([out, retval] VARIANT_BOOL *pVal);
    [propput, id(9), helpstring("Gets or sets a Boolean value that indicates whether a server certificate that is not yet valid will be blocked")]
    HRESULT BlockNotYetValidServerCertificate([in] VARIANT_BOOL newVal);
	
	[propget, id(10), helpstring("Gets or sets a Boolean value that indicates whether an expired server certificate will be blocked")]
    HRESULT BlockExpiredServerCertificate([out, retval] VARIANT_BOOL *pVal);
    [propput, id(10), helpstring("Gets or sets a Boolean value that indicates whether an expired server certificate will be blocked")]
    HRESULT BlockExpiredServerCertificate([in] VARIANT_BOOL newVal);
	
	[propget, id(11), helpstring("Gets or sets the number of days during which an expired certificate will be blocked")]
    HRESULT DaysToBlockExpiredServerCertificate([out, retval] long *pVal);
    [propput, id(11), helpstring("Gets or sets the number of days during which an expired certificate will be blocked")]
    HRESULT DaysToBlockExpiredServerCertificate([in] long newVal);
	
	[id(12), helpstring("Imports the root certification authority certificate specified by the user for use by Forefront TMG")]
          HRESULT ImportRootCACertificate([in] BSTR FileName,
              [in] BSTR Password);
        
    
	[id(13), helpstring("Installs the root certification authority certificate on client computers in the local domain")]
          HRESULT DeployCertificateInActiveDirectory([in] BSTR Domain,
              [in] BSTR UserName,
              [in] BSTR Password);
        
    
	[id(14), helpstring("Returns True if a root certification authority certificate exists")]
          HRESULT RootCACertificateExists([out,retval] VARIANT_BOOL* pVal);
        
    
	[propget, id(15), helpstring("Gets an FPCRefs collection that contains references to the FPCUrlCategories collections defining the URL categories that are included in the exception list")]
    HRESULT UrlCategoriesExceptionList([out, retval] IFPCRefs **pVal);
	
	[propget, id(16), helpstring("Gets or sets the number of days after which the cloned certificate will expire"), hidden]
    HRESULT ClonedCertificateExpirationPeriodInDays([out, retval] long *pVal);
    [propput, id(16), helpstring("Gets or sets the number of days after which the cloned certificate will expire"), hidden]
    HRESULT ClonedCertificateExpirationPeriodInDays([in] long newVal);
	
	[propget, id(17), helpstring("Gets or sets a value from the FpcHttpsInspectionWithCertificateValidationType enumerated type that specifies whether there will be certificate validation with HTTPS inspection or just certificate validation when HTTPS inspection is enabled")]
    HRESULT InspectionWithCertificateValidation([out, retval] FpcHttpsInspectionWithCertificateValidationType *pVal);
    [propput, id(17), helpstring("Gets or sets a value from the FpcHttpsInspectionWithCertificateValidationType enumerated type that specifies whether there will be certificate validation with HTTPS inspection or just certificate validation when HTTPS inspection is enabled")]
    HRESULT InspectionWithCertificateValidation([in] FpcHttpsInspectionWithCertificateValidationType newVal);
	
	[propget, id(18), helpstring("Gets an FPCCACertificate object that holds the root certification authority certificate for HTTPS inspection.")]
    HRESULT CACertificate([out, retval] IFPCCACertificate **pVal);
	
};
	
[
object,
uuid(d5a0bfb7-a8e2-42d0-bb18-ca143d6509a4),
dual,
nonextensible,
helpstring("Outbound HTTPS inspection configuration object"),
pointer_default(unique)
]
interface IFPCOutboundHTTPSInspectionConfiguration2 : IFPCOutboundHTTPSInspectionConfiguration
{
	[propget, id(19), helpstring("Gets an FPCRefs collection that contains references to the FPCUrlCategorySet collections defining the URL category sets that are included in the exception list")]
    HRESULT UrlCategorySetsExceptionList([out, retval] IFPCRefs **pVal);
	
	[propget, id(20), helpstring("Gets an FPCSources object that contains the list of sources that are included in the exception list")]
    HRESULT SourcesExceptionList([out, retval] IFPCSources **pVal);
	
	[propget, id(21), helpstring("Gets or sets the OID of the algorithm to use when signing a certificate")]
    HRESULT CertificateSigningAlgorithm([out, retval] BSTR *pVal);
    [propput, id(21), helpstring("Gets or sets the OID of the algorithm to use when signing a certificate")]
    HRESULT CertificateSigningAlgorithm([in] BSTR newVal);
	
};
	
[
object,
uuid(B8439BCF-AB2D-4e0d-BAAC-4071B89A86F7),
dual,
nonextensible,
helpstring("Certification Authority certificate of Outbound HTTPS inspection configuration object"),
pointer_default(unique)
]
interface IFPCCACertificate : IFPCPersist
{
};
	
[
object,
uuid(6ED6B250-CE7D-4b9d-A2D2-9EED70C68AE8),
dual,
nonextensible,
helpstring("A mapping that assigns a category to a URL"),
pointer_default(unique)
]
interface IFPCUrlToCategoryMapping : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets the URL that is mapped")]
    HRESULT URL([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the URL that is mapped")]
    HRESULT URL([in] BSTR newVal);
	
	[id(2), helpstring("Sets the corresponding URL category based on the catetory identifier specified")]
          HRESULT SetUrlCategory( FpcUrlCategoryT UrlCategoryID);
        
    
	[propget, id(3), helpstring("Gets an FPCRef object that references the FPCUrlCategory object representing the corresponding URL category")]
    HRESULT UrlCategory([out, retval] IFPCRef **pVal);
	
};
	
[
object,
uuid(B0641C17-F5D4-48c3-8E89-F60C77E7CCC2),
dual,
nonextensible,
helpstring("Collection of mappings that assign a category to a URL"),
pointer_default(unique)
]
interface IFPCUrlToCategoryMappings : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns the requested FPCUrlToCategoryMapping object from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCUrlToCategoryMapping** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_ADD), helpstring("Creates a new FPCUrlToCategoryMapping object in the collection and returns a reference to it")]
          HRESULT Add( BSTR URL,
               FpcUrlCategoryT UrlCategoryID,
              [out,retval] IFPCUrlToCategoryMapping** ppMapping);
        
    
	[id(DISPID_REMOVE), helpstring("Removes FPCUrlToCategoryMapping object from the collection")]
          HRESULT Remove( VARIANT v);
        
    
};
	
[
object,
uuid(0954D84B-5BC5-443B-A968-B5166439F9D5),
dual,
helpstring("Malware inspection settings object"),
pointer_default(unique)
]
interface IFPCMalwareInspectionSettings : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets a Boolean value that indicates whether malware inspection is enabled")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets a Boolean value that indicates whether malware inspection is enabled")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(2), helpstring("Gets an FPCMalwareInspectionScannerSettings object that contains the malware inspection scanner settings")]
    HRESULT ScannerSettings([out, retval] IFPCMalwareInspectionScannerSettings **pVal);
	
	[propget, id(3), helpstring("Gets an FPCTemporaryStorageSettings object that contains the temporary storage settings")]
    HRESULT TemporaryStorageSettings([out, retval] IFPCTemporaryStorageSettings **pVal);
	
	[propget, id(4), helpstring("Gets an FPCContentDeliverySettings object that contains the content delivery settings")]
    HRESULT ContentDeliverySettings([out, retval] IFPCContentDeliverySettings **pVal);
	
	[propget, id(5), helpstring("Gets an FPCDestinations object that contains the list of destinations that are exempt from malware inspection")]
    HRESULT ExemptedDestinations([out, retval] IFPCDestinations **pVal);
	
	[propget, id(6), helpstring("Gets an FPCProtocolMessageDefinitions collection that contains the list of types of protocol messages that are exempt from malware inspection")]
    HRESULT ExemptedProtocolMessages([out, retval] IFPCProtocolMessageDefinitions **pVal);
	
};
	
[
object,
uuid(EF4A29E3-0D8D-48b5-B952-459A88A2595E),
dual,
nonextensible,
helpstring("Malware inspection settings object"),
pointer_default(unique)
]
interface IFPCMalwareInspectionSettings2 : IFPCMalwareInspectionSettings
{
	[propget, id(7), helpstring("Gets an FPCSources object that contains the list of sources that are exempt from malware inspection")]
    HRESULT ExemptedSources([out, retval] IFPCSources **pVal);
	
	[propget, id(8), helpstring("Gets or sets a Boolean value that indicates whether Malware Inspection Filter should block all traffic allowed by a rule with malware inspection enabled or should skip malware inspection for such traffic if the definitions folder is not specified")]
    HRESULT BlockWhenDefinitionsFolderNotSpecified([out, retval] VARIANT_BOOL *pVal);
    [propput, id(8), helpstring("Gets or sets a Boolean value that indicates whether Malware Inspection Filter should block all traffic allowed by a rule with malware inspection enabled or should skip malware inspection for such traffic if the definitions folder is not specified")]
    HRESULT BlockWhenDefinitionsFolderNotSpecified([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(e50d3109-f259-4677-b27f-05cbc0dddedd),
dual,
nonextensible,
helpstring("Temporary storage settings object"),
pointer_default(unique)
]
interface IFPCTemporaryStorageSettings : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets the amount of memory used, in kilobytes, at which temporary storage will switch to disk")]
    HRESULT DiskStorageThresholdInKilobytes([out, retval] long *pVal);
    [propput, id(1), helpstring("Gets or sets the amount of memory used, in kilobytes, at which temporary storage will switch to disk")]
    HRESULT DiskStorageThresholdInKilobytes([in] long newVal);
	
	[propget, id(2), helpstring("Gets or sets the folder for temporarily storing files for malware inspection")]
    HRESULT StorageFolder([out, retval] BSTR *pVal);
    [propput, id(2), helpstring("Gets or sets the folder for temporarily storing files for malware inspection")]
    HRESULT StorageFolder([in] BSTR newVal);
	
	[propget, id(3), helpstring("Gets or sets a Boolean value that indicates whether the upper limit on the total amount of disk space used for temporary storage is enforced")]
    HRESULT LimitTotalStorageSize([out, retval] VARIANT_BOOL *pVal);
    [propput, id(3), helpstring("Gets or sets a Boolean value that indicates whether the upper limit on the total amount of disk space used for temporary storage is enforced")]
    HRESULT LimitTotalStorageSize([in] VARIANT_BOOL newVal);
	
	[propget, id(4), helpstring("Gets or sets the maximum total disk space that may be used for temporary storage, in gigabytes")]
    HRESULT MaxTotalStorageSizeInGigas([out, retval] long *pVal);
    [propput, id(4), helpstring("Gets or sets the maximum total disk space that may be used for temporary storage, in gigabytes")]
    HRESULT MaxTotalStorageSizeInGigas([in] long newVal);
	
};
	
[
object,
uuid(0BE0548C-7F30-40AF-9C2D-DFE40EC2DF99),
dual,
nonextensible,
helpstring("Malware inspection scanner settings object"),
pointer_default(unique)
]
interface IFPCMalwareInspectionScannerSettings : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets a Boolean value that indicates whether the malware inspection scanner will attempt to clean infected files")]
    HRESULT CleanInfectedFiles([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets a Boolean value that indicates whether the malware inspection scanner will attempt to clean infected files")]
    HRESULT CleanInfectedFiles([in] VARIANT_BOOL newVal);
	
	[propget, id(2), helpstring("Gets or sets a Boolean value that indicates whether the malware inspection scanner will block files that contain low or medium level threats")]
    HRESULT BlockLowAndMediumLevelThreats([out, retval] VARIANT_BOOL *pVal);
    [propput, id(2), helpstring("Gets or sets a Boolean value that indicates whether the malware inspection scanner will block files that contain low or medium level threats")]
    HRESULT BlockLowAndMediumLevelThreats([in] VARIANT_BOOL newVal);
	
	[propget, id(3), helpstring("Gets or sets a Boolean value that indicates whether the malware inspection scanner will block suspicious files")]
    HRESULT BlockSuspiciousFiles([out, retval] VARIANT_BOOL *pVal);
    [propput, id(3), helpstring("Gets or sets a Boolean value that indicates whether the malware inspection scanner will block suspicious files")]
    HRESULT BlockSuspiciousFiles([in] VARIANT_BOOL newVal);
	
	[propget, id(4), helpstring("Gets or sets a Boolean value that indicates whether the malware inspection scanner will block corrupt files")]
    HRESULT BlockCorruptFiles([out, retval] VARIANT_BOOL *pVal);
    [propput, id(4), helpstring("Gets or sets a Boolean value that indicates whether the malware inspection scanner will block corrupt files")]
    HRESULT BlockCorruptFiles([in] VARIANT_BOOL newVal);
	
	[propget, id(5), helpstring("Gets or sets a Boolean value that indicates whether the malware inspection scanner will block encrypted files")]
    HRESULT BlockEncryptedFiles([out, retval] VARIANT_BOOL *pVal);
    [propput, id(5), helpstring("Gets or sets a Boolean value that indicates whether the malware inspection scanner will block encrypted files")]
    HRESULT BlockEncryptedFiles([in] VARIANT_BOOL newVal);
	
	[propget, id(6), helpstring("Gets or sets a Boolean value that indicates whether the malware inspection scanner will block files with unknown encoding or encryption")]
    HRESULT BlockUnknownEncoding([out, retval] VARIANT_BOOL *pVal);
    [propput, id(6), helpstring("Gets or sets a Boolean value that indicates whether the malware inspection scanner will block files with unknown encoding or encryption")]
    HRESULT BlockUnknownEncoding([in] VARIANT_BOOL newVal);
	
	[propget, id(7), helpstring("Gets or sets a Boolean value that indicates whether the malware inspection scanner will block files that it cannot scan")]
    HRESULT BlockNonscannableFiles([out, retval] VARIANT_BOOL *pVal);
    [propput, id(7), helpstring("Gets or sets a Boolean value that indicates whether the malware inspection scanner will block files that it cannot scan")]
    HRESULT BlockNonscannableFiles([in] VARIANT_BOOL newVal);
	
	[propget, id(8), helpstring("Gets or sets a Boolean value that indicates whether the malware inspection scanner will block files whose scanning time exceeds the limit specified in the MaxScanTime property")]
    HRESULT BlockIfExceedsScanTime([out, retval] VARIANT_BOOL *pVal);
    [propput, id(8), helpstring("Gets or sets a Boolean value that indicates whether the malware inspection scanner will block files whose scanning time exceeds the limit specified in the MaxScanTime property")]
    HRESULT BlockIfExceedsScanTime([in] VARIANT_BOOL newVal);
	
	[propget, id(9), helpstring("Gets or sets the maximum scanning time, in seconds, after which the malware inspection scanner will block the file if the limit on the scanning time is enforced")]
    HRESULT MaxScanTime([out, retval] long *pVal);
    [propput, id(9), helpstring("Gets or sets the maximum scanning time, in seconds, after which the malware inspection scanner will block the file if the limit on the scanning time is enforced")]
    HRESULT MaxScanTime([in] long newVal);
	
	[propget, id(10), helpstring("Gets or sets a Boolean value that indicates whether the malware inspection scanner will block files whose size exceeds the limit specified in the MaxFileSizeInMegs property")]
    HRESULT BlockIfExceedsFileSizeInMegs([out, retval] VARIANT_BOOL *pVal);
    [propput, id(10), helpstring("Gets or sets a Boolean value that indicates whether the malware inspection scanner will block files whose size exceeds the limit specified in the MaxFileSizeInMegs property")]
    HRESULT BlockIfExceedsFileSizeInMegs([in] VARIANT_BOOL newVal);
	
	[propget, id(11), helpstring("Gets or sets the maximum file size, in megabytes, above which the malware inspection scanner will block files if the limit on the file size is enforced")]
    HRESULT MaxFileSizeInMegs([out, retval] long *pVal);
    [propput, id(11), helpstring("Gets or sets the maximum file size, in megabytes, above which the malware inspection scanner will block files if the limit on the file size is enforced")]
    HRESULT MaxFileSizeInMegs([in] long newVal);
	
	[propget, id(12), helpstring("Gets or sets a Boolean value that indicates whether the malware inspection scanner will block archives whose unpacked content size exceeds the limit specified in the MaxUnpackedContentSizeInMegs property")]
    HRESULT BlockIfExceedsUnpackedContentSizeInMegs([out, retval] VARIANT_BOOL *pVal);
    [propput, id(12), helpstring("Gets or sets a Boolean value that indicates whether the malware inspection scanner will block archives whose unpacked content size exceeds the limit specified in the MaxUnpackedContentSizeInMegs property")]
    HRESULT BlockIfExceedsUnpackedContentSizeInMegs([in] VARIANT_BOOL newVal);
	
	[propget, id(13), helpstring("Gets or sets the maximum size, in megabytes, of unpacked content, above which the malware inspection scanner will block archives if the limit on the unpacked content size is enforced")]
    HRESULT MaxUnpackedContentSizeInMegs([out, retval] long *pVal);
    [propput, id(13), helpstring("Gets or sets the maximum size, in megabytes, of unpacked content, above which the malware inspection scanner will block archives if the limit on the unpacked content size is enforced")]
    HRESULT MaxUnpackedContentSizeInMegs([in] long newVal);
	
	[propget, id(14), helpstring("Gets or sets a Boolean value that indicates whether the malware inspection scanner will block archives whose depth exceeds the limit specified in the MaxArchiveDepthLevels property")]
    HRESULT BlockIfExceedsArchiveDepthLevels([out, retval] VARIANT_BOOL *pVal);
    [propput, id(14), helpstring("Gets or sets a Boolean value that indicates whether the malware inspection scanner will block archives whose depth exceeds the limit specified in the MaxArchiveDepthLevels property")]
    HRESULT BlockIfExceedsArchiveDepthLevels([in] VARIANT_BOOL newVal);
	
	[propget, id(15), helpstring("Gets or sets the maximum number of depth levels in archives, beyond which the malware inspection scanner will block archives if the limit on the archive depth is enforced")]
    HRESULT MaxArchiveDepthLevels([out, retval] long *pVal);
    [propput, id(15), helpstring("Gets or sets the maximum number of depth levels in archives, beyond which the malware inspection scanner will block archives if the limit on the archive depth is enforced")]
    HRESULT MaxArchiveDepthLevels([in] long newVal);
	
};
	
[
object,
uuid(3504c967-98f0-47e4-8166-cd92e06367b8),
dual,
nonextensible,
helpstring("Representation of the server routing table"),
pointer_default(unique)
]
interface IFPCRoutingTable : IDispatch
{
	[id(DISPID_REFRESH), helpstring("Refreshes all elements of the table")]
          HRESULT Refresh();
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Retrieves the requested IFPCRoute object from the table")]
          HRESULT Item( long Index,
              [out,retval] IFPCRoute** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

};
	
[
object,
uuid(6aaca616-4e29-470f-bf96-ff14f388b63b),
dual,
nonextensible,
helpstring("A specific entry in the routing table"),
pointer_default(unique)
]
interface IFPCRoute : IDispatch
{
	[propget, id(1), helpstring("Gets the network destination of the route")]
    HRESULT Destination([out, retval] BSTR *pVal);
	
	[propget, id(2), helpstring("Gets the subnet mask of the destination")]
    HRESULT Subnet([out, retval] BSTR *pVal);
	
	[propget, id(3), helpstring("Gets the gate of the route")]
    HRESULT Gateway([out, retval] BSTR *pVal);
	
	[propget, id(4), helpstring("Gets the IP address of the associated network adapter")]
    HRESULT Interface([out, retval] BSTR *pVal);
	
	[propget, id(5), helpstring("Gets the metric of the route")]
    HRESULT Metric([out, retval] long *pVal);
	
};
	
[
object,
uuid(a6d4a4d8-ba56-4320-82f5-627374e7fc94),
dual,
nonextensible,
helpstring("Collection of static routes for an array"),
pointer_default(unique)
]
interface IFPCStaticRoutes : IFPCPersist
{
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Retrieves the requested FPCStaticRoute object from the collection")]
          HRESULT Item([in] long Index,
              [out,retval] IFPCStaticRoute** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Creates a new FPCStaticRoute object in the collection")]
          HRESULT Add([in] BSTR Destination,
              [in] BSTR Subnet,
              [in] BSTR AdapterName,
              [in] BSTR Gateway,
              [out,retval] IFPCStaticRoute** ppStaticRoute);
        
    
	[id(DISPID_REMOVE), helpstring("Removes the specified FPCStaticRoute object from the collection")]
          HRESULT Remove([in] VARIANT v);
        
    
	[id(1), helpstring("Moves the specified static route one step up the list of static routes, which corresponds to the order in which the static routes are tried")]
          HRESULT MoveUp([in] long index);
        
    
	[id(2), helpstring("Moves the specified static route one step down the list of static routes, which corresponds to the order in which the static routes are tried")]
          HRESULT MoveDown([in] long index);
        
    
};
	
[
object,
uuid(302eae6a-acfb-428b-a6d1-3e4898b16cda),
dual,
nonextensible,
helpstring("A static route"),
pointer_default(unique)
]
interface IFPCStaticRoute : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets the IP address of the network destination of the static route")]
    HRESULT Destination([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the IP address of the network destination of the static route")]
    HRESULT Destination([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets the subnet mask of the destination")]
    HRESULT Subnet([out, retval] BSTR *pVal);
    [propput, id(2), helpstring("Gets or sets the subnet mask of the destination")]
    HRESULT Subnet([in] BSTR newVal);
	
	[propget, id(3), helpstring("Gets or sets the gateway for the static route")]
    HRESULT Gateway([out, retval] BSTR *pVal);
    [propput, id(3), helpstring("Gets or sets the gateway for the static route")]
    HRESULT Gateway([in] BSTR newVal);
	
	[propget, id(4), helpstring("Deprecated - AdapterName property is no longer supported")]
    HRESULT AdapterName([out, retval] BSTR *pVal);
    [propput, id(4), helpstring("Deprecated - AdapterName property is no longer supported")]
    HRESULT AdapterName([in] BSTR newVal);
	
	[propget, id(5), helpstring("Gets or sets the cost metric of the static route")]
    HRESULT Metric([out, retval] long *pVal);
    [propput, id(5), helpstring("Gets or sets the cost metric of the static route")]
    HRESULT Metric([in] long newVal);
	
	[id(6), helpstring("Removes the static route from the FPCStaticRoutes collection")]
          HRESULT Remove();
        
    
};
	
[
object,
uuid(0E7B6E4D-4992-44ad-A724-6CB08A3DFD87),
dual,
helpstring("Update Center"),
pointer_default(unique)
]
interface IFPCUpdateCenter : IFPCPersist
{
	[propget, id(1), helpstring("Gets an FPCUpdateServices collection of update services")]
    HRESULT UpdateServices([out, retval] IFPCUpdateServices **pVal);
	
	[propget, id(2), helpstring("Gets an FPCLicenses collection that contains objects representing licenses for obtaining updates")]
    HRESULT Licenses([out, retval] IFPCLicenses **pVal);
	
	[propget, id(3), helpstring("Gets an FPCUpdateSchedule object that represents the schedule for obtaining definition updates. Deprecated in Forefront TMG.")]
    HRESULT DefinitionUpdatesSchedule([out, retval] IFPCUpdateSchedule **pVal);
	
	[propget, id(4), helpstring("Deprecated in Forefront TMG.")]
    HRESULT SoftwareUpdatesSettings([out, retval] IFPCSoftwareUpdatesSettings **pVal);
	
	[propget, id(5), helpstring("Deprecated in Forefront TMG.")]
    HRESULT SoftwareUpdatesSchedule([out, retval] IFPCUpdateSchedule **pVal);
	
	[propget, id(6), helpstring("Gets or sets the time-out period, in seconds, for checking for, downloading, installing updates")]
    HRESULT UpdateTimeOut([out, retval] long *pVal);
    [propput, id(6), helpstring("Gets or sets the time-out period, in seconds, for checking for, downloading, installing updates")]
    HRESULT UpdateTimeOut([in] long newVal);
	
	[id(7), helpstring("Connect to all the update services, download available updates, and install them")]
          HRESULT UpdateNow();
        
    
	[id(8), helpstring("Connect to all the update service and check for available updates")]
          HRESULT CheckForUpdates();
        
    
};
	
[
object,
uuid(01493FEB-11AF-4F96-BBEF-F3047AA65BA5),
dual,
nonextensible,
helpstring("Update Center"),
pointer_default(unique)
]
interface IFPCUpdateCenter2 : IFPCUpdateCenter
{
	[propget, id(9), helpstring("Gets or sets a value from the FpcMicrosoftUpdateSource enumerated type that specifies the source for obtaining updates")]
    HRESULT MicrosoftUpdateSource([out, retval] FpcMicrosoftUpdateSource *pVal);
    [propput, id(9), helpstring("Gets or sets a value from the FpcMicrosoftUpdateSource enumerated type that specifies the source for obtaining updates")]
    HRESULT MicrosoftUpdateSource([in] FpcMicrosoftUpdateSource newVal);
	
	[propget, id(10), helpstring("Gets or sets a Boolean value that indicate whether to bypass the self-proxy in order to reach the external update source")]
    HRESULT BypassSelfProxy([out, retval] VARIANT_BOOL *pVal);
    [propput, id(10), helpstring("Gets or sets a Boolean value that indicate whether to bypass the self-proxy in order to reach the external update source")]
    HRESULT BypassSelfProxy([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(749F610A-D238-44f1-9EE6-E05420C58B95),
dual,
nonextensible,
helpstring("Collection of update services"),
pointer_default(unique)
]
interface IFPCUpdateServices : IFPCPersist
{
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Returns a specific item from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCUpdateService** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

};
	
[
object,
uuid(16FE31F4-C94D-465b-8C19-919761EAFC26),
dual,
helpstring("An update service"),
pointer_default(unique)
]
interface IFPCUpdateService : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the service")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the service")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets a value from the FpcUpdateAction enumerated type that specifies the actions that will be performed when Forefront TMG checks for updates")]
    HRESULT UpdateAction([out, retval] FpcUpdateAction *pVal);
    [propput, id(1), helpstring("Gets or sets a value from the FpcUpdateAction enumerated type that specifies the actions that will be performed when Forefront TMG checks for updates")]
    HRESULT UpdateAction([in] FpcUpdateAction newVal);
	
	[propget, id(2), helpstring("Gets an FPCRef object that references the FPCLicense object which contains the licensing information for obtaining updates for the service")]
    HRESULT License([out, retval] IFPCRef **pVal);
	
};
	
[
object,
uuid(1B9B4527-347B-48d7-AAE1-85AC5FCE6B21),
dual,
nonextensible,
helpstring("An update service"),
pointer_default(unique)
]
interface IFPCUpdateService2 : IFPCUpdateService
{
	[propget, id(3), helpstring("Gets or sets a value from the FpcAutomaticPollingFrequency enumerated type that specifies the automatic polling frequency")]
    HRESULT AutomaticPollingFrequency([out, retval] FpcAutomaticPollingFrequency *pVal);
    [propput, id(3), helpstring("Gets or sets a value from the FpcAutomaticPollingFrequency enumerated type that specifies the automatic polling frequency")]
    HRESULT AutomaticPollingFrequency([in] FpcAutomaticPollingFrequency newVal);
	
	[propget, id(4), helpstring("Gets the supported features of this update service"), hidden]
    HRESULT SupportedUpdateActions([out, retval] FpcSupportedUpdateActions *pVal);
	
	[propget, id(5), helpstring("Gets or sets the number of days that Forefront TMG will wait without installation of an update before issuing an alert")]
    HRESULT WarningDaysWithoutUpdate([out, retval] long *pVal);
    [propput, id(5), helpstring("Gets or sets the number of days that Forefront TMG will wait without installation of an update before issuing an alert")]
    HRESULT WarningDaysWithoutUpdate([in] long newVal);
	
};
	
[
object,
uuid(89AC0F18-6F40-494E-8C31-99DACB654F9B),
dual,
nonextensible,
helpstring("Collection of FPCLicense objects"),
pointer_default(unique)
]
interface IFPCLicenses : IFPCPersist
{
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Retrieves the requested FPCLicense object from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCLicense** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[propget, id(1), helpstring("Gets the number of days before license expiration on which warnings should be displayed")]
    HRESULT WarningDaysToExpiration([out, retval] long *pVal);
    [propput, id(1), helpstring("Gets the number of days before license expiration on which warnings should be displayed")]
    HRESULT WarningDaysToExpiration([in] long newVal);
	
};
	
[
object,
uuid(2af5578d-499c-40aa-ac31-c4b97b08d9ac),
dual,
nonextensible,
helpstring("License information object"),
pointer_default(unique)
]
interface IFPCLicense : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets the name of the license")]
    HRESULT Name([out, retval] BSTR *pVal);
	
	[propget, id(1), helpstring("Gets or sets the license key")]
    HRESULT Key([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the license key")]
    HRESULT Key([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets a Date value that specifies the date when the license expires")]
    HRESULT ExpirationDate([out, retval] DATE *pVal);
    [propput, id(2), helpstring("Gets or sets a Date value that specifies the date when the license expires")]
    HRESULT ExpirationDate([in] DATE newVal);
	
	[propget, id(3), helpstring("Gets the number of days left until the license expires")]
    HRESULT DaysLeft([out, retval] long *pVal);
	
};
	
[
object,
uuid(B7BCDF1F-E60E-4303-9ADD-D703E8544E37),
dual,
nonextensible,
helpstring("Collection of service update states"),
pointer_default(unique)
]
interface IFPCServiceUpdatesStates : IFPCPersist
{
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Retrieves the specified FPCServiceUpdatesState object from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCServiceUpdatesState** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

};
	
[
object,
uuid(33964624-6685-4dd9-8FC5-D5C52D8A56ED),
dual,
helpstring("A service update state"),
pointer_default(unique)
]
interface IFPCServiceUpdatesState : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets a reference to the IFPCUpdateService object this state relates to")]
    HRESULT UpdateService([out, retval] IFPCRef **pVal);
	
	[propget, id(1), helpstring("Gets the status of the update service")]
    HRESULT UpdateServiceStatus([out, retval] FpcDefinitionUpdatesStatus *pVal);
	
	[propget, id(2), helpstring("Gets a DATE value that specifies the date and time in Coordinated Universal Time (UTC) when the update service was last checked for updates")]
    HRESULT TimeLastChecked([out, retval] DATE *pVal);
	
	[propget, id(3), helpstring("Gets a DATE value that specifies the date and time in Coordinated Universal Time (UTC) when an update was last downloaded from the update service")]
    HRESULT LastUpdateTime([out, retval] DATE *pVal);
	
	[propget, id(4), helpstring("Gets a DATE value that specifies the date and time in Coordinated Universal Time (UTC) when an update from the update service was last successful")]
    HRESULT LastSuccessTime([out, retval] DATE *pVal);
	
	[propget, id(5), helpstring("Gets the success or error code returned in the last update attempt")]
    HRESULT LastErrorCode([out, retval] long *pVal);
	
	[propget, id(6), helpstring("Gets the number of consecutive failures or error codes returned in the last update attempts")]
    HRESULT ConsecutiveFailures([out, retval] long *pVal);
	
};
	
[
object,
uuid(ECBCA85F-0060-42f4-8FA8-F1199D1011C4),
dual,
nonextensible,
helpstring("A service update state"),
pointer_default(unique)
]
interface IFPCServiceUpdatesState2 : IFPCServiceUpdatesState
{
	[propget, id(7), helpstring("Gets the version of the latest update")]
    HRESULT Version([out, retval] BSTR *pVal);
	
	[propget, id(8), helpstring("Gets a 16-bit number that indicates the progress, in percent, of the update process")]
    HRESULT PercentCompleted([out, retval] unsigned short *pVal);
	
};
	
[
object,
uuid(9B0827C2-390E-4DDD-B851-26097393B3C5),
dual,
helpstring("Per-rule malware inspection settings object"),
pointer_default(unique)
]
interface IFPCMalwareInspectionProperties : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets a Boolean value that indicates whether content downloaded from the server to the client will be inspected")]
    HRESULT ScanDownload([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets a Boolean value that indicates whether content downloaded from the server to the client will be inspected")]
    HRESULT ScanDownload([in] VARIANT_BOOL newVal);
	
	[propget, id(2), helpstring("Gets or sets a Boolean value that indicates whether content uploaded from the client to the server will be inspected"), hidden]
    HRESULT ScanUpload([out, retval] VARIANT_BOOL *pVal);
    [propput, id(2), helpstring("Gets or sets a Boolean value that indicates whether content uploaded from the client to the server will be inspected"), hidden]
    HRESULT ScanUpload([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(851934CB-B30C-42db-A5E7-3D1435B89333),
dual,
nonextensible,
helpstring("Per-rule malware inspection settings object"),
pointer_default(unique)
]
interface IFPCMalwareInspectionProperties2 : IFPCMalwareInspectionProperties
{
	[propget, id(3), helpstring("Gets or sets a Boolean value that indicates whether the rule-specific malware inspection scanner settings will override the global scanner settings for the array")]
    HRESULT UseRuleSpecificSettings([out, retval] VARIANT_BOOL *pVal);
    [propput, id(3), helpstring("Gets or sets a Boolean value that indicates whether the rule-specific malware inspection scanner settings will override the global scanner settings for the array")]
    HRESULT UseRuleSpecificSettings([in] VARIANT_BOOL newVal);
	
	[propget, id(4), helpstring("Gets or sets a Boolean value that indicates whether the rule forces full content requests by removing the HTTP Range header")]
    HRESULT ForceFullContentRequests([out, retval] VARIANT_BOOL *pVal);
    [propput, id(4), helpstring("Gets or sets a Boolean value that indicates whether the rule forces full content requests by removing the HTTP Range header")]
    HRESULT ForceFullContentRequests([in] VARIANT_BOOL newVal);
	
	[propget, id(5), helpstring("Gets or sets a Boolean value that indicates whether the rule ignores scan errors when requesting partial content")]
    HRESULT IgnorePartialContentRequestScanErrors([out, retval] VARIANT_BOOL *pVal);
    [propput, id(5), helpstring("Gets or sets a Boolean value that indicates whether the rule ignores scan errors when requesting partial content")]
    HRESULT IgnorePartialContentRequestScanErrors([in] VARIANT_BOOL newVal);
	
	[propget, id(6), helpstring("Gets an FPCMalwareInspectionScannerSettings object that contains the rule-specific malware inspection scanner settings")]
    HRESULT ScannerSettings([out, retval] IFPCMalwareInspectionScannerSettings **pVal);
	
};
	
[
object,
uuid(7701AC2A-D873-4105-AEFC-A2C24CCBA8E4),
dual,
helpstring("Container for destinations"),
pointer_default(unique)
]
interface IFPCDestinations : IFPCPersist
{
	[propget, id(1), helpstring("Gets an an FPCSelectionIPs object that specifies the complete set of destination IP addresses")]
    HRESULT DestinationSelectionIPs([out, retval] IFPCSelectionIPs **pVal);
	
	[propget, id(2), helpstring("Gets an FPCRefs collection that contains references to the FPCDomainNameSet objects defining the destination  domain name sets")]
    HRESULT DestinationDomainNameSets([out, retval] IFPCRefs **pVal);
	
	[propget, id(3), helpstring("Gets an FPCRefs collection that contains references to the FPCUrlSet objects defining the destination URL sets")]
    HRESULT URLSets([out, retval] IFPCRefs **pVal);
	
	[propget, id(4), helpstring("Gets an FPCRefs collection that contains references to the FPCUrlCategory objects defining the destination URL categories")]
    HRESULT UrlCategories([out, retval] IFPCRefs **pVal);
	
};
	
[
object,
uuid(ae8d818c-0d87-416e-8d78-8e70840f2198),
dual,
nonextensible,
helpstring("Container for destinations"),
pointer_default(unique)
]
interface IFPCDestinations2 : IFPCDestinations
{
	[propget, id(5), helpstring("Gets an FPCRefs collection that contains references to the FPCUrlCategorySet collections defining the destination URL category sets")]
    HRESULT UrlCategorySets([out, retval] IFPCRefs **pVal);
	
};
	
[
object,
uuid(42A1ECD3-0853-4978-BA10-3FD019D53EF3),
dual,
nonextensible,
helpstring("Container for sources"),
pointer_default(unique)
]
interface IFPCSources : IFPCPersist
{
	[propget, id(1), helpstring("Gets an an FPCSelectionIPs object that specifies the complete set of source IP addresses")]
    HRESULT SourceSelectionIPs([out, retval] IFPCSelectionIPs **pVal);
	
};
	
[
object,
uuid(578971AE-7F93-45E4-B00E-6E2F379A3034),
dual,
nonextensible,
helpstring("A protocol message parameter that may be used in a protocol message definition"),
pointer_default(unique)
]
interface IFPCProtocolMessageDefinitionParameter : IFPCPersist
{
	[propget, id(1), helpstring("Gets the name of the protocol message parameter")]
    HRESULT Name([out, retval] BSTR *pVal);
	
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the protocol message parameter")]
    HRESULT Value([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the protocol message parameter")]
    HRESULT Value([in] BSTR newVal);
	
};
	
[
object,
uuid(C57584CB-62B9-424F-ADC9-D47B62386B52),
dual,
nonextensible,
helpstring("A set of protocol message parameters that form a definition for identifying types of protocol messages"),
pointer_default(unique)
]
interface IFPCProtocolMessageDefinition : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets the name of the protocol message definition")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the name of the protocol message definition")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets the protocol used as a transport")]
    HRESULT TransportProtocol([out, retval] FpcProtocolMessageDefinitionTransportProtocol *pVal);
    [propput, id(2), helpstring("Gets or sets the protocol used as a transport")]
    HRESULT TransportProtocol([in] FpcProtocolMessageDefinitionTransportProtocol newVal);
	
	[id(DISPID_VALUE), helpstring("Returns the requested FPCProtocolMessageDefinitionParameter object from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCProtocolMessageDefinitionParameter** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_ADD), helpstring("Creates a new FPCProtocolMessageDefinitionParameter object in the collection and returns a reference to it")]
          HRESULT Add( BSTR Name,
               BSTR Value,
              [out,retval] IFPCProtocolMessageDefinitionParameter** ppParameter);
        
    
	[id(DISPID_REMOVE), helpstring("Removes FPCProtocolMessageDefinitionParameter object from the collection")]
          HRESULT Remove([in] VARIANT IndexOrName,
              [in,defaultvalue(NULL)] BSTR Value);
        
    
};
	
[
object,
uuid(ECE9F37C-C8EB-4386-991C-85E8172CC2EE),
dual,
nonextensible,
helpstring("Collection of protocol message definitions for identifying types of protocol messages"),
pointer_default(unique)
]
interface IFPCProtocolMessageDefinitions : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Returns the requested FPCProtocolMessageDefinition object from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCProtocolMessageDefinition** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_ADD), helpstring("Creates a new FPCProtocolMessageDefinition object in the collection and returns a reference to it")]
          HRESULT Add( BSTR Name,
               FpcProtocolMessageDefinitionTransportProtocol Protocol,
              [out,retval] IFPCProtocolMessageDefinition** ppDefinition);
        
    
	[id(DISPID_REMOVE), helpstring("Removes the specified FPCProtocolMessageDefinition object from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[id(1), helpstring("Returns a Variant that holds a SafeArray containing the names of the supported parameters for the specified protocol")]
          HRESULT GetSupportedParameters( FpcProtocolMessageDefinitionTransportProtocol Protocol,
              [out,retval] VARIANT* pVal);
        
    
};
	
[
object,
uuid(9172B4D4-D807-4647-A5D0-954680FA2E1D),
dual,
nonextensible,
helpstring("URL filtering settings object"),
pointer_default(unique)
]
interface IFPCUrlFilteringSettings : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets a Boolean value that indicates whether URL filtering is enabled in the array")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets a Boolean value that indicates whether URL filtering is enabled in the array")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(2), helpstring("Gets or sets the URL of the Microsoft Reputation Service server.")]
    HRESULT ServiceUrl([out, retval] BSTR *pVal);
    [propput, id(2), helpstring("Gets or sets the URL of the Microsoft Reputation Service server.")]
    HRESULT ServiceUrl([in] BSTR newVal);
	
	[propget, id(3), helpstring("Gets or sets the URL of the Microsoft Reputation Service telemetry service server.")]
    HRESULT TelemetryServiceUrl([out, retval] BSTR *pVal);
    [propput, id(3), helpstring("Gets or sets the URL of the Microsoft Reputation Service telemetry service server.")]
    HRESULT TelemetryServiceUrl([in] BSTR newVal);
	
	[propget, id(4), helpstring("Gets an FPCUrlToCategoryMappings collection that contains mappings of URLs to overriding categories")]
    HRESULT OverridingUrlCategories([out, retval] IFPCUrlToCategoryMappings **pVal);
	
	[id(5), helpstring("Queries the Microsoft Reputation Service and the FPCUrlToCategoryMappings collection to determine the URL category of the specified URL")]
          HRESULT QueryUrlCategory([in] BSTR bstrUrl,
              [out] FpcUrlCategoryT* pCategoryID,
              [out] FpcUrlCategorizationReason* pReason);
        
    
};
	
[
object,
uuid(57340F76-2873-4E78-9171-2ACEC2FC7E4C),
dual,
nonextensible,
helpstring("performance counters settings"),
pointer_default(unique)
]
interface IFPCPerfCounterSettings : IDispatch
{
	[propget, id(1), helpstring("Gets an RequestRateAverageBytesPerSec object that holds the proxy counters settings")]
    HRESULT RequestRateAverageBytesPerSec([out, retval] IFPCRequestRateAverageBytesPerSec **pVal);
	
	[propget, id(2), helpstring("Number of authentication requests used to calculate the Average Number of Milliseconds Per Authentication Request counter")]
    HRESULT MaxQueueSizeForAvgAuthDuration([out, retval] long *pVal);
    [propput, id(2), helpstring("Number of authentication requests used to calculate the Average Number of Milliseconds Per Authentication Request counter")]
    HRESULT MaxQueueSizeForAvgAuthDuration([in] long newVal);
	
};
	
[
object,
uuid(AAC901AE-1500-49DE-8ABE-DB9F3392D69F),
dual,
nonextensible,
helpstring("Request rate average [bytes/sec] settings"),
pointer_default(unique)
]
interface IFPCRequestRateAverageBytesPerSec : IDispatch
{
	[propget, id(1), helpstring("Requests with processing time less than the number of milliseconds are ignored")]
    HRESULT RequestProcessingTimeLowBoundary([out, retval] long *pVal);
    [propput, id(1), helpstring("Requests with processing time less than the number of milliseconds are ignored")]
    HRESULT RequestProcessingTimeLowBoundary([in] long newVal);
	
	[propget, id(2), helpstring("Requests with processing time more than the number of milliseconds are ignored")]
    HRESULT RequestProcessingTimeHighBoundary([out, retval] long *pVal);
    [propput, id(2), helpstring("Requests with processing time more than the number of milliseconds are ignored")]
    HRESULT RequestProcessingTimeHighBoundary([in] long newVal);
	
	[propget, id(3), helpstring("Requests with sizes smaller than the number of bytes are ignored")]
    HRESULT RequestSizeLowBoundary([out, retval] long *pVal);
    [propput, id(3), helpstring("Requests with sizes smaller than the number of bytes are ignored")]
    HRESULT RequestSizeLowBoundary([in] long newVal);
	
	[propget, id(4), helpstring("Requests with sizes greater than the number of bytes are ignored")]
    HRESULT RequestSizeHighBoundary([out, retval] long *pVal);
    [propput, id(4), helpstring("Requests with sizes greater than the number of bytes are ignored")]
    HRESULT RequestSizeHighBoundary([in] long newVal);
	
};
	
[
object,
uuid(D50A12B1-093D-4d3d-8555-778030A1EBEF),
dual,
nonextensible,
helpstring("An activity statistics entry"),
pointer_default(unique)
]
interface IFPCActivityStatisticsEntry : IDispatch
{
	[propget, id(1), helpstring("Gets the name of activity statistics counter")]
    HRESULT Name([out, retval] BSTR *pVal);
	
	[propget, id(2), helpstring("Gets the value of activity statistics counter")]
    HRESULT Value([out, retval] __int64 *pVal);
	
};
	
[
object,
uuid(E07FDF8A-041C-42d2-A07B-FCD98AD3E8AB),
dual,
nonextensible,
helpstring("A perfromance counter entry"),
pointer_default(unique)
]
interface IFPCPerformanceCounterEntry : IDispatch
{
	[propget, id(1), helpstring("Gets the name of performance counter")]
    HRESULT Name([out, retval] BSTR *pVal);
	
	[propget, id(2), helpstring("Gets or sets the value of perfromance counter")]
    HRESULT Value([out, retval] __int64 *pVal);
    [propput, id(2), helpstring("Gets or sets the value of perfromance counter")]
    HRESULT Value([in] __int64 newVal);
	
};
	
[
object,
uuid(0AA32E6E-8808-4beb-ACEB-49172A15E948),
dual,
nonextensible,
helpstring("Provides statistics concerning the activity of a Forefront TMG array"),
pointer_default(unique)
]
interface IFPCActivityStatistics : IDispatch
{
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Returns a specific counter entry from the collection by its name")]
          HRESULT Item( BSTR Name,
              [out,retval] IFPCActivityStatisticsEntry** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

};
	
[
object,
uuid(773A94F2-BED1-4b5f-BB69-B0FB5CF7D98B),
dual,
nonextensible,
helpstring("Provides Dashboard performance counters concerning the activity of a Forefront TMG array"),
pointer_default(unique)
]
interface IFPCDashboardPerformanceCounters : IDispatch
{
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Returns a specific counter entry from the collection by its name")]
          HRESULT Item( BSTR Name,
              [out,retval] IFPCPerformanceCounterEntry** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

};
	
[
object,
uuid(3F74A069-6E81-49f2-8966-414ACE8F272F),
dual,
nonextensible,
helpstring("SIP Settings"),
pointer_default(unique)
]
interface IFPCSipSettings : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets whether internal SIP clients may register externaly")]
    HRESULT ExternalRegistrationEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets whether internal SIP clients may register externaly")]
    HRESULT ExternalRegistrationEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(2), helpstring("Gets or sets the external registration IP address")]
    HRESULT ExternalRegistrationIPAddress([out, retval] BSTR *pVal);
    [propput, id(2), helpstring("Gets or sets the external registration IP address")]
    HRESULT ExternalRegistrationIPAddress([in] BSTR newVal);
	
	[propget, id(3), helpstring("Gets or sets the default external registration port for SIP")]
    HRESULT ExternalRegistrationPort([out, retval] long *pVal);
    [propput, id(3), helpstring("Gets or sets the default external registration port for SIP")]
    HRESULT ExternalRegistrationPort([in] long newVal);
	
	[propget, id(4), helpstring("Gets or sets the base port for SIP external registration after the default port")]
    HRESULT ExternalRegistrationBasePort([out, retval] long *pVal);
    [propput, id(4), helpstring("Gets or sets the base port for SIP external registration after the default port")]
    HRESULT ExternalRegistrationBasePort([in] long newVal);
	
	[propget, id(5), helpstring("Gets or sets the number of registration ports for SIP in addition to default port")]
    HRESULT NumExternalRegistrationPorts([out, retval] long *pVal);
    [propput, id(5), helpstring("Gets or sets the number of registration ports for SIP in addition to default port")]
    HRESULT NumExternalRegistrationPorts([in] long newVal);
	
	[propget, id(6), helpstring("Gets or sets the max number of registrations on the filter")]
    HRESULT MaxGlobalRegistrations([out, retval] long *pVal);
    [propput, id(6), helpstring("Gets or sets the max number of registrations on the filter")]
    HRESULT MaxGlobalRegistrations([in] long newVal);
	
	[propget, id(7), helpstring("Gets or sets the max number of calls on the filter")]
    HRESULT MaxGlobalCalls([out, retval] long *pVal);
    [propput, id(7), helpstring("Gets or sets the max number of calls on the filter")]
    HRESULT MaxGlobalCalls([in] long newVal);
	
	[propget, id(8), helpstring("Gets or sets the max number of registrations for specific IP address")]
    HRESULT MaxRegistrationsPerIP([out, retval] long *pVal);
    [propput, id(8), helpstring("Gets or sets the max number of registrations for specific IP address")]
    HRESULT MaxRegistrationsPerIP([in] long newVal);
	
	[propget, id(9), helpstring("Gets or sets the max number of calls for specific IP address")]
    HRESULT MaxCallsPerIP([out, retval] long *pVal);
    [propput, id(9), helpstring("Gets or sets the max number of calls for specific IP address")]
    HRESULT MaxCallsPerIP([in] long newVal);
	
	[propget, id(10), helpstring("Gets or sets the max allowed registration expiration")]
    HRESULT MaxAllowedRegistrationExpiration([out, retval] long *pVal);
    [propput, id(10), helpstring("Gets or sets the max allowed registration expiration")]
    HRESULT MaxAllowedRegistrationExpiration([in] long newVal);
	
	[propget, id(11), helpstring("Gets or sets the min allowed media stream port in SDP")]
    HRESULT MinAllowedMediaPortInSDP([out, retval] long *pVal);
    [propput, id(11), helpstring("Gets or sets the min allowed media stream port in SDP")]
    HRESULT MinAllowedMediaPortInSDP([in] long newVal);
	
};
	
[
object,
uuid(79BA08EC-1300-4A6C-A219-601EEB84B8F2),
dual,
nonextensible,
helpstring("SMTP protection settings"),
pointer_default(unique)
]
interface IFPCSmtpProtectionConfiguration : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets a Boolean value that indicates whether SMTP protection is enabled")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets a Boolean value that indicates whether SMTP protection is enabled")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(2), helpstring("Gets or sets a Boolean value that indicates whether antivirus protection is enabled")]
    HRESULT AntivirusEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(2), helpstring("Gets or sets a Boolean value that indicates whether antivirus protection is enabled")]
    HRESULT AntivirusEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(3), helpstring("Gets or sets a Boolean value that indicates whether antispam protection is enabled")]
    HRESULT AntiSpamEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(3), helpstring("Gets or sets a Boolean value that indicates whether antispam protection is enabled")]
    HRESULT AntiSpamEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(4), helpstring("Gets or sets a Boolean value that indicates whether edge subscription mode is enabled")]
    HRESULT EdgeSubscriptionEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(4), helpstring("Gets or sets a Boolean value that indicates whether edge subscription mode is enabled")]
    HRESULT EdgeSubscriptionEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(5), helpstring("Gets or sets a Boolean value that indicates whether integration with the collocated Exchange Edge Transport role and Forefront Security for Exchange Server is enabled in the array")]
    HRESULT IntegrationEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(5), helpstring("Gets or sets a Boolean value that indicates whether integration with the collocated Exchange Edge Transport role and Forefront Security for Exchange Server is enabled in the array")]
    HRESULT IntegrationEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(6), helpstring("Gets an FPCSmtpRoutes collection containing the list of SMTP routes")]
    HRESULT SmtpRoutes([out, retval] IFPCSmtpRoutes **pVal);
	
	[propget, id(7), helpstring("Gets an FPCMailAntivirusSettings object containing the malware inspection settings for email messages")]
    HRESULT AntivirusSettings([out, retval] IFPCMailAntivirusSettings **pVal);
	
	[propget, id(8), helpstring("Gets an FPCMailAntiSpamSettings object containing the antispam settings for email messages")]
    HRESULT AntiSpamSettings([out, retval] IFPCMailAntiSpamSettings **pVal);
	
};
	
[
object,
uuid(1776cc52-d833-4b46-bb4b-307d5698f9df),
dual,
nonextensible,
helpstring("SMTP malware inspection settings"),
pointer_default(unique)
]
interface IFPCMailAntivirusSettings : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets a value that indicates which malware inspection engines to use when inspecting mail traffic")]
    HRESULT EngineSubset([out, retval] FpcMailAntivirusEngine *pVal);
    [propput, id(1), helpstring("Gets or sets a value that indicates which malware inspection engines to use when inspecting mail traffic")]
    HRESULT EngineSubset([in] FpcMailAntivirusEngine newVal);
	
	[propget, id(2), helpstring("Gets or sets a value that indicates how malware inspection engines are chosen for inspecting traffic out of the selected subset")]
    HRESULT SelectionPolicy([out, retval] FpcMailAntivirusEngineSelectionPolicy *pVal);
    [propput, id(2), helpstring("Gets or sets a value that indicates how malware inspection engines are chosen for inspecting traffic out of the selected subset")]
    HRESULT SelectionPolicy([in] FpcMailAntivirusEngineSelectionPolicy newVal);
	
	[propget, id(3), helpstring("Gets or sets a value that indicates which action to take when a malware is found")]
    HRESULT Action([out, retval] FpcMailAntivirusAction *pVal);
    [propput, id(3), helpstring("Gets or sets a value that indicates which action to take when a malware is found")]
    HRESULT Action([in] FpcMailAntivirusAction newVal);
	
	[propget, id(4), helpstring("Gets or sets a value that indicates whether a notification message should be sent when malware is found")]
    HRESULT SendNotification([out, retval] VARIANT_BOOL *pVal);
    [propput, id(4), helpstring("Gets or sets a value that indicates whether a notification message should be sent when malware is found")]
    HRESULT SendNotification([in] VARIANT_BOOL newVal);
	
	[propget, id(5), helpstring("Gets or sets the notification text to send when malware is found")]
    HRESULT NotificationText([out, retval] BSTR *pVal);
    [propput, id(5), helpstring("Gets or sets the notification text to send when malware is found")]
    HRESULT NotificationText([in] BSTR newVal);
	
	[propget, id(6), helpstring("Gets or sets a value that indicates whether to scan doc files as containers of other files")]
    HRESULT ScanDocfilesAsContainers([out, retval] VARIANT_BOOL *pVal);
    [propput, id(6), helpstring("Gets or sets a value that indicates whether to scan doc files as containers of other files")]
    HRESULT ScanDocfilesAsContainers([in] VARIANT_BOOL newVal);
	
	[propget, id(7), helpstring("Gets or sets a value that indicates the number of seconds to allow for scanning a container before timeout")]
    HRESULT ContainerScanningTimeout([out, retval] long *pVal);
    [propput, id(7), helpstring("Gets or sets a value that indicates the number of seconds to allow for scanning a container before timeout")]
    HRESULT ContainerScanningTimeout([in] long newVal);
	
	[propget, id(8), helpstring("Gets or sets a value that indicates which action to take when a scan reaches its timeout")]
    HRESULT TimeoutAction([out, retval] FpcMailAntivirusErrorAction *pVal);
    [propput, id(8), helpstring("Gets or sets a value that indicates which action to take when a scan reaches its timeout")]
    HRESULT TimeoutAction([in] FpcMailAntivirusErrorAction newVal);
	
	[propget, id(9), helpstring("Gets or sets a value that indicates which action to take when the message contains an illegal MIME header")]
    HRESULT IllegalMIMEHeaderAction([out, retval] FpcMailIllegalMimeHeaderAction *pVal);
    [propput, id(9), helpstring("Gets or sets a value that indicates which action to take when the message contains an illegal MIME header")]
    HRESULT IllegalMIMEHeaderAction([in] FpcMailIllegalMimeHeaderAction newVal);
	
	[propget, id(10), helpstring("Gets or sets a value that indicates how the antivirus finds out sender information from the transport protocol")]
    HRESULT TransportSenderInformation([out, retval] FpcMailAntivirusSenderInfo *pVal);
    [propput, id(10), helpstring("Gets or sets a value that indicates how the antivirus finds out sender information from the transport protocol")]
    HRESULT TransportSenderInformation([in] FpcMailAntivirusSenderInfo newVal);
	
	[propget, id(11), helpstring("Gets or sets a value that indicates whether to purge messages that had their body deleted")]
    HRESULT PurgeOnDelete([out, retval] VARIANT_BOOL *pVal);
    [propput, id(11), helpstring("Gets or sets a value that indicates whether to purge messages that had their body deleted")]
    HRESULT PurgeOnDelete([in] VARIANT_BOOL newVal);
	
	[propget, id(12), helpstring("Gets or sets a value that indicates whether to optimize performance by skipping messaged marked as already scanned")]
    HRESULT SkipAlreadyScannedMessages([out, retval] VARIANT_BOOL *pVal);
    [propput, id(12), helpstring("Gets or sets a value that indicates whether to optimize performance by skipping messaged marked as already scanned")]
    HRESULT SkipAlreadyScannedMessages([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(9b84b47e-f7ec-4938-8365-2d1b6ae86ae5),
dual,
nonextensible,
helpstring("SMTP antispam settings"),
pointer_default(unique)
]
interface IFPCMailAntiSpamSettings : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets a Boolean value that indicates whether content filtering is enabled")]
    HRESULT ContentFilteringEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets a Boolean value that indicates whether content filtering is enabled")]
    HRESULT ContentFilteringEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(2), helpstring("Gets or sets a Boolean value that indicates whether spam deletion is enabled")]
    HRESULT SpamDeletionEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(2), helpstring("Gets or sets a Boolean value that indicates whether spam deletion is enabled")]
    HRESULT SpamDeletionEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(3), helpstring("Gets or sets the spam confidence level (SCL) set as the delete threshold")]
    HRESULT DeleteScl([out, retval] long *pVal);
    [propput, id(3), helpstring("Gets or sets the spam confidence level (SCL) set as the delete threshold")]
    HRESULT DeleteScl([in] long newVal);
	
	[propget, id(4), helpstring("Gets or sets a Boolean value that indicates whether spam rejection is enabled")]
    HRESULT SpamRejectionEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(4), helpstring("Gets or sets a Boolean value that indicates whether spam rejection is enabled")]
    HRESULT SpamRejectionEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(5), helpstring("Gets or sets the spam confidence level (SCL) set as the reject threshold")]
    HRESULT RejectScl([out, retval] long *pVal);
    [propput, id(5), helpstring("Gets or sets the spam confidence level (SCL) set as the reject threshold")]
    HRESULT RejectScl([in] long newVal);
	
	[propget, id(6), helpstring("Gets or sets a Boolean value that indicates whether the spam quarantine is enabled")]
    HRESULT SpamQuarantineEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(6), helpstring("Gets or sets a Boolean value that indicates whether the spam quarantine is enabled")]
    HRESULT SpamQuarantineEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(7), helpstring("Gets or sets the spam confidence level (SCL) set as the quarantine threshold")]
    HRESULT QuarantineScl([out, retval] long *pVal);
    [propput, id(7), helpstring("Gets or sets the spam confidence level (SCL) set as the quarantine threshold")]
    HRESULT QuarantineScl([in] long newVal);
	
	[propget, id(8), helpstring("Gets or sets the e-mail address of the spam quarantine mailbox")]
    HRESULT QuarantineMailbox([out, retval] BSTR *pVal);
    [propput, id(8), helpstring("Gets or sets the e-mail address of the spam quarantine mailbox")]
    HRESULT QuarantineMailbox([in] BSTR newVal);
	
	[propget, id(9), helpstring("Gets or sets a Boolean value that indicates whether checking the IP allow list  is enabled")]
    HRESULT IpAllowListEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(9), helpstring("Gets or sets a Boolean value that indicates whether checking the IP allow list  is enabled")]
    HRESULT IpAllowListEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(10), helpstring("Gets an FPCIpListRanges collection containing the IP address ranges in the IP allow list")]
    HRESULT IpAllowListRanges([out, retval] IFPCIpListRanges **pVal);
	
	[propget, id(11), helpstring("Gets or sets a Boolean value that indicates whether use of the IP allow list providers is enabled")]
    HRESULT IpAllowListProvidersEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(11), helpstring("Gets or sets a Boolean value that indicates whether use of the IP allow list providers is enabled")]
    HRESULT IpAllowListProvidersEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(12), helpstring("Gets an FPCIpListProviders collection containing the IP allow list providers")]
    HRESULT IpAllowListProviders([out, retval] IFPCIpListProviders **pVal);
	
	[propget, id(13), helpstring("Gets or sets a Boolean value that indicates whether checking the IP block list  is enabled")]
    HRESULT IpBlockListEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(13), helpstring("Gets or sets a Boolean value that indicates whether checking the IP block list  is enabled")]
    HRESULT IpBlockListEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(14), helpstring("Gets an FPCIpListRanges collection containing the IP address ranges in the IP block list")]
    HRESULT IpBlockListRanges([out, retval] IFPCIpListRanges **pVal);
	
	[propget, id(15), helpstring("Gets or sets a Boolean value that indicates whether use of the IP block list providers is enabled")]
    HRESULT IpBlockListProvidersEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(15), helpstring("Gets or sets a Boolean value that indicates whether use of the IP block list providers is enabled")]
    HRESULT IpBlockListProvidersEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(16), helpstring("Gets an FPCIpListProviders collection containing the IP block list providers ")]
    HRESULT IpBlockListProviders([out, retval] IFPCIpListProviders **pVal);
	
	[propget, id(17), helpstring("Gets or sets a Boolean value that indicates whether  recipient filtering is enabled")]
    HRESULT RecipientFilteringEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(17), helpstring("Gets or sets a Boolean value that indicates whether  recipient filtering is enabled")]
    HRESULT RecipientFilteringEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(18), helpstring("Gets or sets a Boolean value that indicates whether messages sent to recipients not in the global address book will be blocked")]
    HRESULT BlockNotInGlobalAddressBook([out, retval] VARIANT_BOOL *pVal);
    [propput, id(18), helpstring("Gets or sets a Boolean value that indicates whether messages sent to recipients not in the global address book will be blocked")]
    HRESULT BlockNotInGlobalAddressBook([in] VARIANT_BOOL newVal);
	
	[propget, id(19), helpstring("Gets or sets a Boolean value that indicates whether messages sent to recipients in the recipient block list will be blocked")]
    HRESULT RecipientBlockListEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(19), helpstring("Gets or sets a Boolean value that indicates whether messages sent to recipients in the recipient block list will be blocked")]
    HRESULT RecipientBlockListEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(20), helpstring("Gets or sets a Boolean value that indicates whether sender filtering is enabled")]
    HRESULT SenderFilteringEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(20), helpstring("Gets or sets a Boolean value that indicates whether sender filtering is enabled")]
    HRESULT SenderFilteringEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(21), helpstring("Gets or sets a value from the FpcSenderFilterAction enumerated type that specifies the sender filtering action")]
    HRESULT SenderFilteringAction([out, retval] FpcSenderFilterAction *pVal);
    [propput, id(21), helpstring("Gets or sets a value from the FpcSenderFilterAction enumerated type that specifies the sender filtering action")]
    HRESULT SenderFilteringAction([in] FpcSenderFilterAction newVal);
	
	[propget, id(22), helpstring("Gets or sets a Boolean value that indicates whether sender ID validation is enabled")]
    HRESULT SenderIdCheckEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(22), helpstring("Gets or sets a Boolean value that indicates whether sender ID validation is enabled")]
    HRESULT SenderIdCheckEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(23), helpstring("Gets or sets a value from the FpcSenderIdCheckAction enumerated type that specifies the action to be performed when sender ID validation fails")]
    HRESULT SenderIdCheckAction([out, retval] FpcSenderIdCheckAction *pVal);
    [propput, id(23), helpstring("Gets or sets a value from the FpcSenderIdCheckAction enumerated type that specifies the action to be performed when sender ID validation fails")]
    HRESULT SenderIdCheckAction([in] FpcSenderIdCheckAction newVal);
	
	[propget, id(24), helpstring("Gets or sets a Boolean value that indicates whether calculation of the sender reputation level is enabled")]
    HRESULT SenderReputationEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(24), helpstring("Gets or sets a Boolean value that indicates whether calculation of the sender reputation level is enabled")]
    HRESULT SenderReputationEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(25), helpstring("Gets or sets a Boolean value that indicates whether the open proxy test is enabled")]
    HRESULT OpenProxyTestEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(25), helpstring("Gets or sets a Boolean value that indicates whether the open proxy test is enabled")]
    HRESULT OpenProxyTestEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(26), helpstring("Gets or sets the sender reputation level set as the block threshold")]
    HRESULT SenderReputationLevelBlockThreshold([out, retval] long *pVal);
    [propput, id(26), helpstring("Gets or sets the sender reputation level set as the block threshold")]
    HRESULT SenderReputationLevelBlockThreshold([in] long newVal);
	
	[propget, id(27), helpstring("Gets or sets the time during which messages sent from a sender whose sender reputation level is above the block threshold will be blocked")]
    HRESULT SenderReputationBlockDuration([out, retval] long *pVal);
    [propput, id(27), helpstring("Gets or sets the time during which messages sent from a sender whose sender reputation level is above the block threshold will be blocked")]
    HRESULT SenderReputationBlockDuration([in] long newVal);
	
	[propget, id(28), helpstring("Gets an FPCEMailAddresses collection containing the e-mail addresses of recipients who are excluded from content filtering")]
    HRESULT ContentFilteringExceptions([out, retval] IFPCEMailAddresses **pVal);
	
	[propget, id(29), helpstring("Gets an FPCEMailAddresses collection containing the e-mail addresses of recipients who are excluded from the IP block list provider check")]
    HRESULT IpBlockListProvidersExceptions([out, retval] IFPCEMailAddresses **pVal);
	
	[propget, id(30), helpstring("Gets an FPCEMailAddresses collection containing the e-mail addresses of blocked recipients")]
    HRESULT BlockedRecipients([out, retval] IFPCEMailAddresses **pVal);
	
	[propget, id(31), helpstring("Gets an FPCPhrases collection containing the phrases which indicate that messages should not be blocked regardless of the results of other contents checks")]
    HRESULT PassPhrases([out, retval] IFPCPhrases **pVal);
	
	[propget, id(32), helpstring("Gets an FPCPhrases collection containing the phrases which indicate that messages should be blocked")]
    HRESULT BlockPhrases([out, retval] IFPCPhrases **pVal);
	
	[propget, id(33), helpstring("Gets an FPCBlockedSenders collection containing the list of blocked senders")]
    HRESULT BlockedSenders([out, retval] IFPCBlockedSenders **pVal);
	
	[propget, id(34), helpstring("Gets or sets a Boolean value that indicates whether the messages sent from empty senders will be blocked")]
    HRESULT BlockEmptySendersEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(34), helpstring("Gets or sets a Boolean value that indicates whether the messages sent from empty senders will be blocked")]
    HRESULT BlockEmptySendersEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(35), helpstring("Gets or sets a Boolean value that indicates whether the message attachments will be filterered")]
    HRESULT FileFilteringEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(35), helpstring("Gets or sets a Boolean value that indicates whether the message attachments will be filterered")]
    HRESULT FileFilteringEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(36), helpstring("Gets an FPCMailAntispamFilterLists collection containing the list of file filters")]
    HRESULT FileFilters([out, retval] IFPCMailAntispamFilterLists **pVal);
	
	[propget, id(37), helpstring("Gets or sets a Boolean value that indicates whether the message will be filtered according to subject line")]
    HRESULT MessageBodyFilteringEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(37), helpstring("Gets or sets a Boolean value that indicates whether the message will be filtered according to subject line")]
    HRESULT MessageBodyFilteringEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(38), helpstring("Gets an FPCMailAntispamFilterLists collection containing the list of message body filters")]
    HRESULT MessageBodyFilters([out, retval] IFPCMailAntispamFilterLists **pVal);
	
};
	
[
object,
uuid(f3fd5444-afea-43d6-9474-2b53074a7c03),
dual,
nonextensible,
helpstring("SMTP protection status"),
pointer_default(unique)
]
interface IFPCSmtpProtectionStatus : IDispatch
{
	[id(DISPID_REFRESH), helpstring("Refresh SMTP Protection statuses")]
          HRESULT Refresh();
        
    
	[id(1), helpstring("Retrieves the contents of the edge subscription file")]
          HRESULT GetEdgeSubscriptionFile([out,size_is(*lpdwContentLength)] BYTE** ppbFileContent,
              [in,out] LPDWORD lpdwContentLength);
        
    
	[propget, id(2), helpstring("Gets the version of the latest antispam content filter")]
    HRESULT AntispamContentFilterVersion([out, retval] BSTR *pVal);
	
	[propget, id(3), helpstring("the version of the latest antispam signatures")]
    HRESULT AntispamSignatureVersion([out, retval] BSTR *pVal);
	
	[propget, id(4), helpstring("Gets the version of the latest antispam IP reputations")]
    HRESULT AntispamIpReputationVersion([out, retval] BSTR *pVal);
	
	[id(5), helpstring("Gets the version of the latest engine for the specified e-mail antivirus engine")]
          HRESULT GetAntivirusEngineVersion([in] FpcMailAntivirusEngine Engine,
              [out,retval] BSTR* pVersion);
        
    
	[id(6), helpstring("Gets the version of the latest signatures for the specified e-mail antivirus engine")]
          HRESULT GetAntivirusSignatureVersion([in] FpcMailAntivirusEngine Engine,
              [out,retval] BSTR* pVersion);
        
    
	[id(7), helpstring("Gets a DATE value that specifies the date and time in Coordinated Universal Time (UTC) when the specified e-mail antivirus engine was last checked for updates")]
          HRESULT GetAntivirusLastCheckTime([in] FpcMailAntivirusEngine Engine,
              [out,retval] DATE* pDate);
        
    
	[id(8), helpstring("a DATE value that specifies the date and time in Coordinated Universal Time (UTC) when the specified e-mail antivirus engine was last updated")]
          HRESULT GetAntivirusLastUpdateTime([in] FpcMailAntivirusEngine Engine,
              [out,retval] DATE* pDate);
        
    
	[id(9), helpstring("Gets a value from the FpcFssUpdateStatus enumerated type that indicates the current update status of the specified e-mail antivirus engine")]
          HRESULT GetAntivirusUpdateStatus([in] FpcMailAntivirusEngine Engine,
              [out,retval] FpcFssUpdateStatus* pStatus);
        
    
};
	
[
object,
uuid(E5095CC5-3FF4-4125-A4DB-7CC2FE630FC3),
dual,
nonextensible,
helpstring("Collection of IP address ranges in the IP allow list or IP block list"),
pointer_default(unique)
]
interface IFPCIpListRanges : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Retrieves the requested FPCIpListRange object from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCIpListRange** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_REMOVE), helpstring("Removes the specified FPCIpListRange object from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_ADD), helpstring("Creates a new FPCIpListRange object in the collection and returns a reference to it")]
          HRESULT Add([in] BSTR FromIP,
              [in] BSTR ToIP,
              [in] DATE ExpirationDate,
              [out,retval] IFPCIpListRange** ppNewItem);
        
    
};
	
[
object,
uuid(85475446-615C-4997-9FC9-FC6969DF2608),
dual,
nonextensible,
helpstring("IP address range in an IP allow list or an IP block list"),
pointer_default(unique)
]
interface IFPCIpListRange : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets a Boolean value that indicates whether the IP address range will expire")]
    HRESULT WillExpire([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets a Boolean value that indicates whether the IP address range will expire")]
    HRESULT WillExpire([in] VARIANT_BOOL newVal);
	
	[propget, id(2), helpstring("Gets or sets a DATE value that specifies the expiration date and time in Coordinated Universal Time (UTC) of the IP address range")]
    HRESULT ExpirationDate([out, retval] DATE *pVal);
    [propput, id(2), helpstring("Gets or sets a DATE value that specifies the expiration date and time in Coordinated Universal Time (UTC) of the IP address range")]
    HRESULT ExpirationDate([in] DATE newVal);
	
	[propget, id(3), helpstring("Gets or sets the lower bound of the IP address range")]
    HRESULT FromIp([out, retval] BSTR *pVal);
    [propput, id(3), helpstring("Gets or sets the lower bound of the IP address range")]
    HRESULT FromIp([in] BSTR newVal);
	
	[propget, id(4), helpstring("Gets or sets the upper bound of the IP address range")]
    HRESULT ToIp([out, retval] BSTR *pVal);
    [propput, id(4), helpstring("Gets or sets the upper bound of the IP address range")]
    HRESULT ToIp([in] BSTR newVal);
	
};
	
[
object,
uuid(1863587A-5465-48A2-AFAD-F99C752E709A),
dual,
nonextensible,
helpstring("Collection of IP allow list or IP block list providers"),
pointer_default(unique)
]
interface IFPCIpListProviders : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Retrieves the requested FPCIpListProvider object from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCIpListProvider** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_REMOVE), helpstring("Removes the specified FPCIpListProvider object from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_ADD), helpstring("Creates a new FPCIpListProvider object in the collection and returns a reference to it")]
          HRESULT Add([in] BSTR Name,
              [in] BSTR FQDN,
              [out,retval] IFPCIpListProvider** ppNewItem);
        
    
};
	
[
object,
uuid(AE92EAE0-1255-4D5C-A7FB-318FA0D8A690),
dual,
nonextensible,
helpstring("IP allow/block list provider"),
pointer_default(unique)
]
interface IFPCIpListProvider : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the provider")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the provider")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the description of the provider")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the description of the provider")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets the domain name of the provider")]
    HRESULT DomainName([out, retval] BSTR *pVal);
    [propput, id(2), helpstring("Gets or sets the domain name of the provider")]
    HRESULT DomainName([in] BSTR newVal);
	
	[propget, id(3), helpstring("Gets or sets the match mask for the provider")]
    HRESULT Mask([out, retval] BSTR *pVal);
    [propput, id(3), helpstring("Gets or sets the match mask for the provider")]
    HRESULT Mask([in] BSTR newVal);
	
	[propget, id(4), helpstring("Gets or sets a Boolean value that indicates whether the provider is enabled")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(4), helpstring("Gets or sets a Boolean value that indicates whether the provider is enabled")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(5), helpstring("Gets or sets a FpcBlockedProviderErrorMessageType value that indicates the type of error message for blocked IP address")]
    HRESULT BlockedProviderErrorMessageType([out, retval] FpcBlockedProviderErrorMessageType *pVal);
    [propput, id(5), helpstring("Gets or sets a FpcBlockedProviderErrorMessageType value that indicates the type of error message for blocked IP address")]
    HRESULT BlockedProviderErrorMessageType([in] FpcBlockedProviderErrorMessageType newVal);
	
	[propget, id(6), helpstring("Gets or sets a  error message for blocked IP address")]
    HRESULT BlockedProviderErrorMessage([out, retval] BSTR *pVal);
    [propput, id(6), helpstring("Gets or sets a  error message for blocked IP address")]
    HRESULT BlockedProviderErrorMessage([in] BSTR newVal);
	
	[propget, id(7), helpstring("Gets or sets a Boolean value that indicates whether any result code will be matched")]
    HRESULT MatchAnyReturnCode([out, retval] VARIANT_BOOL *pVal);
    [propput, id(7), helpstring("Gets or sets a Boolean value that indicates whether any result code will be matched")]
    HRESULT MatchAnyReturnCode([in] VARIANT_BOOL newVal);
	
	[propget, id(8), helpstring("Gets an FPCIPAddresses collection that contains the list of responses that will be matched")]
    HRESULT MatchedResponses([out, retval] IFPCIPAddresses **pVal);
	
};
	
[
object,
uuid(C175152D-CE44-44DA-BA68-E9D13522026A),
dual,
nonextensible,
helpstring("E-mail address"),
pointer_default(unique)
]
interface IFPCEMailAddress : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets the e-mail address")]
    HRESULT Address([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the e-mail address")]
    HRESULT Address([in] BSTR newVal);
	
};
	
[
object,
uuid(C485D64E-269A-4F45-954D-B97318BA020B),
dual,
nonextensible,
helpstring("Phrase"),
pointer_default(unique)
]
interface IFPCPhrase : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets the e-mail address")]
    HRESULT PhraseString([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the e-mail address")]
    HRESULT PhraseString([in] BSTR newVal);
	
};
	
[
object,
uuid(A5BFB635-1F0C-424E-BB45-5C1BA7503200),
dual,
nonextensible,
helpstring("Collection of e-mail addresses"),
pointer_default(unique)
]
interface IFPCEMailAddresses : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Retrieves the requested e-mail address from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCEMailAddress** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Adds an e-mail address to the collection")]
          HRESULT Add( BSTR Address,
              [out,retval] IFPCEMailAddress** pItem);
        
    
	[id(DISPID_REMOVE), helpstring("Removes the specified e-mail address from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
};
	
[
object,
uuid(F1A5A1CC-C05A-403B-88D8-179E04658D10),
dual,
nonextensible,
helpstring("Collection of phrases"),
pointer_default(unique)
]
interface IFPCPhrases : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Retrieves the requested phrase from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCPhrase** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Adds a phrase to the collection")]
          HRESULT Add( BSTR Phrase,
              [out,retval] IFPCPhrase** pItem);
        
    
	[id(DISPID_REMOVE), helpstring("Removes the specified from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
};
	
[
object,
uuid(4716A201-8305-41C5-B1D9-68568BFDABD7),
dual,
nonextensible,
helpstring("Collection of blocked senders"),
pointer_default(unique)
]
interface IFPCBlockedSenders : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Retrieves the requested FPCBlockedSender object from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCBlockedSender** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_REMOVE), helpstring("Removes the specified FPCBlockedSender object from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_ADD), helpstring("Creates a new FPCBlockedSender object in the collection and returns a reference to it")]
          HRESULT Add([in] BSTR Address,
              [in] FpcBlockedSenderAddressType AddressType,
              [out,retval] IFPCBlockedSender** ppNewItem);
        
    
};
	
[
object,
uuid(5E03BBE2-56BA-4330-AC92-D2F76EA1B50A),
dual,
nonextensible,
helpstring("Blocked sender"),
pointer_default(unique)
]
interface IFPCBlockedSender : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets the address of the blocked sender")]
    HRESULT Address([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the address of the blocked sender")]
    HRESULT Address([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets a value from the FpcBlockedSenderAddressType enumerated type that specifies the type of  address specified for the sender")]
    HRESULT AddressType([out, retval] FpcBlockedSenderAddressType *pVal);
    [propput, id(2), helpstring("Gets or sets a value from the FpcBlockedSenderAddressType enumerated type that specifies the type of  address specified for the sender")]
    HRESULT AddressType([in] FpcBlockedSenderAddressType newVal);
	
};
	
[
object,
uuid(33DAA3D8-0CBA-4544-83C0-9FEC77A40208),
dual,
nonextensible,
helpstring("Address space"),
pointer_default(unique)
]
interface IFPCAddressSpace : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets the string that specifies address space")]
    HRESULT Address([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the string that specifies address space")]
    HRESULT Address([in] BSTR newVal);
	
};
	
[
object,
uuid(188D7933-5370-4369-9A73-49CAC914DA88),
dual,
nonextensible,
helpstring("Collection of address spaces"),
pointer_default(unique)
]
interface IFPCAddressSpaces : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Retrieves the requested FPCAddressSpace object from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCAddressSpace** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_REMOVE), helpstring("Removes the specified FPCAddressSpace object from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_ADD), helpstring("Creates a new FPCAddressSpace object in the collection and returns a reference to it")]
          HRESULT Add([in] BSTR AddressSpace,
              [out,retval] IFPCAddressSpace** ppNewItem);
        
    
};
	
[
object,
uuid(41626AA8-16A4-47DF-95C5-A4EA2C7BCB5D),
dual,
nonextensible,
helpstring("SMTP authentication settings"),
pointer_default(unique)
]
interface IFPCSmtpAuthenticationSettings : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets a Boolean value that indicates whether credentials will be sent for authentication to external servers")]
    HRESULT IntegratedWindowsAuthenticateEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets a Boolean value that indicates whether credentials will be sent for authentication to external servers")]
    HRESULT IntegratedWindowsAuthenticateEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(2), helpstring("Gets or sets a Boolean value that indicates whether the Transport Layer Security (TLS) protocol is enabled")]
    HRESULT TlsEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(2), helpstring("Gets or sets a Boolean value that indicates whether the Transport Layer Security (TLS) protocol is enabled")]
    HRESULT TlsEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(3), helpstring("Gets or sets a Boolean value that indicates whether domain security is enabled")]
    HRESULT DomainSecurityEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(3), helpstring("Gets or sets a Boolean value that indicates whether domain security is enabled")]
    HRESULT DomainSecurityEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(4), helpstring("Gets or sets a Boolean value that indicates whether Basic authentication is enabled")]
    HRESULT BasicAuthenticationEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(4), helpstring("Gets or sets a Boolean value that indicates whether Basic authentication is enabled")]
    HRESULT BasicAuthenticationEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(5), helpstring("Gets or sets a Boolean value that indicates whether Basic authentication is enabled only after TLS started")]
    HRESULT OfferBasicAuthenticationAfterTLSEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(5), helpstring("Gets or sets a Boolean value that indicates whether Basic authentication is enabled only after TLS started")]
    HRESULT OfferBasicAuthenticationAfterTLSEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(6), helpstring("Gets or sets a Boolean value that indicates whether credentials will be sent to Exchange servers for authentication")]
    HRESULT ExchangeServerAuthenticationEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(6), helpstring("Gets or sets a Boolean value that indicates whether credentials will be sent to Exchange servers for authentication")]
    HRESULT ExchangeServerAuthenticationEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(7), helpstring("Gets or sets a Boolean value that indicates whether the externally secured connections, for example, by IPsec, are enabled")]
    HRESULT ExternallySecuredEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(7), helpstring("Gets or sets a Boolean value that indicates whether the externally secured connections, for example, by IPsec, are enabled")]
    HRESULT ExternallySecuredEnabled([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(255B1484-3BE1-4634-8E59-34B537261BBF),
dual,
nonextensible,
helpstring("SMTP route authentication settings"),
pointer_default(unique)
]
interface IFPCSmtpRouteAuthenticationSettings : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets a FpcSmtpDestinationAuthenticationMethod value that indicates which authentication method will be used for destination servers")]
    HRESULT DestinationAuthenticationMethod([out, retval] FpcSmtpDestinationAuthenticationMethod *pVal);
    [propput, id(1), helpstring("Gets or sets a FpcSmtpDestinationAuthenticationMethod value that indicates which authentication method will be used for destination servers")]
    HRESULT DestinationAuthenticationMethod([in] FpcSmtpDestinationAuthenticationMethod newVal);
	
	[propget, id(2), helpstring("Gets or sets a Boolean value that indicates whether the Transport Layer Security (TLS) protocol is enabled")]
    HRESULT TlsEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(2), helpstring("Gets or sets a Boolean value that indicates whether the Transport Layer Security (TLS) protocol is enabled")]
    HRESULT TlsEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(3), helpstring("Gets the credentials that will be supplied for Basic authentication")]
    HRESULT Credentials([out, retval] IFPCCredentials **pVal);
	
};
	
[
object,
uuid(950CADEE-1420-40E2-BEA6-FBDB46CBA320),
dual,
nonextensible,
helpstring("SMTP route"),
pointer_default(unique)
]
interface IFPCSmtpRoute : IFPCPersist
{
	[propget, id(DISPID_VALUE), helpstring("Gets or sets the name of the route")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(DISPID_VALUE), helpstring("Gets or sets the name of the route")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(1), helpstring("Gets or sets the description of the route")]
    HRESULT Description([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the description of the route")]
    HRESULT Description([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets a Boolean value that indicates whether the route is enabled")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(2), helpstring("Gets or sets a Boolean value that indicates whether the route is enabled")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(3), helpstring("Gets or sets a value from the FpcSmtpRouteDirection enumerated type that indicates whether the route is to an internal  or Internet server")]
    HRESULT RouteDirection([out, retval] FpcSmtpRouteDirection *pVal);
    [propput, id(3), helpstring("Gets or sets a value from the FpcSmtpRouteDirection enumerated type that indicates whether the route is to an internal  or Internet server")]
    HRESULT RouteDirection([in] FpcSmtpRouteDirection newVal);
	
	[propget, id(4), helpstring("Gets or sets the FQDN for the response of the listener to an EHLO or HELO command")]
    HRESULT EhloResponse([out, retval] BSTR *pVal);
    [propput, id(4), helpstring("Gets or sets the FQDN for the response of the listener to an EHLO or HELO command")]
    HRESULT EhloResponse([in] BSTR newVal);
	
	[propget, id(5), helpstring("Gets or sets a Boolean value that indicates whether the maximum message size enforcement is enabled")]
    HRESULT MaxMessageSizeEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(5), helpstring("Gets or sets a Boolean value that indicates whether the maximum message size enforcement is enabled")]
    HRESULT MaxMessageSizeEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(6), helpstring("Gets or sets a maximum message size")]
    HRESULT MaxMessageSize([out, retval] long *pVal);
    [propput, id(6), helpstring("Gets or sets a maximum message size")]
    HRESULT MaxMessageSize([in] long newVal);
	
	[propget, id(7), helpstring("Gets or sets a value from  the FpcMailForwardingMethod enumerated type that indicates the mail forwarding method for the route")]
    HRESULT MailForwardingMethod([out, retval] FpcMailForwardingMethod *pVal);
    [propput, id(7), helpstring("Gets or sets a value from  the FpcMailForwardingMethod enumerated type that indicates the mail forwarding method for the route")]
    HRESULT MailForwardingMethod([in] FpcMailForwardingMethod newVal);
	
	[propget, id(8), helpstring("Gets or sets the mail forwarding address that will be used for direct mail forwarding")]
    HRESULT MailForwardingAddress([out, retval] BSTR *pVal);
    [propput, id(8), helpstring("Gets or sets the mail forwarding address that will be used for direct mail forwarding")]
    HRESULT MailForwardingAddress([in] BSTR newVal);
	
	[propget, id(9), helpstring("Gets or sets a Boolean value that indicates whether the specific source IP address is enabled for the route")]
    HRESULT SpecificSourceIpAddressEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(9), helpstring("Gets or sets a Boolean value that indicates whether the specific source IP address is enabled for the route")]
    HRESULT SpecificSourceIpAddressEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(10), helpstring("Gets or sets the specific source IP address for this route")]
    HRESULT SpecificSourceIpAddress([out, retval] BSTR *pVal);
    [propput, id(10), helpstring("Gets or sets the specific source IP address for this route")]
    HRESULT SpecificSourceIpAddress([in] BSTR newVal);
	
	[propget, id(11), helpstring("Gets an FPCSmtpAuthenticationSettings object that holds the  authentication settings for the listener")]
    HRESULT ListenerAuthenticationSettings([out, retval] IFPCSmtpAuthenticationSettings **pVal);
	
	[propget, id(12), helpstring("Gets an FPCSmtpRouteAuthenticationSettings object containing the  authentication settings for the route")]
    HRESULT RouteAuthenticationSettings([out, retval] IFPCSmtpRouteAuthenticationSettings **pVal);
	
	[propget, id(13), helpstring("Gets an FPCIPsOnNetworks collection that contains information about the IP addresses on which Forefront TMG listens for SMTP requests from particular networks")]
    HRESULT IPsOnNetworks([out, retval] IFPCIPsOnNetworks **pVal);
	
	[propget, id(14), helpstring("Gets a reference to the collection of network sets to listen")]
    HRESULT IPsOnNetworkSets([out, retval] IFPCRefs **pVal);
	
	[propget, id(15), helpstring("Gets an FPCComputers collection that contains the internal SMTP mail servers in the organization")]
    HRESULT InternalMailServers([out, retval] IFPCComputers **pVal);
	
	[propget, id(16), helpstring("Gets an FPCAddressSpaces collection of the address spaces associated with the route")]
    HRESULT AddressSpaces([out, retval] IFPCAddressSpaces **pVal);
	
};
	
[
object,
uuid(C8A6C601-99AA-4B9F-9EA8-01678AB1F203),
dual,
nonextensible,
helpstring("Collection of SMTP routes"),
pointer_default(unique)
]
interface IFPCSmtpRoutes : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Retrieves the requested FPCSmtpRoute object from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCSmtpRoute** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_REMOVE), helpstring("Removes the specified FPCSmtpRoute object from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_ADD), helpstring("Creates a new FPCSmtpRoute object in the collection and returns a reference to it")]
          HRESULT Add([in] BSTR Name,
              [out,retval] IFPCSmtpRoute** ppNewItem);
        
    
};
	
[
object,
uuid(e8d6aa1e-3ec3-4673-9906-9ccd04a771cb),
dual,
nonextensible,
helpstring("A collection of filter lists"),
pointer_default(unique)
]
interface IFPCMailAntispamFilterLists : IFPCPersist
{
	[propget, id(1), helpstring("Gets a value from the FpcMailAntispamFilterListType enumerated type that specifies the type of the lists in the collection")]
    HRESULT Type([out, retval] FpcMailAntispamFilterListType *pVal);
	
	[id(DISPID_VALUE), helpstring("Retrieves the requested IFPCMailAntispamFilterList object from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] IFPCMailAntispamFilterList** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_REMOVE), helpstring("Removes the specified IFPCMailAntispamFilterList object from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_ADD), helpstring("Creates a new IFPCMailAntispamFilterList object in the collection and returns a reference to it")]
          HRESULT Add( BSTR Name,
              [out,retval] IFPCMailAntispamFilterList** ppNewList);
        
    
};
	
[
object,
uuid(a56d3bdf-5d87-4e7b-9ac6-4463bcfbfde5),
dual,
nonextensible,
helpstring("An antispam filtering feature object"),
pointer_default(unique)
]
interface IFPCMailAntispamFilterList : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets the name of the filter list")]
    HRESULT Name([out, retval] BSTR *pVal);
    [propput, id(1), helpstring("Gets or sets the name of the filter list")]
    HRESULT Name([in] BSTR newVal);
	
	[propget, id(2), helpstring("Gets or sets the a Boolean value that indicates whether the filter list is enabled")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(2), helpstring("Gets or sets the a Boolean value that indicates whether the filter list is enabled")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(3), helpstring("Gets or sets a value from the FpcMailAntiSpamFilterAction enumerated type that specifies the action to be taken when a matching message is detected")]
    HRESULT Action([out, retval] FpcMailAntiSpamFilterAction *pVal);
    [propput, id(3), helpstring("Gets or sets a value from the FpcMailAntiSpamFilterAction enumerated type that specifies the action to be taken when a matching message is detected")]
    HRESULT Action([in] FpcMailAntiSpamFilterAction newVal);
	
	[propget, id(4), helpstring("Gets or sets a Boolean value that indicates whether the filter list will be used  to scan inbound messages")]
    HRESULT ScanInboundMessages([out, retval] VARIANT_BOOL *pVal);
    [propput, id(4), helpstring("Gets or sets a Boolean value that indicates whether the filter list will be used  to scan inbound messages")]
    HRESULT ScanInboundMessages([in] VARIANT_BOOL newVal);
	
	[propget, id(5), helpstring("Gets or sets a Boolean value that indicates whether the filter list will be used  to scan outbound messages")]
    HRESULT ScanOutboundMessages([out, retval] VARIANT_BOOL *pVal);
    [propput, id(5), helpstring("Gets or sets a Boolean value that indicates whether the filter list will be used  to scan outbound messages")]
    HRESULT ScanOutboundMessages([in] VARIANT_BOOL newVal);
	
	[propget, id(6), helpstring("Gets a value from the FpcMailAntispamFilterListType enumerated type that specifies the type of the list")]
    HRESULT Type([out, retval] FpcMailAntispamFilterListType *pVal);
	
	[propget, id(7), helpstring("Gets a collection of items this filter detects")]
    HRESULT Items([out, retval] IFPCMailAntispamFilterStrings **pVal);
	
	[propget, id(8), helpstring("Gets a collection of file types this filter detects")]
    HRESULT FileTypes([out, retval] IFPCMailAntispamFilterFileTypes **pVal);
	
};
	
[
object,
uuid(b2b02524-d8b7-464b-ba19-2b1cf6896e1d),
dual,
nonextensible,
helpstring("SecurityAssessmentSharing"),
pointer_default(unique)
]
interface IFPCSecurityAssessmentSharing : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets a Boolean value that indicates whether the security assessment agent can be used")]
    HRESULT SecurityAssessmentAgentStatus([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets a Boolean value that indicates whether the security assessment agent can be used")]
    HRESULT SecurityAssessmentAgentStatus([in] VARIANT_BOOL newVal);
	
	[propget, id(2), helpstring("Gets or sets the IP address of the internal honeypot for security assessments")]
    HRESULT HoneypotIpAddress([out, retval] BSTR *pVal);
    [propput, id(2), helpstring("Gets or sets the IP address of the internal honeypot for security assessments")]
    HRESULT HoneypotIpAddress([in] BSTR newVal);
	
	[propget, id(3), helpstring("Gets or sets a Boolean value that indicates whether SMTP protection is controlled according to Forefront TMG policies or according to Forefront Protection Manager policies")]
    HRESULT SmtpProtectionControl([out, retval] VARIANT_BOOL *pVal);
    [propput, id(3), helpstring("Gets or sets a Boolean value that indicates whether SMTP protection is controlled according to Forefront TMG policies or according to Forefront Protection Manager policies")]
    HRESULT SmtpProtectionControl([in] VARIANT_BOOL newVal);
	
	[propget, id(4), helpstring("Gets or sets a Boolean value that indicates whether NAP integration is enabled")]
    HRESULT NapIntegrationEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(4), helpstring("Gets or sets a Boolean value that indicates whether NAP integration is enabled")]
    HRESULT NapIntegrationEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(5), helpstring("Gets or sets a Boolean value that indicates whether array members will apply assessment-dictated responses to computers")]
    HRESULT ApplyResponsesToComputers([out, retval] VARIANT_BOOL *pVal);
    [propput, id(5), helpstring("Gets or sets a Boolean value that indicates whether array members will apply assessment-dictated responses to computers")]
    HRESULT ApplyResponsesToComputers([in] VARIANT_BOOL newVal);
	
	[propget, id(6), helpstring("Gets or sets a Boolean value that indicates whether  array members will apply assessment-dictated responses to users")]
    HRESULT ApplyResponsesToUsers([out, retval] VARIANT_BOOL *pVal);
    [propput, id(6), helpstring("Gets or sets a Boolean value that indicates whether  array members will apply assessment-dictated responses to users")]
    HRESULT ApplyResponsesToUsers([in] VARIANT_BOOL newVal);
	
	[propget, id(7), helpstring("Gets or sets the security assessment sharing agent configuration")]
    HRESULT AgentConfiguration([out, retval] BSTR *pVal);
    [propput, id(7), helpstring("Gets or sets the security assessment sharing agent configuration")]
    HRESULT AgentConfiguration([in] BSTR newVal);
	
	[propget, id(8), helpstring("Gets or sets the security assessment sharing agent configuration file name")]
    HRESULT AgentConfigurationFileName([out, retval] BSTR *pVal);
    [propput, id(8), helpstring("Gets or sets the security assessment sharing agent configuration file name")]
    HRESULT AgentConfigurationFileName([in] BSTR newVal);
	
	[propget, id(9), helpstring("Gets or sets the SCOM server management group name")]
    HRESULT ScomManagementGroupName([out, retval] BSTR *pVal);
    [propput, id(9), helpstring("Gets or sets the SCOM server management group name")]
    HRESULT ScomManagementGroupName([in] BSTR newVal);
	
	[propget, id(10), helpstring("Gets or sets a flag indicating if Blocked Computers evaluation can be applied in kernel mode")]
    HRESULT EnableKernelModeBlockedListEvaluation([out, retval] VARIANT_BOOL *pVal);
    [propput, id(10), helpstring("Gets or sets a flag indicating if Blocked Computers evaluation can be applied in kernel mode")]
    HRESULT EnableKernelModeBlockedListEvaluation([in] VARIANT_BOOL newVal);
	
};
	
[
object,
uuid(d7d40645-b1e4-451e-8da3-26d8d4b78c63),
dual,
nonextensible,
helpstring("A collection of filter strings"),
pointer_default(unique)
]
interface IFPCMailAntispamFilterStrings : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Retrieves the requested filter string from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] BSTR* filterString);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_REMOVE), helpstring("Removes the specified filter string from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_ADD), helpstring("Adds a filter string to the collection")]
          HRESULT Add( BSTR filterString);
        
    
};
	
[
object,
uuid(d0167360-2791-4ecc-8e68-2b54186ea0b9),
dual,
nonextensible,
helpstring("A collection of mail antispam filter file types"),
pointer_default(unique)
]
interface IFPCMailAntispamFilterFileTypes : IFPCPersist
{
	[id(DISPID_VALUE), helpstring("Retrieves the requested FpcMailAntiSpamFileType object from the collection")]
          HRESULT Item( VARIANT v,
              [out,retval] FpcMailAntiSpamFileType* Name);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_REMOVE), helpstring("Removes the specified FpcMailAntiSpamFileType object from the collection")]
          HRESULT Remove( VARIANT v);
        
    
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_ADD), helpstring("Adds a file type to the collection")]
          HRESULT Add( FpcMailAntiSpamFileType fileType);
        
    
};
	
[
object,
uuid(BE4025CF-0ED8-4763-96B5-4E13AA176D08),
dual,
nonextensible,
helpstring("Collection of restricted port ranges"),
pointer_default(unique)
]
interface IFPCRestrictedPorts : IFPCPersist
{
	[propget, id(DISPID_COUNT), helpstring("Gets the number of objects in the collection")]
    HRESULT Count([out, retval] long *pVal);
	
	[id(DISPID_VALUE), helpstring("Retrieves the requested FPCRestrictedPortsRange object from the collection")]
          HRESULT Item([in] long Index,
              [out,retval] IFPCRestrictedPortsRange** pItem);
        
    
	[propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

	[id(DISPID_ADD), helpstring("Creates a new FPCRestrictedPortsRange object in the collection")]
          HRESULT Add([in] USHORT usPortLow,
              [in] USHORT usPortHigh,
              [out,retval] IFPCRestrictedPortsRange** ppPortsRange);
        
    
	[id(DISPID_REMOVE), helpstring("Removes the specified FPCRestrictedPortsRange object from the collection")]
          HRESULT Remove([in] long lIndex);
        
    
};
	
[
object,
uuid(25AC6E39-F78A-4727-8020-4F5390AC3513),
dual,
nonextensible,
helpstring("Range of the Restricted Ports: from low to high"),
pointer_default(unique)
]
interface IFPCRestrictedPortsRange : IDispatch
{
	[propget, id(1), helpstring("Gets lowest port of the range")]
    HRESULT PortLow([out, retval] long *pVal);
	
	[propget, id(2), helpstring("Gets highest port of the range")]
    HRESULT PortHigh([out, retval] long *pVal);
	
	[id(3), helpstring("Get both low and high port - cannot be called from VBScript")]
          HRESULT GetRange([out] long* pdwPortLow,
              [out] long* pdwPortHigh);
        
    
};
	
[
object,
uuid(1236FE62-9ACD-4EBC-A2C3-EC13A04C9036),
dual,
nonextensible,
helpstring("Change tracking settings and log"),
pointer_default(unique)
]
interface IFPCChangeTracking : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets a Boolean value that indicates whether change tracking is enabled")]
    HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets a Boolean value that indicates whether change tracking is enabled")]
    HRESULT Enabled([in] VARIANT_BOOL newVal);
	
	[propget, id(2), helpstring("Gets or sets the maximum number of entries that can be included in the change tracking log")]
    HRESULT MaxEntries([out, retval] long *pVal);
    [propput, id(2), helpstring("Gets or sets the maximum number of entries that can be included in the change tracking log")]
    HRESULT MaxEntries([in] long newVal);
	
	[propget, id(3), helpstring("Gets a Boolean value that indicates whether change tracking was enabled when the stored configuration was loaded"), hidden]
    HRESULT InitiallyEnabled([out, retval] VARIANT_BOOL *pVal);
	
	[propget, id(4), helpstring("Gets the change tracking log")]
    HRESULT ChangeLog([out, retval] BSTR *pVal);
	
	[id(5), helpstring("Sets the change tracking log"), hidden]
          HRESULT SetChangeLog([in] BSTR ChangeLog);
        
    
	[propget, id(6), helpstring("Gets or sets a Boolean value that indicates whether change tracking log will be cleared on the next Save call"), hidden]
    HRESULT ClearLog([out, retval] VARIANT_BOOL *pVal);
    [propput, id(6), helpstring("Gets or sets a Boolean value that indicates whether change tracking log will be cleared on the next Save call"), hidden]
    HRESULT ClearLog([in] VARIANT_BOOL newVal);
	
	[id(7), helpstring("Writes the change tracking log to file")]
          HRESULT WriteLogToFile([in] BSTR FileName);
        
    
};
	
[
object,
uuid(FA582D43-F10B-49D2-86AA-39684E88605E),
dual,
nonextensible,
helpstring("IPv6 Settings"),
pointer_default(unique)
]
interface IFPCIPv6Settings : IFPCPersist
{
	[propget, id(1), helpstring("Gets or sets a Boolean value that indicates whether Direct Access Mode is enabled"), hidden]
    HRESULT DirectAccessEnabled([out, retval] VARIANT_BOOL *pVal);
    [propput, id(1), helpstring("Gets or sets a Boolean value that indicates whether Direct Access Mode is enabled"), hidden]
    HRESULT DirectAccessEnabled([in] VARIANT_BOOL newVal);
	
	[propget, id(2), helpstring("Gets or sets a Boolean value that indicates whether translation ignores TOS in NAT-PT"), hidden]
    HRESULT IgnoreTosInNatPt([out, retval] VARIANT_BOOL *pVal);
    [propput, id(2), helpstring("Gets or sets a Boolean value that indicates whether translation ignores TOS in NAT-PT"), hidden]
    HRESULT IgnoreTosInNatPt([in] VARIANT_BOOL newVal);
	
	[propget, id(3), helpstring("Gets or sets whether IPv6 traffic is supported"), hidden]
    HRESULT  EnableIPv6Support([out, retval] VARIANT_BOOL *pVal);
    [propput, id(3), helpstring("Gets or sets whether IPv6 traffic is supported"), hidden]
    HRESULT  EnableIPv6Support([in] VARIANT_BOOL newVal);
	
};
	

/////////////////////////////////////////////////////////////////////////

[
object,
uuid(37FEA673-89F3-4E50-B8A1-59A4A1A9B2F0),
dual,
nonextensible,
helpstring("Persist interface"),
pointer_default(unique)
]
interface IFPCPersist : IDispatch
{
    [id(DISPID_EXPORT), helpstring("Writes the stored values of all of the object's properties to the specified XML document.")]
    HRESULT Export([in] IUnknown *pDocument,
                    [in] long OptionalData,
                    [in, defaultvalue(NULL)] BSTR EncryptionPassword,
                    [in, defaultvalue(NULL)] BSTR Comment);

    [id(DISPID_IMPORT), helpstring("Copies the values of all of the object's properties from the specified XML document to persistent storage.")]
    HRESULT Import([in] IUnknown *pDocument,
                    [in] long OptionalData,
                    [in, defaultvalue(NULL)] BSTR EncryptionPassword,
                    [in, defaultvalue(VARIANT_FALSE)] VARIANT_BOOL CleanCollections,
                    [in, defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
                    [in, defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);

    [id(DISPID_EXPORT_FILE), helpstring("Writes the stored values of all of the object's properties to the specified XML file.")]
    HRESULT ExportToFile([in] BSTR XmlFileName,
                    [in] long OptionalData,
                    [in, defaultvalue(NULL)] BSTR EncryptionPassword,
                    [in, defaultvalue(NULL)] BSTR Comment);

    [id(DISPID_IMPORT_FILE), helpstring("Copies the values of all of the object's properties from the specified XML file to persistent storage.")]
    HRESULT ImportFromFile([in] BSTR XmlFileName,
                    [in] long OptionalData,
                    [in, defaultvalue(NULL)] BSTR EncryptionPassword,
                    [in, defaultvalue(VARIANT_FALSE)] VARIANT_BOOL CleanCollections,
                    [in, defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
                    [in, defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);

    [id(DISPID_CANIMPORT), helpstring("Returns a Boolean value that indicates whether the object's properties can be imported from the specified XML document.")]
    HRESULT CanImport([in] IUnknown *pDocument,
                        [in, defaultvalue(VARIANT_FALSE)] VARIANT_BOOL bValidateSchema,
                        [out, retval] VARIANT_BOOL* pbRetVal);

    [id(DISPID_LOADDOCPROPERTIES), helpstring("Provides the XML document's properties so that you can know what information can be imported from the document.")]
    HRESULT LoadDocProperties([in] IUnknown *pDocument,
                                [out, defaultvalue(NULL)] BSTR *ItemType,
                                [out, defaultvalue(NULL)] long *OptionalData,
                                [out, defaultvalue(NULL)] BSTR *Comment);

    [id(DISPID_SAVE), helpstring("Writes the current values of all of the object's properties to persistent storage.")]
    HRESULT Save([in, defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
                 [in, defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);

    [id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
    HRESULT Refresh();

    [propget, id(DISPID_PERSISTENTNAME), helpstring("Gets the persistent name of the object. The persistent name of an object is a name that is unique for the object at the respective level of the COM object hierarchy")]
    HRESULT PersistentName([out, retval] BSTR *bstrPersistentName);

    [propget, id(DISPID_VENDOR_SETS), helpstring("Gets an FPCVendorParametersSets object that can hold sets of custom data for extending the object.")]
    HRESULT VendorParametersSets([out, retval] IFPCVendorParametersSets **pVal);

    [id(DISPID_WAIT_FOR_CHANGES), helpstring("Registers to wait for an event indicating that the contents of the object have changed (for use in C and C++ programming only)."), restricted, local]
    HRESULT WaitForChanges([in] INT64 hEvent);

    [id(DISPID_CANCEL_WAIT_FOR_CHANGES), helpstring("Cancels the registration established by the WaitForChanges method (for use in C and C++ programming only)."), restricted]
    HRESULT CancelWaitForChanges();

    [id(DISPID_GET_RESTART_MASK), helpstring("Retrieves a 32-bit bitmask of the FpcServices enumerated type that specifies which services need to be restarted for currently unsaved changes to take effect.")]
    HRESULT GetServiceRestartMask([out, retval] long *plServiceRestartMask);

    [id(DISPID_GET_DIRTY_FEATURES), hidden, helpstring("Get a bitmask of the are dirty")]
    HRESULT GetDirtyFeatureMask([out, retval] long *plDirtyFeatureMask);

    [id(DISPID_IMPORT_AS_NEW), hidden, helpstring("Imports object from an xml with a new storage name")]
    HRESULT ImportAsNew([in] IUnknown *pDocument,
               [in] long OptionalData,
               [in, defaultvalue(NULL)] BSTR EncryptionPassword,
               [in, defaultvalue(VARIANT_FALSE)] VARIANT_BOOL CleanCollections,
               [in, defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
               [in, defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration,
               [out, defaultvalue(NULL)] BSTR * pbstrNewItemKey);

};

interface IFPCSnapinNode;
interface IFPCSnapinPluginPolicy;

[
    object,
    uuid(99DD77E8-D1AD-40BD-8D3C-43A8E68BF553),
    helpstring("Used to extend Firwall Server management"),
    pointer_default(unique),
    oleautomation
]
interface IFPCSnapinNode : IUnknown
{
    [propget, id(1), helpstring("Gets the FPC root object")]
    HRESULT ComRoot([out, retval] IDispatch **pVal);

    [propget, id(2), helpstring("Gets the object that you are extending")]
    HRESULT CurrentObject([out, retval] IDispatch **pVal);

    [propget, id(3), helpstring("Gets the array under which you are creating an extension")]
    HRESULT ParentArray([out, retval] IDispatch **pVal);

    [propget, id(4), helpstring("Gets the FPCEnterprisePolicy under which you create an extension")]
    HRESULT ParentPolicy([out, retval] IDispatch **pVal);

    [propget, id(5), helpstring("Retrieves plugin policy object for this data object")]
    HRESULT PluginPolicy([out, retval] IFPCSnapinPluginPolicy** ppPluginPolicy);

    [id(DISPID_REFRESH), helpstring("Reads the values of all of the object's properties from persistent storage, overwriting any changes that have not been saved.")]
    HRESULT Refresh();
};

[
    object,
    uuid(C8322444-DA17-4FD8-8538-DEAD31ECF26D),
    helpstring("Used to extend Firwall Server plugin policy"),
    pointer_default(unique),
    oleautomation
]
interface IFPCSnapinPluginPolicy : IUnknown
{
    [id(1), helpstring("Checks whether specified protocol is selected")]
    HRESULT IsProtocolSelected([in] BSTR bstrProtocolGuid);

    [id(2), helpstring("Checks whether any protocol applied to specified application filter is selected")]
    HRESULT IsApplicationFilterSelected([in] BSTR bstrAppFilterGuid);

    [propget, id(3), helpstring("Returns currently selected policy rule action (allow / deny)")]
    HRESULT CurrentAction([out, retval] FpcPolicyRuleActions* pAction);

    [propget, id(4), helpstring("Retrieves policy rule of the plugin policy (the policy rule may be outdated)")]
    HRESULT PolicyRule([out, retval] IFPCPolicyRule** ppPolicyRule);

    [propget, id(5), helpstring("Retrieve vendor parameters sets in which the extension can store data")]
    HRESULT VendorParametersSets([out, retval] IFPCVendorParametersSets** ppVps);

    [id(6), helpstring("A must-be indication that the extension implements plugin policy")]
    HRESULT IndicatePluginPolicy();
};

[
    hidden,
    object,
    uuid(AB7FEB86-DCFC-4933-8913-7BBD9A813711),
    helpstring("IFPCUtilityFunctionsInternal Interface"),
    pointer_default(unique),
    oleautomation
]
interface IFPCUtilityFunctionsInternal : IUnknown
{
    [id(1), helpstring("Gets a Boolean value which indicates whether an application filter is selected")]
    HRESULT IsApplicationFilterSelected([in] BSTR bstrAppFilterGuid,
                                        [in] VARIANT ProtocolGuidsArray,
                                        [in] FpcProtocolSelectionType SelectionType,
                                        [in, defaultvalue(NULL)] IFPCArray* pArray,
                                        [out, retval] VARIANT_BOOL *pvbSelected);
};

[
    hidden,
    object,
    uuid(57a9e274-4bff-4dc5-bfe1-f60cb2dd2ca2),
    helpstring("IFPCServiceResponsivenessInternal Interface"),
    pointer_default(unique),
    oleautomation
]
interface IFPCServiceResponsivenessInternal : IUnknown
{
    /*[propget, id(1), helpstring("Gets or sets whether the Firewall Service is responding to RPC")]
    HRESULT FirewallServiceRPCResponsiveness([out, retval] FpcServiceRpcResponsiveness *pVal);
    [propput, id(1), helpstring("Gets or sets whether the Firewall Service is responding to RPC")]
    HRESULT FirewallServiceRPCResponsiveness([in] FpcServiceRpcResponsiveness newVal);

    [propget, id(2), helpstring("Gets or sets whether the ISASTG Service is responding to RPC")]
    HRESULT ISASTGServiceRPCResponsiveness([out, retval] FpcServiceRpcResponsiveness *pVal);
    [propput, id(2), helpstring("Gets or sets whether the ISASTG Service is responding to RPC")]
    HRESULT ISASTGServiceRPCResponsiveness([in] FpcServiceRpcResponsiveness newVal);

    [propget, id(3), helpstring("Gets or sets whether the ISACTRL Service is responding to RPC")]
    HRESULT ISACTRLServiceRPCResponsiveness([out, retval] FpcServiceRpcResponsiveness *pVal);
    [propput, id(3), helpstring("Gets or sets whether the ISACTRL Service is responding to RPC")]
    HRESULT ISACTRLServiceRPCResponsiveness([in] FpcServiceRpcResponsiveness newVal);

    [propget, id(4), helpstring("Gets or sets whether the Job Scheduler Service is responding to RPC")]
    HRESULT JobSchedulerServiceRPCResponsiveness([out, retval] FpcServiceRpcResponsiveness *pVal);
    [propput, id(4), helpstring("Gets or sets whether the Job Scheduler Service is responding to RPC")]
    HRESULT JobSchedulerServiceRPCResponsiveness([in] FpcServiceRpcResponsiveness newVal);*/

    [propget, id(1), helpstring("Gets or sets whether the given service is responding to RPC")]
    HRESULT ServiceRPCResponsiveness([in] FpcRPCServices Service, [out, retval] FpcServiceRpcResponsiveness *pVal);
    [propput, id(1), helpstring("Gets or sets whether the given service is responding to RPC")]
    HRESULT ServiceRPCResponsiveness([in] FpcRPCServices Service, [in] FpcServiceRpcResponsiveness newVal);

    [propget, id(2), helpstring("Gets or sets whether the server is responding to RPC")]
    HRESULT ServerRPCResponsiveness([out, retval] FpcServiceRpcResponsiveness *pVal);
};

[
hidden,
object,
uuid(8e5b2d82-6808-47b5-b1a8-094993f6a5e7),
helpstring("IFPCEnableUIModeInternal Interface"),
pointer_default(unique)
]
interface IFPCEnableUIModeInternal : IUnknown
{
    [id(1), helpstring("Sets the COM to work in UI Mode - UI decides which service is non-responsive")]
    HRESULT EnableUIMode([in] DWORD dwRpcTimeout);
};

[
    hidden,
    object,
    uuid(1EF94A2A-A479-41c2-9D20-A167764554F2),
    helpstring("IFPCCredentialsInternal Interface"),
    pointer_default(unique),
    oleautomation
]
interface IFPCCredentialsInternal : IUnknown
{
    [id(5), helpstring("Get the password (valid only on Microsoft Forefront Threat Management Gateway computer under Local System or Network Service account)")]
    HRESULT GetClearTextPassword([out, retval] BSTR *pVal);
};

[
    object,
    uuid(03cb3712-83f3-4670-8483-00ef305c3de5),
    nonextensible,
    helpstring("IFPCCollectionInternal Interface"),
    pointer_default(unique),
    oleautomation
]
interface IFPCCollectionInternal : IUnknown
{
    [propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);

    [id(DISPID_REMOVE), helpstring("Removes an item from the collection (by name)")]
    HRESULT Remove(VARIANT v);

    [id(1), helpstring("method GetGuidFromName")]
    HRESULT GetGuidFromName([in]  BSTR Name, [out] BSTR *pBstrGuid);

    [id(2), helpstring("method GetNameFromGuid")]
    HRESULT GetNameFromGuid([in]  BSTR Guid, [out] BSTR *pBstrName);

    [id(3), helpstring("Returns a specific item from the collection")]
    HRESULT ItemByKey([in] BSTR Name, [out, retval] IFPCItemInternal **pItem);

    [id(4), helpstring("Returns a specific item from the collection")]
    HRESULT ItemByGuid([in] BSTR Guid, [out, retval] IFPCItemInternal **pItem);

    [id(5), helpstring("Returns a specific item from the collection")]
    HRESULT AddWithStorageName([in] BSTR Key, [in] BSTR StorageName, [out, retval] IFPCItemInternal **pItem);

    [propget, id(DISPID_COUNT), helpstring("Gets the number of items in the object")]
    HRESULT Count([out, retval] long *pVal);

};


//
// Object Status
//
typedef [v1_enum] enum ComObjStatus
{
    objNone,
    objRefreshing,
    objExistRefreshing,
    objImporting,
    objExistImporting,
    objRefImporting,
    objSaving,
    objForceSaving,
    objExporting,
    objForceExporting,
    objRefExporting
} ComObjStatus;

typedef [v1_enum] enum FpcVerifyType
{
    fpcVtRemove,
    fpcVtChange
} FpcVerifyType;

[
    hidden,
    object,
    uuid(6B4847DF-C7D4-4f6c-84C1-51746EB827F5),
    helpstring("IFPCItemInternal Interface"),
    pointer_default(unique),
    oleautomation
]
interface IFPCItemInternal : IUnknown
{
    [propget, id(1), helpstring("property ObjectGUID")]
    HRESULT ObjectGUID([out, retval] BSTR *bstrGUID);

    [propget, id(2), helpstring("property ObjectKey")]
    HRESULT ObjectKey([out, retval] BSTR *bstrKey);

    [propget, id(3), helpstring("property ObjectScope")]
    HRESULT ObjectScope([out, retval] FpcItemScope *pScope);

    [id(4), helpstring("method ObjectRefresh")]
    HRESULT ObjectRefresh([in, defaultvalue(objRefreshing)] ComObjStatus newStatus,
                          [in, defaultvalue(VARIANT_FALSE)] VARIANT_BOOL OneLevelOnly);

    [id(5), helpstring("method ObjectSave")]
    HRESULT ObjectSave([in, defaultvalue(objSaving)] ComObjStatus newStatus);

    [id(6), helpstring("method ObjectVerifyChangeOnMe")]
    HRESULT ObjectVerifyChangeOnMe([in] FpcVerifyType VerifyType);

    [id(7), helpstring("method ObjectVerifyChangeOnItem")]
    HRESULT ObjectVerifyChangeOnItem([in] FpcVerifyType VerifyType,
                                     [in] BSTR Name,
                                     [in] BSTR Guid,
                                     [in] BSTR Class,
                                     [in] FpcItemScope Scope);

    [id(8), helpstring("method FindCollectionForObject")]
    HRESULT FindCollectionForObject([in] ComObjStatus newStatus,
                                    [in] BSTR Class,
                                    [out, retval] IFPCCollectionInternal **pInternal);

    [id(9), helpstring("method FindItem")]
    HRESULT FindItem([in] ComObjStatus newStatus,
                     [in] BSTR Name,
                     [in] BSTR Class,
                     [out, retval] IFPCItemInternal **pInternal);

    [id(10), helpstring("method ObjectExport")]
    HRESULT ObjectExport([in] IUnknown *pDocument,
                         [in] long OptionalData,
                         [in, defaultvalue(NULL)] BSTR EncryptionPassword,
                         [in, defaultvalue(NULL)] BSTR Comment);

    [id(11), helpstring("method ObjectImport")]
    HRESULT ObjectImport([in] BSTR fileName,
                         [in] IUnknown *pDocument,
                         [in] long OptionalData,
                         [in, defaultvalue(NULL)] BSTR EncryptionPassword,
                         [in, defaultvalue(VARIANT_FALSE)] VARIANT_BOOL CleanCollections,
                         [in, defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fResetRequiredServices,
                         [in, defaultvalue(VARIANT_TRUE)] VARIANT_BOOL fReloadConfiguration);

    [id(12), helpstring("method ObjectCanImport")]
    HRESULT ObjectCanImport([in] IUnknown *pDocument,
                      [in, defaultvalue(VARIANT_FALSE)] VARIANT_BOOL bValidateSchema,
                      [out, retval] VARIANT_BOOL* pbRetVal);

    [id(13), helpstring("method ObjectLoadDocProperties")]
    HRESULT ObjectLoadDocProperties([in] IUnknown *pDocument,
                              [out, defaultvalue(NULL)] BSTR *ItemType,
                              [out, defaultvalue(NULL)] long *OptionalData,
                              [out, defaultvalue(NULL)] BSTR *Comment);

    [id(14), helpstring("method ObjectCanImportStirling")]
    HRESULT ObjectCanImportStirling([in]          IUnknown     *pDocument,
                                    [in]          BOOL          fModifyXmlToDisconnectStirling,
                                    [out, retval] VARIANT_BOOL *vbCanImportStirling);

    [id(15), helpstring("Retrieves binding information for central storage server")]
    HRESULT GetCentralStorageBindInfo([out, defaultvalue(NULL)] BSTR *pServerName,
                               [out, defaultvalue(NULL)] BSTR *pServerAddress,
                               [out, defaultvalue(NULL)] BSTR *pUserName,
                               [out, defaultvalue(NULL)] BSTR *pUserDomain,
                               [out, defaultvalue(NULL)] BSTR *pPassword);

    [id(16), helpstring("Retrieves binding information for the parent FW server (must be called from within Server object or its child)")]
    HRESULT GetBindInfoForFW([out, defaultvalue(NULL)] BSTR *pServerName,
                             [out, defaultvalue(NULL)] BSTR *pServerAddress,
                             [out, defaultvalue(NULL)] BSTR *pUserName,
                             [out, defaultvalue(NULL)] BSTR *pUserDomain,
                             [out, defaultvalue(NULL)] BSTR *pPassword);

    [propget, id(17), helpstring("Retrieves parent object")]
    HRESULT ParentObject([out, retval] IFPCItemInternal** pParentObj);

    [propget, id(18), helpstring("Retrieves root FPC object")]
    HRESULT ParentFPC([out, retval] IFPC** pFpc);

    [propget, id(19), helpstring("Retrieves array in which the object resides (returns FILE_NOT_FOUND if the scope is not appropriate)")]
    HRESULT ParentArray([out, retval] IFPCArray** pArray);

    [propget, id(20), helpstring("Retrieves array in which the object resides (returns FILE_NOT_FOUND if the scope is not appropriate)")]
    HRESULT ParentEnterprisePolicy([out, retval] IFPCEEPolicy** pEnterprisePolicy);

    [id(21), helpstring("Gets a UI display info for an object")]
    HRESULT ObjectGetUIDisplayInfo([out] BSTR *pDisplayName,
                                   [out, defaultvalue(NULL)] BSTR *pDisplayClass,
                                   [out, defaultvalue(NULL)] BSTR *pScopeName,
                                   [out, defaultvalue(NULL)] BSTR *pParentArray,
                                   [out, defaultvalue(NULL)] BSTR *pParentPolicy,
                                   [out, defaultvalue(NULL)] BOOL* pfMemberOfCollection);

    [propget, id(22), helpstring("Checks whether this object is writable")]
    HRESULT ObjectIsWritable(
             [in] FpcOperationToCheckPermission eOpType,
             [out] VARIANT_BOOL* pVal,
             [out, defaultvalue(NULL)] VARIANT_BOOL* pfAccessDeniedDueToCSSVer);

    [id(23), helpstring("Checks whether the specified child object is readable/writable")]
    HRESULT CheckAccessChild([in, string] LPCWSTR                       pszChildName,
                             [in, string] LPCWSTR                       pszChildClassType,
                             [in]         ACCESS_MASK                   DesiredAccess,
                             [in]         FpcOperationToCheckPermission eOpToCheckPermission,
                             [out]        VARIANT_BOOL                  *pResult);

    [propget, id(24), helpstring("Retrieves object's class id")]
    HRESULT ClassID([out, retval] CLSID* pClsid);

    [id(25), helpstring("Get enumerator vlues that we want to expose through the idl")]
    HRESULT Enums([in] FpcExportImportOptionalData eExpImpOpt,
                  [in] FpcProtocolCategory eProtCat,
                  [in] FpcCopyElementsType,
                  [in] FpcKeySizeType);

    [propget, id(26), helpstring("Retrieves server in which the object resides (returns FILE_NOT_FOUND if the scope is not appropriate)")]
    HRESULT ParentServer([out, retval] IFPCEEServer** pServer);

    [propget, id(27), helpstring("Retrieves the flag that enables/disables adding Object Context to error descriptions")]
    HRESULT EnableObjectContextInErrorDesc([out, retval] VARIANT_BOOL* pEnable);

    [propput, id(27), helpstring("Set the flag that enables/disables adding Object Context to error descriptions")]
    HRESULT EnableObjectContextInErrorDesc([in] VARIANT_BOOL Enable);

    [id(28), helpstring("method TraverseSave")]
    HRESULT TraverseSave([in, defaultvalue(objSaving)] ComObjStatus newStatus);

    [id(29), helpstring("Get the object's number of children")]
    HRESULT GetChildrenCount([out, retval] long *pVal);
        
    [id(30), helpstring("Get the object's children names")]
    HRESULT GetChildrenNames([out, retval] SAFEARRAY(BSTR)* pChildrenNames);
    
    [id(31), helpstring("Get the object's child with the given name")]
    HRESULT GetChildByName([in] BSTR bstrName, [out, retval] IFPCItemInternal** ppChild);    
    
    [id(32), helpstring("Get the object's child with the given guid")]
    HRESULT GetChildByGuid([in] BSTR bstrGuid, [out, retval] IFPCItemInternal** ppChild);
    
    [id(33), helpstring("Get the object's properties values")]
    HRESULT GetProperties([out, retval] SAFEARRAY(VARIANT)* pProperties);
    
    [id(34), helpstring("Get the object's properties names")]
    HRESULT GetPropertiesNames([out, retval] SAFEARRAY(BSTR)* pPropertiesNames);
    
    [id(35), helpstring("Get the object's child in the given index")]
    HRESULT GetChild(long index, [out, retval] IFPCItemInternal **pChild);
    
    [propget, id(DISPID_NEWENUM), helpstring("Gets an enumerator object")]
    HRESULT _NewEnum([out, retval] IUnknown **pVal);
    
    [propget, id(36), helpstring("Get the object's VBName")]
    HRESULT ObjectVBName([out, retval] BSTR *bstrVBName);
};

[
    hidden,
    object,
    uuid(51E6AE7B-FE9B-400d-A1D4-5C466F853BD1),
    helpstring("IFPCRefInternal Interface"),
    pointer_default(unique),
    oleautomation
]
interface IFPCRefInternal : IUnknown
{
    [propget, id(1), helpstring("property Item Guid")]
    HRESULT Guid([out, retval] BSTR *bstrGUID);

    [id(2), helpstring("Resolves the FPCRef into an object")]
    HRESULT ResolveItem([out] IFPCItemInternal** pInternal);

    [propget, id(3), helpstring("Retrieve vendor parameters sets in which the extension can store data")]
    HRESULT VendorParametersSets([out, retval] IFPCVendorParametersSets** ppVps);
};


[
object,
uuid(87F88570-ACC7-4A96-9F95-B95407E33AFB),
dual,
nonextensible,
pointer_default(unique),
hidden
]
interface IFPCProtocolDefinitionsInternal : IUnknown
{
    HRESULT GetStandardProtocols(
        [in]  IFPCProtocolDefinition* ProtocolFilter,
        [out] VARIANT* pvStandardProtocolNames,
        [out] VARIANT* pvStandardProtocolGuids,
        [out] VARIANT* pvStandardProtocolScopes);
};

[
object,
uuid(59F09ABA-4B4B-4731-AB46-B775A6F62030),
dual,
nonextensible,
helpstring("Deprecated in Forefront TMG"),
pointer_default(unique)
]
interface IFPCIPSConfiguration : IUnknown
{
    [propget, id(2), helpstring("Deprecated in Forefront TMG")]
    HRESULT IPSInspectionEnabled([out, retval] VARIANT_BOOL* pVal);
    [propput, id(2), helpstring("Deprecated in Forefront TMG")]
    HRESULT IPSInspectionEnabled([in] VARIANT_BOOL newVal);

    [propget, id(4), helpstring("Deprecated in Forefront TMG")]
    HRESULT ExcludedIPs([out, retval] IFPCSelectionIPs **pVal);

    [propget, id(5), helpstring("Deprecated in Forefront TMG")]
    HRESULT ExcludedHttpDomainNameSets([out, retval] IFPCRefs **pVal);
};


[
object,
uuid(758E722F-631E-49db-9345-BFFCED46AC1B),
dual,
nonextensible,
helpstring("An update schedule. Deprecated in Forefront TMG."),
pointer_default(unique)
]
interface IFPCUpdateSchedule : IFPCPersist
{
    [propget, id(1), helpstring("Gets or sets a value from the FpcScheduleType enumerated type that specifies the type of the schedule")]
    HRESULT ScheduleType([out, retval] FpcScheduleType *pVal);
    [propput, id(1), helpstring("Gets or sets a value from the FpcScheduleType enumerated type that specifies the type of the schedule")]
    HRESULT ScheduleType([in] FpcScheduleType fpcScheduleType);

    [propget, id(2), helpstring("Gets or sets a value from the FpcDayOfWeek enumerated type that specifies every day or one day of the week for obtaining updates in a daily or weekly update schedule")]
    HRESULT DayOfWeek([out, retval] FpcDayOfWeek *pVal);
    [propput, id(2), helpstring("Gets or sets a value from the FpcDayOfWeek enumerated type that specifies every day or one day of the week for obtaining updates in a daily or weekly update schedule")]
    HRESULT DayOfWeek([in] FpcDayOfWeek pVal);

    [propget, id(3), helpstring("Gets or sets a FpcScheduleHours value that specifies the time of day for obtaining updates in a daily or weekly update schedule")]
    HRESULT HourOfDay([out, retval] FpcScheduleHours *pVal);
    [propput, id(3), helpstring("Gets or sets a FpcScheduleHours value that specifies the time of day for obtaining updates in a daily or weekly update schedule")]
    HRESULT HourOfDay([in] FpcScheduleHours fpcScheduleHours);
};


[
object,
uuid(E39966EC-A85A-4b09-B3EA-25BA8DECED7E),
dual,
nonextensible,
helpstring("Software Updates Settings. Deprecated in Forefront TMG."),
pointer_default(unique)
]
interface IFPCSoftwareUpdatesSettings : IFPCPersist
{
    [propget, id(1), helpstring("Gets or sets a value from the FpcUpdateAction enumerated type that specifies the actions that will be performed when Forefront TMG checks for updates")]
    HRESULT UpdateAction([out, retval] FpcUpdateAction *pVal);
    [propput, id(1), helpstring("Gets or sets a value from the FpcUpdateAction enumerated type that specifies the actions that will be performed when Forefront TMG checks for updates")]
    HRESULT UpdateAction([in] FpcUpdateAction fpcUpdateAction);

    [propget, id(2), helpstring("Gets or sets a Boolean value that indicates whether only the minimal updates for patching hardened systems will be downloaded")]
    HRESULT DownloadMinimalUpdates([out, retval] VARIANT_BOOL *pVal);
    [propput, id(2), helpstring("Gets or sets a Boolean value that indicates whether only the minimal updates for patching hardened systems will be downloaded")]
    HRESULT DownloadMinimalUpdates([in] VARIANT_BOOL fVal);
};

//
[
uuid(410EBD0E-504D-4552-A22E-A751D748A680),
helpfile("isasdk.chm"),
helpcontext(_isa_objects),
version(1.0),
helpstring("Microsoft Forefront Threat Management Gateway Administration Library")
]
library FPCLib
{
    importlib("stdole32.tlb");
    importlib("stdole2.tlb");
    [
    uuid(D5DF7881-38EF-48D8-94F8-74B8994ECCC2),
//***    helpcontext(_isa_fpcpersistsink_object),
    helpstring("IFPCPersistSink sink interface")
    ]
    dispinterface IFPCPersistSink
    {
        properties:

        methods:
        [id(1), helpstring("Method for handling progress events")]
        HRESULT Progress([in] long Percentage);

    };

	[
    uuid(3C9D5976-BF6A-4C08-9F30-89BAE7FB10AB),
    helpcontext(_isa_fpcsnapinnode_object),
    helpstring("FPCSnapinNode Class"),
    noncreatable
    ]
    coclass FPCSnapinNode
    {
        [default]         interface IFPCSnapinNode;
    };
    
	[
    uuid(7157D173-808C-44FF-BA13-76E19CF68897),
    //***    helpcontext(_isa_FPCPersist_object),
    helpstring("FPCPersist Class"),
    noncreatable,
    hidden
    ]
    coclass FPCPersist
    {
        [default]         interface IFPCPersist;
        [default, source] dispinterface IFPCPersistSink;
    };

	[
	helpcontext(_isa_fpc_object),
	uuid(6EB6B56F-AC96-4B2F-9DD6-678ECAD5789D),
	helpstring("FPC Class")
	]
	coclass FPC
	{
        [default]         interface IFPC;
                          interface IFPCEE;
                          interface IFPC2;
                          interface IFPC3;
                          interface IFPCDistributionStatusInternal;
                          interface IFPCUtilityFunctionsInternal;
	};

	[
	uuid(90027a81-f48b-4ed4-b19e-f99c5c37671c),
	helpstring("FPCEnterprise Class")
	]
	coclass FPCEnterprise
	{
        [default]         interface IFPCEEEnterprise;
                          interface IFPCEnterprise2;
                          interface IFPCEnterprise3;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	uuid(74f5ca1b-9a68-4422-a8ad-6e1254aeea12),
	helpstring("FPCPolicies Class")
	]
	coclass FPCPolicies
	{
        [default]         interface IFPCEEPolicies;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	uuid(9d8fddc3-548d-40a7-a6ee-02385f88b2fb),
	helpstring("FPCPolicy Class")
	]
	coclass FPCPolicy
	{
        [default]         interface IFPCEEPolicy;
                          interface IFPCPolicy2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(AEB749B6-0EF9-42DE-B43F-CF75D1F7CB0A),
	helpstring("FPCConnectionLimit Class")
	]
	coclass FPCConnectionLimit
	{
        [default]         interface IFPCConnectionLimit;
                          interface IFPCConnectionLimit2;
                          interface IFPCConnectionLimit3;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(5F4135F4-EFE4-4D93-A2A6-2916C529C54D),
	helpstring("FPConnectionLimitPolicy Class")
	]
	coclass FPCConnectionLimitPolicy
	{
        [default]         interface IFPCConnectionLimitPolicy;
                          interface IFPCConnectionLimitPolicy2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcarray_object), noncreatable,
	uuid(E603489F-FA78-41CA-ADFE-EDC572C944DE),
	helpstring("FPCArray Class")
	]
	coclass FPCArray
	{
        [default]         interface IFPCArray;
                          interface IFPCEEArray;
                          interface IFPCArray2;
                          interface IFPCArray3;
                          interface IFPCArray4;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcarrays_collection), noncreatable,
	uuid(7C3452E1-243B-4F01-B5A8-876D387B0BAC),
	helpstring("FPCArrays Class")
	]
	coclass FPCArrays
	{
        [default]         interface IFPCArrays;
                          interface IFPCEEArrays;
                          interface IFPCArrays2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	hidden, noncreatable,
	uuid(f39fb115-3f0e-4937-a9be-5331052bf754),
	helpstring("FPCCrossArraySettings Class")
	]
	coclass FPCCrossArraySettings
	{
        [default]         interface IFPCCrossArraySettings;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	hidden, noncreatable,
	uuid(02457d6d-4d09-48d0-a7db-d16922c13513),
	helpstring("FPCCrossArray Class")
	]
	coclass FPCCrossArray
	{
        [default]         interface IFPCCrossArray;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	hidden, noncreatable,
	uuid(6d4754a6-480b-4194-8f0e-c8663f0dec73),
	helpstring("FPCCrossArrayImplicitMappings Class")
	]
	coclass FPCCrossArrayImplicitMappings
	{
        [default]         interface IFPCCrossArrayImplicitMappings;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	hidden, noncreatable,
	uuid(425e2655-2fa8-4b9e-bc1b-9b55bf46db81),
	helpstring("FPCCrossArrayImplicitMapping Class")
	]
	coclass FPCCrossArrayImplicitMapping
	{
        [default]         interface IFPCCrossArrayImplicitMapping;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(8df1ac58-647d-44b9-bdf5-20bc2d7a67ea),
	helpstring("FPCPolicyAssignment Class")
	]
	coclass FPCPolicyAssignment
	{
        [default]         interface IFPCEEPolicyAssignment;
                          interface IFPCPolicyAssignment2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(f0671e1b-5c03-49c7-959a-f040c603638d),
	helpstring("FPCEEConfigurationStorageServerConnection Class")
	]
	coclass FPCConfigurationStorageServerConnection
	{
        [default]         interface IFPCEEConfigurationStorageServerConnection;
                          interface IFPCConfigurationStorageServerConnection2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpccache_object), noncreatable,
	uuid(990F5649-A48D-44A4-9FA6-EB5C2ADCE99C),
	helpstring("FPCCache Class")
	]
	coclass FPCCache
	{
        [default]         interface IFPCCache;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcextensions_object), noncreatable,
	uuid(D16D931D-21F8-47BF-8132-5BC454BFBB21),
	helpstring("FPCExtensions Class")
	]
	coclass FPCExtensions
	{
        [default]         interface IFPCExtensions;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(A6B83673-4A78-4C81-B2F3-16699D49CE0A),
	helpstring("FPCRuleElements Class")
	]
	coclass FPCRuleElements
	{
        [default]         interface IFPCRuleElements;
                          interface IFPCRuleElements2;
                          interface IFPCRuleElements3;
                          interface IFPCRuleElements4;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcnetworkconfiguration_object), noncreatable,
	uuid(B51A18BA-845F-4C90-A9A3-D79722629ABD),
	helpstring("FPCNetworkConfiguration Class")
	]
	coclass FPCNetworkConfiguration
	{
        [default]         interface IFPCNetworkConfiguration;
                          interface IFPCEENetworkConfiguration;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcservers_collection), noncreatable,
	uuid(40CBE837-BB8F-4363-A830-B39EF230A2B3),
	helpstring("FPCServers Class")
	]
	coclass FPCServers
	{
        [default]         interface IFPCServers;
                          interface IFPCEEServers;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpccertificates_collection), noncreatable,
	uuid(C14924B9-864E-45BC-A088-2FD691A85CE4),
	helpstring("Certificates Class")
	]
	coclass FPCCertificates
	{
        [default]         interface IFPCCertificates;
                          interface IFPCCertificates2;
	};

	[
	helpcontext(_isa_fpccertificate_object), noncreatable,
	uuid(DCD53727-E38B-4B4E-A8D0-9F9BEB7B8289),
	helpstring("FPCCertificate Class")
	]
	coclass FPCCertificate
	{
        [default]         interface IFPCCertificate;
                          interface IFPCCertificate2;
                          interface IFPCCertificate3;
	};

	[
	helpcontext(_isa_fpcserver_object), noncreatable,
	uuid(4D3A4401-8CB6-47D7-85DC-AC12C804D604),
	helpstring("FPCServer Class")
	]
	coclass FPCServer
	{
        [default]         interface IFPCServer;
                          interface IFPCEEServer;
                          interface IFPCServer2;
                          interface IFPCServer3;
                          interface IFPCServer4;
                          interface IFPCServiceResponsivenessInternal;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcexternalcomponents_collection), noncreatable,
	uuid(D3371365-8BDF-4ae9-8C28-04A4859768A3),
	helpstring("Collection of external components")
	]
	coclass FPCExternalComponents
	{
        [default]         interface IFPCExternalComponents;
	};

	[
	helpcontext(_isa_fpcexternalcomponent_object),noncreatable,
	uuid(A20DFB83-7D35-4abd-84F4-83025F71C7BD),
	helpstring("External component object")
	]
	coclass FPCExternalComponent
	{
        [default]         interface IFPCExternalComponent;
	};

	[
	helpcontext(_isa_fpcdistributionstatus_object), noncreatable,
	uuid(47F46C20-3B10-4edc-8A1A-9E3E5AC0EE3C),
	helpstring("FPCEEDistributionStatus Class")
	]
	coclass FPCEEDistributionStatus
	{
        [default]         interface IFPCEEDistributionStatus;
                          interface IFPCDistributionStatus2;
	};

	[
	helpcontext(_isa_fpcschedule_object), noncreatable,
	uuid(D002251D-6F36-41C5-8326-1A698A81DF3B),
	helpstring("FPCSchedule Class")
	]
	coclass FPCSchedule
	{
        [default]         interface IFPCSchedule;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcschedules_collection), noncreatable,
	uuid(D0560C66-3C69-4329-AAC5-221217E29168),
	helpstring("FPCSchedules Class")
	]
	coclass FPCSchedules
	{
        [default]         interface IFPCSchedules;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcalert_object), noncreatable,
	uuid(CE2F235F-C645-4F46-BC97-3D0620010F10),
	helpstring("FPCAlert Class")
	]
	coclass FPCAlert
	{
        [default]         interface IFPCAlert;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcalerts_collection), noncreatable,
	uuid(AAA36863-331B-4CA5-95EA-9A039BF8C26F),
	helpstring("FPCAlerts Class")
	]
	coclass FPCAlerts
	{
        [default]         interface IFPCAlerts;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcalertaction_object), noncreatable,
	uuid(CCD7C6BC-47AE-4E10-84CE-1D6826001F24),
	helpstring("FPCAlertAction Class")
	]
	coclass FPCAlertAction
	{
        [default]         interface IFPCAlertAction;
	};

	[
	helpcontext(_isa_fpcalertactions_collection), noncreatable,
	uuid(9BFCD0A1-C906-41DA-8B23-4625A23675C1),
	helpstring("FPCAlertActions Class")
	]
	coclass FPCAlertActions
	{
        [default]         interface IFPCAlertActions;
	};

	[
	helpcontext(_isa_fpceventdefinition_object), noncreatable,
	uuid(BE0B1C8F-2F70-439F-8015-DCFAE12EB4BF),
	helpstring("FPCEventDefinition Class")
	]
	coclass FPCEventDefinition
	{
        [default]         interface IFPCEventDefinition;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpceventdefinitions_collection), noncreatable,
	uuid(1C3F70B0-5FAD-45C4-A465-6E16E2BBDCAC),
	helpstring("FPCEventDefinitions Class")
	]
	coclass FPCEventDefinitions
	{
        [default]         interface IFPCEventDefinitions;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcvendorparameterssets_collection), noncreatable,
	uuid(FA191CA8-841D-4BF0-99B1-EB846E734CDA),
	helpstring("FPCVendorParametersSets Class")
	]
	coclass FPCVendorParametersSets
	{
        [default]         interface IFPCVendorParametersSets;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcvendorparametersset_object), noncreatable,
	uuid(6B1581D1-3CE8-47E1-A0FB-BE042057D518),
	helpstring("FPCVendorParametersSet Class")
	]
	coclass FPCVendorParametersSet
	{
        [default]         interface IFPCVendorParametersSet;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(550aba47-635e-4fa9-80d0-2b5b0c827899),
	helpstring("FPCLdapMatchingPattern Class")
	]
	coclass FPCLdapMatchingPattern
	{
        [default]         interface IFPCLdapMatchingPattern;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(753d437e-04d5-4768-90c2-381d804442b3),
	helpstring("FPCLdapMatchingPatterns Class")
	]
	coclass FPCLdapMatchingPatterns
	{
        [default]         interface IFPCLdapMatchingPatterns;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(1fc66874-73e9-4d15-8671-b4b8bda0da5b),
	helpstring("FPCLdapServer Class")
	]
	coclass FPCLdapServer
	{
        [default]         interface IFPCLdapServer;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(f585e90d-4e78-485d-b398-c717f1be5a5e),
	helpstring("FPCLdapServersSet Class")
	]
	coclass FPCLdapServersSet
	{
        [default]         interface IFPCLdapServersSet;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(8609ad06-b8af-4447-9172-1c8ea7db5fb6),
	helpstring("FPCLdapServersSets Class")
	]
	coclass FPCLdapServersSets
	{
        [default]         interface IFPCLdapServersSets;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(E876378C-96AC-4155-B894-406BC48445BF),
	helpstring("FPCRadiusServers Class")
	]
	coclass FPCRadiusServers
	{
        [default]         interface IFPCRadiusServers;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(12BF2983-9147-4126-9868-CB04CAB0747C),
	helpstring("FPCRadiusServer Class")
	]
	coclass FPCRadiusServer
	{
        [default]         interface IFPCRadiusServer;
                          interface IFPCRadiusServer2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(F217FB54-9C5B-47CD-A806-6BD5E6E73859),
	helpstring("FPCUserSets Class")
	]
	coclass FPCUserSets
	{
        [default]         interface IFPCUserSets;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(93280553-2C16-4535-A114-7CE68B65B3A5),
	helpstring("FPCUserSet Class")
	]
	coclass FPCUserSet
	{
        [default]         interface IFPCUserSet;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcaccounts_collection), noncreatable,
	uuid(0DE9536B-18F6-453D-8053-9E22E27E4082),
	helpstring("FPCAccounts Class")
	]
	coclass FPCAccounts
	{
        [default]         interface IFPCAccounts;
	};

	[
	noncreatable,
	uuid(2A323787-487C-471D-85C3-CEE9F001E4CD),
	helpstring("FPCNonWindowsUsers Class")
	]
	coclass FPCNonWindowsUsers
	{
        [default]         interface IFPCNonWindowsUsers;
                          interface IFPCNonWindowsUsers2;
	};

	[
	helpcontext(_isa_fpcaccount_object), noncreatable,
	uuid(B14118D3-AEEE-4250-80CC-BE07D46A31AE),
	helpstring("FPCAccount Class")
	]
	coclass FPCAccount
	{
        [default]         interface IFPCAccount;
	};

	[
	noncreatable,
	uuid(8EBF59B0-10FF-4BB9-9A42-B3FDCEE460A1),
	helpstring("FPCNonWindowsUser Class")
	]
	coclass FPCNonWindowsUser
	{
        [default]         interface IFPCNonWindowsUser;
                          interface IFPCNonWindowsUser2;
	};

	[
	helpcontext(_isa_fpccredentials_object), noncreatable,
	uuid(FA4BB7AF-2B1D-4E0F-8E42-09D81BDAFD34),
	helpstring("FPCCredentials Class")
	]
	coclass FPCCredentials
	{
        [default]         interface IFPCCredentials;
                          interface IFPCCredentialsInternal;
	};

	[
	helpcontext(_isa_fpclogs_collection), noncreatable,
	uuid(5C8BEE56-2379-4C57-AF5F-F6F1C521EFC9),
	helpstring("FPCLogs Class")
	]
	coclass FPCLogs
	{
        [default]         interface IFPCLogs;
                          interface IFPCLogs2;
                          interface IFPCLogs3;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpclog_object), noncreatable,
	uuid(D185646D-0ED8-47DB-8C1C-3019980CD06C),
	helpstring("FPCLog Class")
	]
	coclass FPCLog
	{
        [default]         interface IFPCLog;
                          interface IFPCEELog;
                          interface IFPCLog2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcsessionsmonitorentry_object), noncreatable,
	uuid(0f3eb37b-3df4-4286-8a36-faad4375c79a),
	helpstring("FPCSessionsMonitorEntry Class")
	]
	coclass FPCSessionsMonitorEntry
	{
        [default]         interface IFPCSessionsMonitorEntry;
	};

	[
	helpcontext(_isa_fpcsessionsmonitor_object), noncreatable,
	uuid(d8009793-3aab-4b67-94ce-f626959f8482),
	helpstring("FPCSessionsMonitor Class")
	]
	coclass FPCSessionsMonitor
	{
        [default]         interface IFPCSessionsMonitor;
	};

	[
	helpcontext(_isa_fpcsessionsmonitors_object), noncreatable,
	uuid(6e57c951-2fdf-4a54-b30e-aa3be0de8e23),
	helpstring("FPCSessionsMonitors Class")
	]
	coclass FPCSessionsMonitors
	{
        [default]         interface IFPCSessionsMonitors;
	};

	[
	helpcontext(_isa_fpclogviewer_object), noncreatable,
	uuid(1A914563-574F-4C24-9062-5610D41B89C6),
	helpstring("FPCLogViewer Class")
	]
	coclass FPCLogViewer
	{
        [default]         interface IFPCLogViewer;
                          interface IFPCLogViewer2;
	};

	[
	helpcontext(_isa_fpclogcontent_collection), noncreatable,
	uuid(069A2149-D8C4-43DE-95AA-BAD938462BA1),
	helpstring("FPCLogContent Class")
	]
	coclass FPCLogContent
	{
        [default]         interface IFPCLogContent;
                          interface IFPCEELogContent;
	};

	[
	helpcontext(_isa_fpcarraypolicy_object), noncreatable,
	uuid(051FAD20-ABD9-4C90-923D-6C859DA6EF6E),
	helpstring("FPCArrayPolicy Class")
	]
	coclass FPCArrayPolicy
	{
        [default]         interface IFPCArrayPolicy;
                          interface IFPCArrayPolicy2;
                          interface IFPCArrayPolicy3;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcnetworkinspectionsystem_object), noncreatable,
	uuid(98C69B57-A116-4442-B6EB-395A888FB261),
	helpstring("FPCNetworkInspectionSystem Class")
	]
	coclass FPCNetworkInspectionSystem
	{
        [default]         interface IFPCNetworkInspectionSystem;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcnissignatureconfigurations_object), noncreatable,
	uuid(14F32DE1-CBA2-4FE3-B520-B38F68946B2D),
	helpstring("FPCNisSignatureConfigurations Class")
	]
	coclass FPCNisSignatureConfigurations
	{
        [default]         interface IFPCNisSignatureConfigurations;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcnissignatureconfiguration_object), noncreatable,
	uuid(3BB328DB-71A3-43A2-BC48-0CC4D922B9CA),
	helpstring("FPCNisSignatureConfiguration Class")
	]
	coclass FPCNisSignatureConfiguration
	{
        [default]         interface IFPCNisSignatureConfiguration;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcnissignatureset_object), noncreatable,
	uuid(4de829c8-9790-4cfe-9b04-4ea9fa5adfb5),
	helpstring("FPCNisSignatureSet Class")
	]
	coclass FPCNisSignatureSet
	{
        [default]         interface IFPCNisSignatureSet;
	};

	[
	helpcontext(_isa_fpcnissignatures_object), noncreatable,
	uuid(9fa4bd61-7655-4858-9072-343788010d6f),
	helpstring("FPCNisSignatures Class")
	]
	coclass FPCNisSignatures
	{
        [default]         interface IFPCNisSignatures;
	};

	[
	helpcontext(_isa_fpcnisssignature_object), noncreatable,
	uuid(d945ef38-5fc5-4f0c-8bd2-02b8b9cabf83),
	helpstring("FPCNisSignature Class")
	]
	coclass FPCNisSignature
	{
        [default]         interface IFPCNisSignature;
	};

	[
	helpcontext(_isa_fpcnisavailablesignaturesets_object), noncreatable,
	uuid(17314a1a-467f-41bd-af19-72e6e1388591),
	helpstring("FPCNisAvailableSignatureSets Class")
	]
	coclass FPCNisAvailableSignatureSets
	{
        [default]         interface IFPCNisAvailableSignatureSets;
	};

	[
	helpcontext(_isa_fpcnisavailablesignatureset_object), noncreatable,
	uuid(704bf6fe-9155-4e35-8fe4-4ce9d9de036f),
	helpstring("FPCIPSSignature Class")
	]
	coclass FPCNisAvailableSignatureSet
	{
        [default]         interface IFPCNisAvailableSignatureSet;
	};

	[
	noncreatable,
	uuid(6F22085B-8A51-48EB-B99E-6A1E8B06637C),
	helpstring("FPCSystemPolicy Class")
	]
	coclass FPCSystemPolicy
	{
        [default]         interface IFPCSystemPolicy;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(80E26D89-8185-461A-B236-ED194A117504),
	helpstring("FPCSystemPolicyConfigGroup Class")
	]
	coclass FPCSystemPolicyConfigGroup
	{
        [default]         interface IFPCSystemPolicyConfigGroup;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(4BB162F9-8D9C-4a65-8D61-21034188FC41),
	helpstring("CFPCUserAgentMapping Class")
	]
	coclass FPCUserAgentMapping
	{
        [default]         interface IFPCUserAgentMapping;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(0F26F4E4-F1D6-4ffe-A475-0E332187296A),
	helpstring("CFPCUserAgentMappings Class")
	]
	coclass FPCUserAgentMappings
	{
        [default]         interface IFPCUserAgentMappings;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpccacheconfiguration_object), noncreatable,
	uuid(F9BE106D-E4AE-4720-BD86-B9CC204E1B53),
	helpstring("FPCCacheConfiguration Class")
	]
	coclass FPCCacheConfiguration
	{
        [default]         interface IFPCCacheConfiguration;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpccacherules_object), noncreatable,
	uuid(09DC9B21-9F11-4FDD-B25F-0EA47D7AAFB1),
	helpstring("FPCCacheRules Class")
	]
	coclass FPCCacheRules
	{
        [default]         interface IFPCCacheRules;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpccacherule_object), noncreatable,
	uuid(A5727853-F528-4A05-80E1-48E7E340FA0A),
	helpstring("FPCCacheRule Class")
	]
	coclass FPCCacheRule
	{
        [default]         interface IFPCCacheRule;
                          interface IFPCCacheRule2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpchttpcacheconfiguration_object), noncreatable,
	uuid(EC5F0818-BD31-4DC5-9AA9-8759DDC9F99E),
	helpstring("FPCHTTPCacheConfiguration Class")
	]
	coclass FPCHTTPCacheConfiguration
	{
        [default]         interface IFPCHTTPCacheConfiguration;
	};

	[
	helpcontext(_isa_fpcftpcacheconfiguration_object), noncreatable,
	uuid(7AF32EF4-7DFE-40F1-8B58-40F582DB3B48),
	helpstring("FPCFTPCacheConfiguration Class")
	]
	coclass FPCFTPCacheConfiguration
	{
        [default]         interface IFPCFTPCacheConfiguration;
	};

	[
	helpcontext(_isa_fpcactivecacheconfiguration_object), noncreatable,
	uuid(8353B8DE-5846-4A63-8E1A-E7A13CC57BFE),
	helpstring("FPCActiveCacheConfiguration Class")
	]
	coclass FPCActiveCacheConfiguration
	{
        [default]         interface IFPCActiveCacheConfiguration;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcprotocoldefinition_object), noncreatable,
	uuid(CF28E928-B21A-4452-8918-D4102209CC1C),
	helpstring("FPCProtocolDefinition Class")
	]
	coclass FPCProtocolDefinition
	{
        [default]         interface IFPCProtocolDefinition;
                          interface IFPCProtocolDefinition2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(E97F2C3C-4697-4E60-80E0-E498FE963981),
	helpstring("FPCProtocolConnection Class")
	]
	coclass FPCProtocolConnection
	{
        [default]         interface IFPCProtocolConnection;
                          interface IFPCProtocolConnection2;
	};

	[
	noncreatable,
	uuid(BD553C4C-53C8-42D4-B29D-2D482176A00C),
	helpstring("FPCIpOptions Class")
	]
	coclass FPCIpOptions
	{
        [default]         interface IFPCIpOptions;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcprotocolconnections_collection), noncreatable,
	uuid(7099ABF8-9C2B-46C4-8D5B-45F09D5A7E86),
	helpstring("FPCProtocolConnections Class")
	]
	coclass FPCProtocolConnections
	{
        [default]         interface IFPCProtocolConnections;
                          interface IFPCProtocolConnections2;
	};

	[
	helpcontext(_isa_fpcprotocoldefinitions_collection), noncreatable,
	uuid(9C406870-6B99-4DCE-88DA-6717EA16BBC4),
	helpstring("FPCProtocolDefinitions class")
	]
	coclass FPCProtocolDefinitions
	{
        [default]         interface IFPCProtocolDefinitions;
                          interface IFPCProtocolDefinitionsInternal;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcadapters_collection), noncreatable,
	uuid(5AC97CA1-E135-426A-97E1-BA6C7F415BAA),
	helpstring("FPCAdapters Class")
	]
	coclass FPCAdapters
	{
        [default]         interface IFPCAdapters;
	};

	[
	helpcontext(_isa_fpcadapters_collection), noncreatable,
	uuid(4061606C-1DE1-469C-A1E8-FD7871FA7B4E),
	helpstring("FPCAllAdapters Class")
	]
	coclass FPCAllAdapters
	{
        [default]         interface IFPCAllAdapters;
                          interface IFPCAllAdapters2;
	};

	[
	helpcontext(_isa_fpcadapter_object), noncreatable,
	uuid(5353FE91-EBB0-4390-9765-50D0949B1BA2),
	helpstring("FPCAdapter Class")
	]
	coclass FPCAdapter
	{
        [default]         interface IFPCAdapter;
                          interface IFPCAdapter2;
	};

	[
	helpcontext(_isa_fpcrefs_collection), noncreatable,
	uuid(146833C1-B6B8-461D-B0DB-076A8E755CF4),
	helpstring("FPCRefs Class")
	]
	coclass FPCRefs
	{
        [default]         interface IFPCRefs;
                          interface IFPCEERefs;
	};

	[
	helpcontext(_isa_fpcref_object), noncreatable,
	uuid(B06A9AE5-9E1C-4752-ACFD-BB2CCA9DCA0A),
	helpstring("FPCRef Class")
	]
	coclass FPCRef
	{
        [default]         interface IFPCRef;
                          interface IFPCEERef;
                          interface IFPCRefInternal;
	};

	[
	helpcontext(_isa_fpcapplicationfilter_object), noncreatable,
	uuid(7A598523-DD0B-4442-BC73-D36871F1E5B2),
	helpstring("FPCApplicationFilter Class")
	]
	coclass FPCApplicationFilter
	{
        [default]         interface IFPCApplicationFilter;
                          interface IFPCApplicationFilter2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcapplicationfilters_collection), noncreatable,
	uuid(804BAEAA-B2E2-452D-9D43-21EF2A61B89D),
	helpstring("FPApplicationCFilters Class")
	]
	coclass FPCApplicationFilters
	{
        [default]         interface IFPCApplicationFilters;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcroutingrules_collection), noncreatable,
	uuid(EAA101D0-3895-4700-9BD2-7677F0D262A9),
	helpstring("FPCRoutingRules Class")
	]
	coclass FPCRoutingRules
	{
        [default]         interface IFPCRoutingRules;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcroutingrule_object), noncreatable,
	uuid(4CEB97F6-D735-47FD-AF87-313A1936D324),
	helpstring("FPCRoutingRule Class")
	]
	coclass FPCRoutingRule
	{
        [default]         interface IFPCRoutingRule;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcprimaryroute_object), noncreatable,
	uuid(D2B6FF85-7D59-4F6E-861E-D4CDBCFC1E2F),
	helpstring("FPCPrimaryRoute Class")
	]
	coclass FPCPrimaryRoute
	{
        [default]         interface IFPCPrimaryRoute;
                          interface IFPCPrimaryRoute2;
	};

	[
	helpcontext(_isa_fpcbackuproute_object), noncreatable,
	uuid(B4EEFD64-37AB-453A-B487-E64341ECEA02),
	helpstring("FPCBackupRoute Class")
	]
	coclass FPCBackupRoute
	{
        [default]         interface IFPCBackupRoute;
                          interface IFPCBackupRoute2;
	};

	[
	helpcontext(_isa_fpcdialupnetworkconnections_collection), noncreatable,
	uuid(5E01C298-05E2-42F9-81AC-6ECA2F0EF97F),
	helpstring("FPCDialupNetworkConnections Class")
	]
	coclass FPCDialupNetworkConnections
	{
        [default]         interface IFPCDialupNetworkConnections;
	};

	[
	helpcontext(_isa_fpccachecontents_object), noncreatable,
	uuid(478F8A7D-7C3A-4B8A-8506-5B27E6A779DC),
	helpstring("FPCCacheContents Class")
	]
	coclass FPCCacheContents
	{
        [default]         interface IFPCCacheContents;
	};

	[
	helpcontext(_isa_fpcattackdetection_collection), noncreatable,
	uuid(48FDB993-E862-4D11-B033-84F2C44C9ED3),
	helpstring("FPCAttackDetection Class")
	]
	coclass FPCAttackDetection
	{
        [default]         interface IFPCAttackDetection;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpccachedrive_object), noncreatable,
	uuid(EFC42254-2157-4A5D-9F2C-858AAAF542C8),
	helpstring("FPCCacheDrive Class")
	]
	coclass FPCCacheDrive
	{
        [default]         interface IFPCCacheDrive;
	};

	[
	helpcontext(_isa_fpccachedrives_collection), noncreatable,
	uuid(94F7DE06-0228-4C41-82D2-500895107536),
	helpstring("FPCCacheDrives Class")
	]
	coclass FPCCacheDrives
	{
        [default]         interface IFPCCacheDrives;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcdiskdrive_object), noncreatable,
	uuid(A2DB3A9F-CC92-4C29-B0F3-604DF57849A1),
	helpstring("FPCDiskDrive Class")
	]
	coclass FPCDiskDrive
	{
        [default]         interface IFPCDiskDrive;
	};

	[
	helpcontext(_isa_fpcdiskdrives_collection), noncreatable,
	uuid(27325F92-E582-498E-B274-C7A7343E760F),
	helpstring("FPCDiskDrives Class")
	]
	coclass FPCDiskDrives
	{
        [default]         interface IFPCDiskDrives;
	};

	[
	helpcontext(_isa_fpcclientconfig_object), noncreatable,
	uuid(966228E8-4C6C-4291-9878-9862F0BE624D),
	helpstring("FPCClientConfig Class")
	]
	coclass FPCClientConfig
	{
        [default]         interface IFPCClientConfig;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcfirewallclientconfig_object), noncreatable,
	uuid(8BA7D18E-695D-4661-A146-B41E30C37E08),
	helpstring("FPCFirewallClientConfig Class")
	]
	coclass FPCFirewallClientConfig
	{
        [default]         interface IFPCFirewallClientConfig;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcwebbrowserclientconfig_object), noncreatable,
	uuid(2C34BE14-AE6D-4418-9F73-5BA8CF704F03),
	helpstring("FPCWebBrowserClientConfig Class")
	]
	coclass FPCWebBrowserClientConfig
	{
        [default]         interface IFPCWebBrowserClientConfig;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcclientautoscript_object), noncreatable,
	uuid(7BC4A457-03C0-41F2-A6AE-53C02DFE7B3C),
	helpstring("FPCClientAutoScript Class")
	]
	coclass FPCClientAutoScript
	{
        [default]         interface IFPCClientAutoScript;
                          interface IFPCClientAutoScript2;
                          interface IFPCClientAutoScript3;
	};

	[
	helpcontext(_isa_fpcclientbackuproute_object), noncreatable,
	uuid(47D3485C-2D40-40CD-A171-3579643ABD04),
	helpstring("FPCClientBackupRoute Class")
	]
	coclass FPCClientBackupRoute
	{
        [default]         interface IFPCClientBackupRoute;
	};

	[
	helpcontext(_isa_fpcldt_collection), noncreatable,
	uuid(0DB63E88-0763-428A-A046-5D345F36202C),
	helpstring("FPCLDT Class")
	]
	coclass FPCLDT
	{
        [default]         interface IFPCLDT;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcldtentry_object), noncreatable,
	uuid(EAF52A69-1A38-48EB-A001-3333FF7F3F04),
	helpstring("FPCLDTEntry Class")
	]
	coclass FPCLDTEntry
	{
        [default]         interface IFPCLDTEntry;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcscheduledcontentdownload_collection), noncreatable,
	uuid(012A4169-09C2-4990-BD71-71D7E8343342),
	helpstring("FPCScheduledContentDownload Class")
	]
	coclass FPCScheduledContentDownload
	{
        [default]         interface IFPCScheduledContentDownload;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcscheduledcontentdownloadconfig_object), noncreatable,
	uuid(F3FDE763-77D2-451F-8E8C-45406C165F9B),
	helpstring("FPCScheduledContentDownloadConfig Class")
	]
	coclass FPCScheduledContentDownloadConfig
	{
        [default]         interface IFPCScheduledContentDownloadConfig;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(279CE297-A8E2-4F70-B635-AF040B6695AC),
	helpstring("FPCPublicNames Class")
	]
	coclass FPCPublicNames
	{
        [default]         interface IFPCPublicNames;
	};

	[
	noncreatable,
	uuid(8FC600F2-DFF2-440B-8207-CB0C05F377B3),
	helpstring("FPCLinkTranslationPatterns Class")
	]
	coclass FPCLinkTranslationPatterns
	{
        [default]         interface IFPCLinkTranslationPatterns;
	};

	[
	noncreatable,
	uuid(B31EF9B1-FDBC-4908-B53A-6B3407C5E25B),
	helpstring("FPCLinkTranslationRedirection Class")
	]
	coclass FPCLinkTranslationRedirection
	{
        [default]         interface IFPCLinkTranslationRedirection;
	};

	[
	noncreatable,
	uuid(F7ABF58C-B2C7-4634-846E-8079C021962E),
	helpstring("FPCPathMappings Class")
	]
	coclass FPCPathMappings
	{
        [default]         interface IFPCPathMappings;
	};

	[
	noncreatable,
	uuid(A427A436-A44E-4088-BE8F-B02281FFA24B),
	helpstring("FPCPathMapping Class")
	]
	coclass FPCPathMapping
	{
        [default]         interface IFPCPathMapping;
	};

	[
	helpcontext(_isa_fpcfilterexpression_object), noncreatable,
	uuid(320B60E9-DC43-4CA1-85E5-BC6C8E7B1393),
	helpstring("FPCFilterExpression Class")
	]
	coclass FPCFilterExpression
	{
        [default]         interface IFPCFilterExpression;
	};

	[
	helpcontext(_isa_fpcfilterexpression_collection),
	uuid(0177876D-807B-4DB0-B2C9-9D8E2040D969),
	helpstring("FPCFilterExpressions Class")
	]
	coclass FPCFilterExpressions
	{
        [default]         interface IFPCFilterExpressions;
                          interface IFPCFilterExpressions2;
	};

	[
	noncreatable,
	uuid(26ab95d8-4d19-4ea0-b00f-3af1fd144f3e),
	helpstring("FPCUserAgents Class")
	]
	coclass FPCUserAgents
	{
        [default]         interface IFPCUserAgents;
	};

	[
	noncreatable,
	uuid(43b73564-fc53-496a-8918-59fb6f8d7926),
	helpstring("FPCHTTPHeaders Class")
	]
	coclass FPCHTTPHeaders
	{
        [default]         interface IFPCHTTPHeaders;
	};

	[
	helpcontext(_isa_fpcfirewallchaining_object), noncreatable,
	uuid(3A76817B-8600-4340-AE5A-5875CDE005DD),
	helpstring("FPCFirewallChaining Class")
	]
	coclass FPCFirewallChaining
	{
        [default]         interface IFPCFirewallChaining;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(272FDC11-820B-42D2-B7E0-8A3D84600732),
	helpstring("FPCDialingConfiguration Class")
	]
	coclass FPCDialingConfiguration
	{
        [default]         interface IFPCDialingConfiguration;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcwebproxy_object), noncreatable,
	uuid(3BD428B9-1128-435B-8489-49F3388B9069),
	helpstring("FPCWebProxy Class")
	]
	coclass FPCWebProxy
	{
        [default]         interface IFPCWebProxy;
                          interface IFPCEEWebProxy;
                          interface IFPCWebProxy2;
                          interface IFPCWebProxy3;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(afc8c604-8c50-4e59-ba32-49175ff62135),
	helpstring("FPCCookieCryptoConfiguration Class")
	]
	coclass FPCCookieCryptoConfiguration
	{
        [default]         interface IFPCCookieCryptoConfiguration;
	};

	[
	noncreatable,
	uuid(107B661A-B5A4-4F52-A222-CC3BB1491DB3),
	helpstring("Class FPCUserMapping")
	]
	coclass FPCUserMapping
	{
        [default]         interface IFPCUserMapping;
	};

	[
	noncreatable,
	uuid(AEEFB092-E8DF-41BA-A2C6-34EEB16A810C),
	helpstring("Class FPCAuthenticationScheme")
	]
	coclass FPCAuthenticationScheme
	{
        [default]         interface IFPCAuthenticationScheme;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(2301B6DF-117F-4B57-939F-2B4E6F5E4620),
	helpstring("Class FPCAuthenticationSchemes")
	]
	coclass FPCAuthenticationSchemes
	{
        [default]         interface IFPCAuthenticationSchemes;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcwebfilter_object), noncreatable,
	uuid(BAF5AE2D-1B1A-4991-908A-A374F9537779),
	helpstring("Class FPCWebFilter")
	]
	coclass FPCWebFilter
	{
        [default]         interface IFPCWebFilter;
                          interface IFPCWebFilter2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcwebfilters_collection), noncreatable,
	uuid(3C773AA6-A97F-4453-8C19-AAFFC1E25459),
	helpstring("Class FPCWebFilters")
	]
	coclass FPCWebFilters
	{
        [default]         interface IFPCWebFilters;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpctunnelportranges_collection), noncreatable,
	uuid(C1D7DDB1-56FC-4CEF-81BB-979592A2EA8A),
	helpstring("Class FPCTunnelPortRanges")
	]
	coclass FPCTunnelPortRanges
	{
        [default]         interface IFPCTunnelPortRanges;
	};

	[
	helpcontext(_isa_fpchttpcompressionconfiguration), noncreatable,
	uuid(465ad72d-883f-4374-9617-928dc4259dec),
	helpstring("Class FPCHTTPCompressionConfiguration")
	]
	coclass FPCHTTPCompressionConfiguration
	{
        [default]         interface IFPCHTTPCompressionConfiguration;
                          interface IFPCHTTPCompressionConfiguration2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpctunnelportrange_object), noncreatable,
	uuid(9043E370-7A9F-4499-827E-3C5081FBB3CA),
	helpstring("Class FPCTunnelPortRange")
	]
	coclass FPCTunnelPortRange
	{
        [default]         interface IFPCTunnelPortRange;
	};

	[
	noncreatable,
	uuid(64B99ABE-00A2-4F50-8BDD-86D7789AC4A1),
	helpstring("Class FPCContentTypeSets")
	]
	coclass FPCContentTypeSets
	{
        [default]         interface IFPCContentTypeSets;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(B79B86B7-0B14-46C5-BF4F-C76A63E28582),
	helpstring("Class FPCContentTypeSet")
	]
	coclass FPCContentTypeSet
	{
        [default]         interface IFPCContentTypeSet;
                          interface IFPCContentTypeSet2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(B0FCB8B5-1DD6-4d16-A269-F434C0B8D5B4),
	helpstring("FPCConnectivityResults Class")
	]
	coclass FPCConnectivityResults
	{
        [default]         interface IFPCConnectivityResults;
	};

	[
	noncreatable,
	uuid(3C5EFD70-B146-4b4a-B5E3-8B2358767BB2),
	helpstring("FPCConnectivityResult Class")
	]
	coclass FPCConnectivityResult
	{
        [default]         interface IFPCConnectivityResult;
                          interface IFPCConnectivityResult2;
	};

	[
	helpcontext(_isa_fpcsignaledalerts_collection ), noncreatable,
	uuid(8558075D-C573-41F9-BD76-B428490FE9E3),
	helpstring("FPCSignaledAlerts Class")
	]
	coclass FPCSignaledAlerts
	{
        [default]         interface IFPCSignaledAlerts;
	};

	[
	helpcontext(_isa_fpcsignaledalert_object), noncreatable,
	uuid(91B5C154-C242-406B-BD68-C46403B26E72),
	helpstring("FPCSignaledAlert Class")
	]
	coclass FPCSignaledAlert
	{
        [default]         interface IFPCSignaledAlert;
	};

	[
	noncreatable,
	uuid(2E4EE3E1-5734-441B-A257-E503297F6C2A),
	helpstring("FPCSignaledAlertInstance Class")
	]
	coclass FPCSignaledAlertInstance
	{
        [default]         interface IFPCSignaledAlertInstance;
	};

	[
	helpcontext(_isa_fpcjobstatus_object), noncreatable,
	uuid(CAEEB437-F032-4AA6-B6D4-033F97C8957A),
	helpstring("FPCScheduledContentDownloadJobStatus Class")
	]
	coclass FPCScheduledContentDownloadJobStatus
	{
        [default]         interface IFPCScheduledContentDownloadJobStatus;
	};

	[
	helpcontext(_isa_fpcjobstatuses_collection), noncreatable,
	uuid(2A5D2DDD-8DBA-4546-ABD8-072ABE841400),
	helpstring("FPCScheduledContentDownloadJobStatuses Class")
	]
	coclass FPCScheduledContentDownloadJobStatuses
	{
        [default]         interface IFPCScheduledContentDownloadJobStatuses;
	};

	[
	helpcontext(_isa_fpcclientconfigsettings_collection), noncreatable,
	uuid(231B3865-797E-478E-9B46-8D71A63858BD),
	helpstring("Class FPCClientConfigSettings")
	]
	coclass FPCClientConfigSettings
	{
        [default]         interface IFPCClientConfigSettings;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcclientsettingssection_object), noncreatable,
	uuid(915E8295-2D9D-445D-AEDD-C910DAAD3181),
	helpstring("Class FPCClientSettingsSection")
	]
	coclass FPCClientSettingsSection
	{
        [default]         interface IFPCClientSettingsSection;
	};

	[
	noncreatable,
	uuid(8E7522ED-1DE2-4747-B966-C1D11A3B5679),
	helpstring("Class FPCNetworks")
	]
	coclass FPCNetworks
	{
        [default]         interface IFPCNetworks;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(07E8B656-A441-4079-8B40-64610F47B82B),
	helpstring("Class FPCNetwork")
	]
	coclass FPCNetwork
	{
        [default]         interface IFPCNetwork;
                          interface IFPCEENetwork;
                          interface IFPCNetwork2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(f14307fa-4617-455e-be76-c78efd8f5a00),
	helpstring("Class FPCEnterpriseNetworks")
	]
	coclass FPCEnterpriseNetworks
	{
        [default]         interface IFPCEEEnterpriseNetworks;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(9cf822af-b8f3-42dc-9089-20d79beae3cc),
	helpstring("Class FPCEnterpriseNetwork")
	]
	coclass FPCEnterpriseNetwork
	{
        [default]         interface IFPCEEEnterpriseNetwork;
                          interface IFPCEEEnterpriseNetwork2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(36F325FE-F56E-4A21-8EB7-9A7354779D79),
	helpstring("Class FPCNetworkTemplates")
	]
	coclass FPCNetworkTemplates
	{
        [default]         interface IFPCNetworkTemplates;
	};

	[
	noncreatable,
	uuid(9CC6DCBA-DEA0-45EA-864A-E9B8C4284074),
	helpstring("Class FPCNetworkTemplate")
	]
	coclass FPCNetworkTemplate
	{
        [default]         interface IFPCNetworkTemplate;
	};

	[
	noncreatable,
	uuid(81EE808F-F4E6-44CB-9F7A-2EAE8056EA51),
	helpstring("Class FPCNetworksInTemplate")
	]
	coclass FPCNetworksInTemplate
	{
        [default]         interface IFPCNetworksInTemplate;
	};

	[
	noncreatable,
	uuid(881FF935-50CE-4A04-AB46-0C7B0458A5FC),
	helpstring("Class FPCNetworkInTemplate")
	]
	coclass FPCNetworkInTemplate
	{
        [default]         interface IFPCNetworkInTemplate;
	};

	[
	noncreatable,
	uuid(C6D57696-2B06-453B-98EF-1125722EF273),
	helpstring("Class FPCPoliciesInTemplate")
	]
	coclass FPCPoliciesInTemplate
	{
        [default]         interface IFPCPoliciesInTemplate;
	};

	[
	noncreatable,
	uuid(24508B1C-AEC3-4BB4-9B45-44E6D0C29082),
	helpstring("Class FPCPolicyInTemplate")
	]
	coclass FPCPolicyInTemplate
	{
        [default]         interface IFPCPolicyInTemplate;
	};

	[
	noncreatable,
	uuid(00E555F4-033B-4F29-B3D8-6C9DBBE20CDB),
	helpstring("Class FPCNetworkSets")
	]
	coclass FPCNetworkSets
	{
        [default]         interface IFPCNetworkSets;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(38E9A5EA-5D7B-4B19-9ECD-E7DBF97B4432),
	helpstring("Class FPCNetworkSet")
	]
	coclass FPCNetworkSet
	{
        [default]         interface IFPCNetworkSet;
                          interface IFPCEENetworkSet;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(6764E2AB-CAB0-4FAA-9FDE-FC2D5E1F359E),
	helpstring("Class FPCNetworkRule")
	]
	coclass FPCNetworkRule
	{
        [default]         interface IFPCNetworkRule;
                          interface IFPCNetworkRule2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(8B16A021-BAA2-4276-84EB-22D9AF4C054F),
	helpstring("Class FPCReadOnlyIpRangeEntry")
	]
	coclass FPCReadOnlyIpRangeEntry
	{
        [default]         interface IFPCReadOnlyIpRangeEntry;
	};

	[
	noncreatable,
	uuid(8C3ED75E-0E7F-410B-BCA7-A63FE77B2249),
	helpstring("Class FPCReadOnlyIpRangeSet")
	]
	coclass FPCReadOnlyIpRangeSet
	{
        [default]         interface IFPCReadOnlyIpRangeSet;
                          interface IFPCEEReadOnlyIpRangeSet;
	};

	[
	noncreatable,
	uuid(88B28C0D-DDB6-42C2-A073-6C7C22D83E01),
	helpstring("Class FPCNetworkRules")
	]
	coclass FPCNetworkRules
	{
        [default]         interface IFPCNetworkRules;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(78BC57B4-CD40-4267-8FFC-C62617E48B1F),
	helpstring("FPCVpnConfiguration Class")
	]
	coclass FPCVpnConfiguration
	{
        [default]         interface IFPCVpnConfiguration;
                          interface IFPCEEVpnConfiguration;
                          interface IFPCVpnConfiguration2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(CBFE36D3-0B41-43C3-ABAC-36175170D6F0),
	helpstring("FPCVpnQuarantineSettings Class")
	]
	coclass FPCVpnQuarantineSettings
	{
        [default]         interface IFPCVpnQuarantineSettings;
	};

	[
	noncreatable,
	uuid(3F00825E-F6C2-4382-A16A-63C95DC60DCB),
	helpstring("FPCVpnPPPSettings Class")
	]
	coclass FPCVpnPPPSettings
	{
        [default]         interface IFPCVpnPPPSettings;
	};

	[
	noncreatable,
	uuid(C34A5CA1-48AF-45f5-8999-DA00BFA9A9F8),
	helpstring("FPCVpnNetworkConfiguration Class")
	]
	coclass FPCVpnNetworkConfiguration
	{
        [default]         interface IFPCVpnNetworkConfiguration;
                          interface IFPCEEVpnNetworkConfiguration;
	};

	[
	noncreatable,
	uuid(A3AB77E9-40D3-4900-B208-70CB901E92BA),
	helpstring("FPCVpnNetworkL2tpPptpSettings Class")
	]
	coclass FPCVpnNetworkL2tpPptpSettings
	{
        [default]         interface IFPCVpnNetworkL2tpPptpSettings;
	};

	[
	noncreatable,
	uuid(996662E3-73D5-4f98-A1A8-E30C98BBD6DF),
	helpstring("FPCVpnNetworkIPSecSettings Class")
	]
	coclass FPCVpnNetworkIPSecSettings
	{
        [default]         interface IFPCVpnNetworkIPSecSettings;
	};

	[
	noncreatable,
	uuid(2941C5C9-0D5E-4C76-A946-10669BD349EA),
	helpstring("FPCIpRangeEntry Class")
	]
	coclass FPCIpRangeEntry
	{
        [default]         interface IFPCIpRangeEntry;
	};

	[
	noncreatable,
	uuid(F15BAE18-643B-4EE3-BA1A-0BBFC396CB6C),
	helpstring("FPCIpRangeSet Class")
	]
	coclass FPCIpRangeSet
	{
        [default]         interface IFPCIpRangeSet;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(E4FA0B8F-8747-4956-AF17-BE0C45786CB0),
	helpstring("FPCWebListenerProperties Class")
	]
	coclass FPCWebListenerProperties
	{
        [default]         interface IFPCWebListenerProperties;
                          interface IFPCWebListenerProperties2;
                          interface IFPCWebListenerProperties3;
	};

	[
	noncreatable,
	uuid(20146628-AE71-4333-ACD2-D5AA3198A8D6),
	helpstring("IFPCFormsBasedAuthenticationProperties Class")
	]
	coclass FPCFormsBasedAuthenticationProperties
	{
        [default]         interface IFPCFormsBasedAuthenticationProperties;
	};

	[
	noncreatable,
	uuid(5822D0E6-9397-4215-A552-3BE616BC20BB),
	helpstring("IFPCSecurIDAuthenticationProperties Class")
	]
	coclass FPCSecurIDAuthenticationProperties
	{
        [default]         interface IFPCSecurIDAuthenticationProperties;
	};

	[
	noncreatable,
	uuid(A4C6B79A-849E-4459-8B23-82B093040C55),
	helpstring("FPCWebListener Class")
	]
	coclass FPCWebListener
	{
        [default]         interface IFPCWebListener;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(5ACCA5E8-5498-4678-8678-7876FDA97131),
	helpstring("FPCWebListeners Class")
	]
	coclass FPCWebListeners
	{
        [default]         interface IFPCWebListeners;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(262099D1-A357-47C1-9A74-004F1DFC6171),
	helpstring("FPCSSLClientCertificateRestriction Class")
	]
	coclass FPCSSLClientCertificateRestriction
	{
        [default]         interface IFPCSSLClientCertificateRestriction;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(8616A250-5A6B-4897-BD71-2E2B4F76759A),
	helpstring("FPCSSLClientCertificateRestrictions Class")
	]
	coclass FPCSSLClientCertificateRestrictions
	{
        [default]         interface IFPCSSLClientCertificateRestrictions;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(D7F7AEDD-416C-44C6-8EC0-5D4A54ED4AFD),
	helpstring("FPCIPsOnNetworks Class")
	]
	coclass FPCIPsOnNetworks
	{
        [default]         interface IFPCIPsOnNetworks;
	};

	[
	noncreatable,
	uuid(E06D08C4-2051-4F78-922D-7C83C77E084D),
	helpstring("FPCIPAddresses Class")
	]
	coclass FPCIPAddresses
	{
        [default]         interface IFPCIPAddresses;
	};

	[
	noncreatable,
	uuid(888F5AE3-0863-41C2-B7EB-FC1501D4A529),
	helpstring("FPCIPOnNetwork Class")
	]
	coclass FPCIPOnNetwork
	{
        [default]         interface IFPCIPOnNetwork;
	};

	[
	noncreatable,
	uuid(11DEE6AB-1972-4127-8F2A-B0299B4F0ED4),
	helpstring("FPCAppliedSSLCertificates Class")
	]
	coclass FPCAppliedSSLCertificates
	{
        [default]         interface IFPCAppliedSSLCertificates;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(515DFC1E-107B-4E5D-B06E-0A868E09BDB4),
	helpstring("FPCAppliedSSLCertificate Class")
	]
	coclass FPCAppliedSSLCertificate
	{
        [default]         interface IFPCAppliedSSLCertificate;
                          interface IFPCAppliedSSLCertificate2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(630035E0-C329-48F3-8334-F994CF773BE1),
	helpstring("FPCReportJobs Class")
	]
	coclass FPCReportJobs
	{
        [default]         interface IFPCReportJobs;
                          interface IFPCReportJobs2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(DB4C3CEB-7E01-4997-A7C3-33CB2322C8AE),
	helpstring("FPCReportJob Class")
	]
	coclass FPCReportJob
	{
        [default]         interface IFPCReportJob;
                          interface IFPCEEReportJob;
                          interface IFPCEEReportJob2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(BC9E03B2-E7F0-4581-95BA-B3020A2AE47A),
	helpstring("FPCReports Class")
	]
	coclass FPCReports
	{
        [default]         interface IFPCReports;
                          interface IFPCReports2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(47E57D40-8169-46CA-B9AF-D174137CE1A7),
	helpstring("FPCDailysumConfig Class")
	]
	coclass FPCDailysumConfig
	{
        [default]         interface IFPCLogSummaryConfiguration;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(8E2DA168-6315-497f-A699-CA864CE73002),
	helpstring("FPCReportingServicesProperties Class")
	]
	coclass FPCReportingServicesProperties
	{
        [default]         interface IFPCReportingServicesProperties;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	hidden,
	uuid(9FDD8E23-4BD7-4A0D-9781-81DC35B8F9A0),
	helpstring("FPCReadyReport Class")
	]
	coclass FPCReadyReport
	{
        [default]         interface IFPCReadyReport;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(B7F66C93-85CB-4E7B-BFCA-1ACE2B2BF8DF),
	helpstring("FPCReadyReports Class")
	]
	coclass FPCReadyReports
	{
        [default]         interface IFPCReadyReports;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(4980789E-61D6-11DB-8373-B622A1EF5492),
	helpstring("FPCReportSummaryDefinition Class")
	]
	coclass FPCReportSummaryDefinition
	{
        [default]         interface IFPCReportSummaryDefinition;
                          interface IFPCReportSummaryDefinition2;
	};

	[
	noncreatable,
	uuid(4057DA6E-61D6-11DB-8373-B622A1EF5492),
	helpstring("FPCReportSummaryDefinitions Class")
	]
	coclass FPCReportSummaryDefinitions
	{
        [default]         interface IFPCReportSummaryDefinitions;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(2AB58666-61D6-11DB-8373-B622A1EF5492),
	helpstring("FPCRdlReportDefinition Class")
	]
	coclass FPCRdlReportDefinition
	{
        [default]         interface IFPCRdlReportDefinition;
	};

	[
	noncreatable,
	uuid(352F5CCA-61D6-11DB-8373-B622A1EF5492),
	helpstring("FPCRdlReportDefinitions Class")
	]
	coclass FPCRdlReportDefinitions
	{
        [default]         interface IFPCRdlReportDefinitions;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(893E41EB-B08A-400a-BC13-673241C0EF0D),
	helpstring("FPCRdlReportParameterInstance Class")
	]
	coclass FPCRdlReportParameterInstance
	{
        [default]         interface IFPCRdlReportParameterInstance;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(DE2A5E00-32C6-4a94-98EE-708B3268EBCD),
	helpstring("FPCRdlReportParameterInstances Class")
	]
	coclass FPCRdlReportParameterInstances
	{
        [default]         interface IFPCRdlReportParameterInstances;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(71CCA278-1F56-41ab-AA52-D8BBB1254B24),
	helpstring("FPCRdlReportParameterPermittedValue Class")
	]
	coclass FPCRdlReportParameterPermittedValue
	{
        [default]         interface IFPCRdlReportParameterPermittedValue;
	};

	[
	noncreatable,
	uuid(100B0937-A4D3-47fa-888D-FC598E57407A),
	helpstring("FPCRdlReportParameterPermittedValues Class")
	]
	coclass FPCRdlReportParameterPermittedValues
	{
        [default]         interface IFPCRdlReportParameterPermittedValues;
	};

	[
	noncreatable,
	uuid(9C055929-B749-4421-B5C7-8BF5702F4A0B),
	helpstring("FPCRdlReportParameter Class")
	]
	coclass FPCRdlReportParameter
	{
        [default]         interface IFPCRdlReportParameter;
	};

	[
	noncreatable,
	uuid(C4DDC837-8966-4a7a-AC2D-4D1199C1DF12),
	helpstring("FPCRdlReportParameters Class")
	]
	coclass FPCRdlReportParameters
	{
        [default]         interface IFPCRdlReportParameters;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(1C41C28B-7D44-4ac9-8AD1-B68BC817D11D),
	helpstring("FPCRdlReportCategory Class")
	]
	coclass FPCRdlReportCategory
	{
        [default]         interface IFPCRdlReportCategory;
	};

	[
	noncreatable,
	uuid(6624BC72-2317-42d4-980E-E33EC63E06E9),
	helpstring("FPCRdlReportCategories Class")
	]
	coclass FPCRdlReportCategories
	{
        [default]         interface IFPCRdlReportCategories;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(B81810E2-3474-42f5-B049-999E16892321),
	helpstring("FPCRdlReportRef Class")
	]
	coclass FPCRdlReportRef
	{
        [default]         interface IFPCRdlReportRef;
	};

	[
	noncreatable,
	uuid(30EEAB9A-34DF-45ff-9AF7-F96764C9063C),
	helpstring("FPCRdlReportRefs Class")
	]
	coclass FPCRdlReportRefs
	{
        [default]         interface IFPCRdlReportRefs;
	};

	[
	hidden,
	uuid(EAB282A7-E514-4C3B-A3C5-D7AECF517207),
	helpstring("FPCReportsProperties Class")
	]
	coclass FPCReportsProperties
	{
        [default]         interface IFPCReportsProperties;
                          interface IFPCEEReportsProperties;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	hidden,
	uuid(5A3A5E1B-8510-4899-A3CC-437C24141D18),
	helpstring("FPCSummaryReports Class")
	]
	coclass FPCSummaryReports
	{
        [default]         interface IFPCSummaryReports;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	hidden,
	uuid(A189DCEB-B80A-4904-9C50-56513AFA5EFC),
	helpstring("FPCWebUsageReports Class")
	]
	coclass FPCWebUsageReports
	{
        [default]         interface IFPCWebUsageReports;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	hidden,
	uuid(11D415E6-24B2-42F3-AE94-F51D9ADA1B55),
	helpstring("FPCApplicationUsageReports Class")
	]
	coclass FPCApplicationUsageReports
	{
        [default]         interface IFPCApplicationUsageReports;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	hidden,
	uuid(9E8ABC18-F306-45AB-9606-C2DBA2919115),
	helpstring("FPCTrafficReports Class")
	]
	coclass FPCTrafficReports
	{
        [default]         interface IFPCTrafficReports;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	hidden,
	uuid(BCD1E868-4B8A-4321-8FB2-D018670A919A),
	helpstring("FPCSecurityReports Class")
	]
	coclass FPCSecurityReports
	{
        [default]         interface IFPCSecurityReports;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(9E125847-B339-426A-89A7-A541CB92DFE2),
	helpstring("FPCComputer Class")
	]
	coclass FPCComputer
	{
        [default]         interface IFPCComputer;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(90CD1188-5334-466E-B722-1E7BA00933A5),
	helpstring("FPCComputers Class")
	]
	coclass FPCComputers
	{
        [default]         interface IFPCComputers;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(9AEAA37B-EE08-4C78-80D6-5E75337780D9),
	helpstring("FPCAddressRange Class")
	]
	coclass FPCAddressRange
	{
        [default]         interface IFPCAddressRange;
                          interface IFPCAddressRange2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(217DA7F7-E8C3-4773-BFA8-312FB46E7B57),
	helpstring("FPCAddressRanges Class")
	]
	coclass FPCAddressRanges
	{
        [default]         interface IFPCAddressRanges;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(683F21C1-E75C-4E58-B3BC-5B94C9ABFD3D),
	helpstring("FPCSubnet Class")
	]
	coclass FPCSubnet
	{
        [default]         interface IFPCSubnet;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(2C24F981-2926-44DC-AF81-8F8E04A37D56),
	helpstring("FPCSubnets Class")
	]
	coclass FPCSubnets
	{
        [default]         interface IFPCSubnets;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(B2BC5CC7-99F0-4B52-8BC1-08AB74E5D02C),
	helpstring("FPCISPs Class")
	]
	coclass FPCISPs
	{
        [default]         interface IFPCISPs;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(61BA6C16-DC2F-447F-AE2D-3ABACBB62759),
	helpstring("FPCISP Class")
	]
	coclass FPCISP
	{
        [default]         interface IFPCISP;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(53E96914-8B44-4974-A0B8-630D4D6B051E),
	helpstring("FPCISPRedundancyConfig Class")
	]
	coclass FPCISPRedundancyConfig
	{
        [default]         interface IFPCISPRedundancyConfig;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(0B964D61-5EBE-4837-9AE1-00FEF4ABCB0F),
	helpstring("FPCComputerSet Class")
	]
	coclass FPCComputerSet
	{
        [default]         interface IFPCComputerSet;
                          interface IFPCComputerSet2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(6CDD4742-5E8C-44AD-9D53-ED831C58CF3A),
	helpstring("FPCComputerSets Class")
	]
	coclass FPCComputerSets
	{
        [default]         interface IFPCComputerSets;
                          interface IFPCComputerSets2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(21FFAFB5-A3AB-4129-8B98-3046A9D8A81F),
	helpstring("FPCUrlCategory Class")
	]
	coclass FPCUrlCategory
	{
        [default]         interface IFPCUrlCategory;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(26AA3CE0-DF3C-4399-B9E4-CD64686F1B62),
	helpstring("FPCUrlCategories Class")
	]
	coclass FPCUrlCategories
	{
        [default]         interface IFPCUrlCategories;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(d192ddbf-b127-483c-8d21-5713333732a3),
	helpstring("FPCUrlCategorySet Class")
	]
	coclass FPCUrlCategorySet
	{
        [default]         interface IFPCUrlCategorySet;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(98e729d9-0754-411a-a255-11840afb6756),
	helpstring("FPCUrlCategorySets Class")
	]
	coclass FPCUrlCategorySets
	{
        [default]         interface IFPCUrlCategorySets;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(AA2E238A-0B11-4EF8-9257-DA4864F87A5A),
	helpstring("FPCURLSet Class")
	]
	coclass FPCURLSet
	{
        [default]         interface IFPCURLSet;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(D6C38DA0-C96C-4894-8C6C-6A2EA0121BE2),
	helpstring("FPCURLSets Class")
	]
	coclass FPCURLSets
	{
        [default]         interface IFPCURLSets;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(61A8568E-53C1-4D6D-BBD8-4F7150EB3093),
	helpstring("FPCDomainNameSet Class")
	]
	coclass FPCDomainNameSet
	{
        [default]         interface IFPCDomainNameSet;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(2AD0305E-45E7-4bfd-B364-D917899E5BCD),
	helpstring("FPCPublishedServer Class")
	]
	coclass FPCPublishedServer
	{
        [default]         interface IFPCPublishedServer;
	};

	[
	noncreatable,
	uuid(32E2A53E-1E6A-4986-9ABD-20E7F61655A3),
	helpstring("FPCLoadBalancingConfig Class")
	]
	coclass FPCLoadBalancingConfig
	{
        [default]         interface IFPCLoadBalancingConfig;
	};

	[
	noncreatable,
	uuid(3492DAB0-8C77-4a8a-950B-A40335A136F4),
	helpstring("CFPCServerFarm Class")
	]
	coclass FPCServerFarm
	{
        [default]         interface IFPCServerFarm;
	};

	[
	noncreatable,
	uuid(0C71567E-A986-4d85-A3B9-FBEFDB70D594),
	helpstring("CFPCServerFarms Class")
	]
	coclass FPCServerFarms
	{
        [default]         interface IFPCServerFarms;
	};

	[
	noncreatable,
	uuid(727244CF-8961-49f5-B31F-B5DD288C5646),
	helpstring("FPCPublishedServers Class")
	]
	coclass FPCPublishedServers
	{
        [default]         interface IFPCPublishedServers;
	};

	[
	noncreatable,
	uuid(C66C195D-6678-4DD6-B2F5-BB8E0291B949),
	helpstring("FPCDomainNameSets Class")
	]
	coclass FPCDomainNameSets
	{
        [default]         interface IFPCDomainNameSets;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(A5DAB829-2386-45C9-A542-0F37FC2B335C),
	helpstring("FPCSelectionIPs Class")
	]
	coclass FPCSelectionIPs
	{
        [default]         interface IFPCSelectionIPs;
                          interface IFPCEESelectionIPs;
	};

	[
	noncreatable,
	uuid(0277B001-6386-433a-B33B-9A29AF81581F),
	helpstring("FPCExplicitLinkTranslationMappings Class")
	]
	coclass FPCExplicitLinkTranslationMappings
	{
        [default]         interface IFPCExplicitLinkTranslationMappings;
	};

	[
	noncreatable,
	uuid(B80278AF-F961-4758-94C8-A69BBBDA5C90),
	helpstring("FPCExplicitLinkTranslationMapping Class")
	]
	coclass FPCExplicitLinkTranslationMapping
	{
        [default]         interface IFPCExplicitLinkTranslationMapping;
	};

	[
	noncreatable,
	uuid(F888D462-8E04-464c-8882-30655B9E5AD1),
	helpstring("FPCCodePages Class")
	]
	coclass FPCCodePages
	{
        [default]         interface IFPCCodePages;
	};

	[
	noncreatable,
	uuid(E61622A5-14AE-450a-9181-3FE848C5B8CA),
	helpstring("FPCCodePage Class")
	]
	coclass FPCCodePage
	{
        [default]         interface IFPCCodePage;
	};

	[
	noncreatable,
	uuid(A39B1DC0-6C98-4857-871C-84C0A8D7870D),
	helpstring("FPCAccessProperties Class")
	]
	coclass FPCAccessProperties
	{
        [default]         interface IFPCAccessProperties;
                          interface IFPCAccessProperties2;
	};

	[
	noncreatable,
	uuid(EE55F3CC-A0C6-4945-98BD-55E64BA1CA64),
	helpstring("FPCServerPublishingProperties Class")
	]
	coclass FPCServerPublishingProperties
	{
        [default]         interface IFPCServerPublishingProperties;
                          interface IFPCEEServerPublishingProperties;
	};

	[
	noncreatable,
	uuid(34935FBC-B82D-42EC-A364-8E7EAA3BC502),
	helpstring("FPCWebPublishingProperties Class")
	]
	coclass FPCWebPublishingProperties
	{
        [default]         interface IFPCWebPublishingProperties;
                          interface IFPCWebPublishingProperties2;
                          interface IFPCWebPublishingProperties3;
                          interface IFPCWebPublishingProperties4;
	};

	[
	noncreatable,
	uuid(126158BF-E55E-44A2-9858-D94f9AE6A255),
	helpstring("FPCPolicyGroups Class")
	]
	coclass FPCPolicyGroups
	{
        [default]         interface IFPCPolicyGroups;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(12615EB7-5CEA-450B-BF51-0A816FB58834),
	helpstring("FPCPolicyGroup Class")
	]
	coclass FPCPolicyGroup
	{
        [default]         interface IFPCPolicyGroup;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(1FCA2D63-047B-4FB1-ACFB-534FB9A6111B),
	helpstring("FPCPolicyRules Class")
	]
	coclass FPCPolicyRules
	{
        [default]         interface IFPCPolicyRules;
                          interface IFPCEEPolicyRules;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(A4E35B9F-548A-404C-9BAB-350BEA38EFAF),
	helpstring("FPCSystemPolicyRules Class")
	]
	coclass FPCSystemPolicyRules
	{
        [default]         interface IFPCSystemPolicyRules;
                          interface IFPCSystemPolicyRules2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(59740B3A-8771-492C-AF59-7764F4F939EF),
	helpstring("FPCPolicyRule Class")
	]
	coclass FPCPolicyRule
	{
        [default]         interface IFPCPolicyRule;
                          interface IFPCEEPolicyRule;
                          interface IFPCPolicyRule2;
                          interface IFPCPolicyRule3;
                          interface IFPCPolicyRule4;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(6498d63e-d9ab-4bd5-b492-4d85a6520f2d),
	helpstring("FPCAdminSecurity Class")
	]
	coclass FPCAdminSecurity
	{
        [default]         interface IFPCAdminSecurity;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(6ccaba90-6573-44be-af9a-134cabe8fc59),
	helpstring("FPCSecurityRoles Class")
	]
	coclass FPCSecurityRoles
	{
        [default]         interface IFPCSecurityRoles;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(0ba52d36-762b-4211-96b6-e335f6247919),
	helpstring("FPCSecurityRole Class")
	]
	coclass FPCSecurityRole
	{
        [default]         interface IFPCSecurityRole;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(e34f3fa4-f1f1-43b7-abc8-57627f94bd2b),
	helpstring("FPCDelegatedAdmins Class")
	]
	coclass FPCDelegatedAdmins
	{
        [default]         interface IFPCDelegatedAdmins;
                          interface IFPCEEDelegatedAdmins;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(f359eb24-1558-433e-a005-a6b552f17325),
	helpstring("FPCDelegatedAdmin Class")
	]
	coclass FPCDelegatedAdmin
	{
        [default]         interface IFPCDelegatedAdmin;
                          interface IFPCEEDelegatedAdmin;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(7EF6CA87-5B5A-4E2C-A46C-BB5BFE5DDCA3),
	helpstring("FPCConnectivityVerifiers Class")
	]
	coclass FPCConnectivityVerifiers
	{
        [default]         interface IFPCConnectivityVerifiers;
                          interface IFPCConnectivityVerifiers2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(C04ABAF5-AF36-4F75-B8C8-72E78282355A),
	helpstring("FPCConnectivityVerifier Class")
	]
	coclass FPCConnectivityVerifier
	{
        [default]         interface IFPCConnectivityVerifier;
                          interface IFPCConnectivityVerifier2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(FA4A84DE-B139-4de1-A24F-6844C0F42FC5),
	helpstring("FPCLowLevelSettings Class")
	]
	coclass FPCLowLevelSettings
	{
        [default]         interface IFPCLowLevelSettings;
                          interface IFPCLowLevelSettings2;
                          interface IFPCLowLevelSettings3;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(48E520BB-AA21-4701-9237-33555F8DD91E),
	helpstring("FPCNLBCluster Class")
	]
	coclass FPCNLBCluster
	{
        [default]         interface IFPCEENLBCluster;
                          interface IFPCNLBCluster2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(ED600C54-6D54-4D0F-AD60-7D66B8652FE4),
	helpstring("FPCNLBConfiguration Class")
	]
	coclass FPCNLBConfiguration
	{
        [default]         interface IFPCEENLBConfiguration;
                          interface IFPCNLBConfiguration2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(435f293f-b984-412b-a299-3b72406bccc2),
	helpstring("FPCDomainMapping Class")
	]
	coclass FPCDomainMapping
	{
        [default]         interface IFPCEEDomainMapping;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(af324e38-7078-4b48-9fd0-cc9454eca609),
	helpstring("FPCDomainMappings Class")
	]
	coclass FPCDomainMappings
	{
        [default]         interface IFPCEEDomainMappings;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(2BAEFC22-6B73-4907-983B-3E5595F0E867),
	helpstring("FPCContentDeliverySettings Class")
	]
	coclass FPCContentDeliverySettings
	{
        [default]         interface IFPCContentDeliverySettings;
                          interface IFPCContentDeliverySettings2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(B9BBAE14-8957-4f6d-B3FA-356638E18E05),
	helpstring("FPCOutboundHTTPSInspectionConfiguration Class")
	]
	coclass FPCOutboundHTTPSInspectionConfiguration
	{
        [default]         interface IFPCOutboundHTTPSInspectionConfiguration;
                          interface IFPCOutboundHTTPSInspectionConfiguration2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(A0CC6D96-4913-40fb-911A-8C58512FDA6F),
	helpstring("FPCCACertificate Class")
	]
	coclass FPCCACertificate
	{
        [default]         interface IFPCCACertificate;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(28480042-CB9F-402d-8718-7C606790FB29),
	helpstring("FPCUrlToCategoryMapping Class")
	]
	coclass FPCUrlToCategoryMapping
	{
        [default]         interface IFPCUrlToCategoryMapping;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(B82013E2-98ED-49a0-A174-967F9837165A),
	helpstring("FPCUrlToCategoryMappings Class")
	]
	coclass FPCUrlToCategoryMappings
	{
        [default]         interface IFPCUrlToCategoryMappings;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(F0AF8ADD-210E-4B9E-8A88-F58F56932EB7),
	helpstring("FPCMalwareInspectionSettings Class")
	]
	coclass FPCMalwareInspectionSettings
	{
        [default]         interface IFPCMalwareInspectionSettings;
                          interface IFPCMalwareInspectionSettings2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(e58a0797-3c03-46cd-b02e-8718a7df8134),
	helpstring("FPCTemporaryStorageSettings Class")
	]
	coclass FPCTemporaryStorageSettings
	{
        [default]         interface IFPCTemporaryStorageSettings;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(527C9F2A-D7CD-41F8-BEA6-93240394AF30),
	helpstring("FPCMalwareInspectionScannerSettings Class")
	]
	coclass FPCMalwareInspectionScannerSettings
	{
        [default]         interface IFPCMalwareInspectionScannerSettings;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(116c49f8-9fa8-4747-8d47-fce47fa63d70),
	helpstring("FPCRoutingTable Class")
	]
	coclass FPCRoutingTable
	{
        [default]         interface IFPCRoutingTable;
	};

	[
	noncreatable,
	uuid(658773bd-68c3-45b3-9e5a-4d921625cf1b),
	helpstring("FPCRoute Class")
	]
	coclass FPCRoute
	{
        [default]         interface IFPCRoute;
	};

	[
	noncreatable,
	uuid(4d94075f-151e-4872-ab24-fe420ad756a5),
	helpstring("FPCStaticRoutes Class")
	]
	coclass FPCStaticRoutes
	{
        [default]         interface IFPCStaticRoutes;
	};

	[
	noncreatable,
	uuid(03770e03-7470-4635-a929-f9bcec070a05),
	helpstring("FPCStaticRoute Class")
	]
	coclass FPCStaticRoute
	{
        [default]         interface IFPCStaticRoute;
	};

	[
	helpcontext(_isa_fpcupdatecenter_object), noncreatable,
	uuid(95578915-BC2F-4951-9A4A-52E877FFF180),
	helpstring("FPCUpdateCenter Class")
	]
	coclass FPCUpdateCenter
	{
        [default]         interface IFPCUpdateCenter;
                          interface IFPCUpdateCenter2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcupdateservices_object), noncreatable,
	uuid(F01C2133-7C91-4622-BF3B-88A3D4E68694),
	helpstring("FPCUpdateServices Class")
	]
	coclass FPCUpdateServices
	{
        [default]         interface IFPCUpdateServices;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcupdateservice_object), noncreatable,
	uuid(01DAD308-44F4-4229-BB9A-8775593D304D),
	helpstring("FPCUpdateService Class")
	]
	coclass FPCUpdateService
	{
        [default]         interface IFPCUpdateService;
                          interface IFPCUpdateService2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(FE2506AE-0166-43C1-8EE1-B1E09220A293),
	helpstring("FPCLicenses Class")
	]
	coclass FPCLicenses
	{
        [default]         interface IFPCLicenses;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(DBCEFC2E-290C-432E-B6D7-22D8F64712E7),
	helpstring("FPCLicense Class")
	]
	coclass FPCLicense
	{
        [default]         interface IFPCLicense;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcserviceupdatesstates_object), noncreatable,
	uuid(B425F355-C78F-4560-8E65-266F5E188574),
	helpstring("FPCServiceUpdatesStates Class")
	]
	coclass FPCServiceUpdatesStates
	{
        [default]         interface IFPCServiceUpdatesStates;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	helpcontext(_isa_fpcserviceupdatesstate_object), noncreatable,
	uuid(ABDD6024-CDB5-4a4c-A574-4013136782E9),
	helpstring("FPCServiceUpdatesState Class")
	]
	coclass FPCServiceUpdatesState
	{
        [default]         interface IFPCServiceUpdatesState;
                          interface IFPCServiceUpdatesState2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(88C3E434-0A93-491B-BF49-65C08C7B4D21),
	helpstring("FPCMalwareInspectionProperties Class")
	]
	coclass FPCMalwareInspectionProperties
	{
        [default]         interface IFPCMalwareInspectionProperties;
                          interface IFPCMalwareInspectionProperties2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(F0DFCCB5-3B6E-4564-B380-090C4A571478),
	helpstring("FPCDestinations Class")
	]
	coclass FPCDestinations
	{
        [default]         interface IFPCDestinations;
                          interface IFPCDestinations2;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(0B5790C5-0D35-42AE-A587-2A43D6E1825F),
	helpstring("FPCSources Class")
	]
	coclass FPCSources
	{
        [default]         interface IFPCSources;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(592A060F-F0B0-404B-B40C-4CE14F7BDCDF),
	helpstring("FPCProtocolMessageDefinitionParameter Class")
	]
	coclass FPCProtocolMessageDefinitionParameter
	{
        [default]         interface IFPCProtocolMessageDefinitionParameter;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(C34FC27F-5657-4BFC-B095-A9679BBB4279),
	helpstring("FPCProtocolMessageDefinition Class")
	]
	coclass FPCProtocolMessageDefinition
	{
        [default]         interface IFPCProtocolMessageDefinition;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(ECD56E7C-0533-4523-8C2A-F7FD19370635),
	helpstring("FPCProtocolMessageDefinitions Class")
	]
	coclass FPCProtocolMessageDefinitions
	{
        [default]         interface IFPCProtocolMessageDefinitions;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(641B8A38-1D2C-4BD6-99B4-C819F5D5DED1),
	helpstring("FPCUrlFilteringSettings Class")
	]
	coclass FPCUrlFilteringSettings
	{
        [default]         interface IFPCUrlFilteringSettings;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(5663F53A-F9D0-49EE-A654-D68F0A63B795),
	helpstring("PerfCounterSettings Class")
	]
	coclass FPCPerfCounterSettings
	{
        [default]         interface IFPCPerfCounterSettings;
	};

	[
	noncreatable,
	uuid(0FD56593-FE31-46F9-A399-5161CF74F5F0),
	helpstring("RequestRateAverageBytesPerSec Class")
	]
	coclass FPCRequestRateAverageBytesPerSec
	{
        [default]         interface IFPCRequestRateAverageBytesPerSec;
	};

	[
	helpcontext(_isa_fpcactivitystatisticsentry_object), noncreatable,
	uuid(485A7F6B-7F99-4f9c-A2A1-24C352497ADE),
	helpstring("FPCStatisticsEntry Class")
	]
	coclass FPCActivityStatisticsEntry
	{
        [default]         interface IFPCActivityStatisticsEntry;
	};

	[
	noncreatable,
	uuid(662CE64C-A6A2-4048-A38E-48F9598F6967),
	helpstring("FPCPerformanceCounterEntry Class")
	]
	coclass FPCPerformanceCounterEntry
	{
        [default]         interface IFPCPerformanceCounterEntry;
	};

	[
	helpcontext(_isa_fpcactivitystatistics_object), noncreatable,
	uuid(93FDEECA-F353-45ad-A437-3C680DDAAF3B),
	helpstring("FPCStatistics Class")
	]
	coclass FPCActivityStatistics
	{
        [default]         interface IFPCActivityStatistics;
	};

	[
	noncreatable,
	uuid(FF63DC63-5DAE-49ad-9DA7-C04D18BAF203),
	helpstring("FPCDashboardPerformanceCounters Class")
	]
	coclass FPCDashboardPerformanceCounters
	{
        [default]         interface IFPCDashboardPerformanceCounters;
	};

	[
	helpcontext(_isa_fpcsipsettings_object), noncreatable,
	uuid(E6D1F736-FF27-4c32-A656-8C959912F186),
	helpstring("FPCSipSettings Class")
	]
	coclass FPCSipSettings
	{
        [default]         interface IFPCSipSettings;
	};

	[
	noncreatable,
	uuid(D04D4F4A-64C8-4AC9-9E08-EEBFACB7AFF0),
	helpstring("FPCSmtpProtectionConfiguration Class")
	]
	coclass FPCSmtpProtectionConfiguration
	{
        [default]         interface IFPCSmtpProtectionConfiguration;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(5c7dde68-7dc3-4592-9a9b-e0240d582853),
	helpstring("FPCMailAntivirusSettings Class")
	]
	coclass FPCMailAntivirusSettings
	{
        [default]         interface IFPCMailAntivirusSettings;
	};

	[
	noncreatable,
	uuid(14912eec-8fab-47ac-818f-df2348b00eb9),
	helpstring("FPCMailAntiSpamSettings Class")
	]
	coclass FPCMailAntiSpamSettings
	{
        [default]         interface IFPCMailAntiSpamSettings;
	};

	[
	noncreatable,
	uuid(8e2adcdd-856f-4de4-bbe3-7c3bbcaaf389),
	helpstring("FPCSmtpProtectionStatus Class")
	]
	coclass FPCSmtpProtectionStatus
	{
        [default]         interface IFPCSmtpProtectionStatus;
	};

	[
	noncreatable,
	uuid(376DF7D8-63D6-4683-8286-9F20B04EAF66),
	helpstring("FPCIpListRanges Class")
	]
	coclass FPCIpListRanges
	{
        [default]         interface IFPCIpListRanges;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(8B75AC6A-D6EE-44EF-B54C-2432370B33CA),
	helpstring("FPCIpListRange Class")
	]
	coclass FPCIpListRange
	{
        [default]         interface IFPCIpListRange;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(FFBEEF1B-AC0F-4C71-AFB5-6BE246551ED2),
	helpstring("FPCIpListProviders Class")
	]
	coclass FPCIpListProviders
	{
        [default]         interface IFPCIpListProviders;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(EFE0B062-BAD2-4B91-8D8D-DCEC56A63C5C),
	helpstring("FPCIpListProvider Class")
	]
	coclass FPCIpListProvider
	{
        [default]         interface IFPCIpListProvider;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(353A248A-2DFA-42A3-A369-B1347F085A9A),
	helpstring("FPCEMailAddress Class")
	]
	coclass FPCEMailAddress
	{
        [default]         interface IFPCEMailAddress;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(93165C13-D8B8-44A9-9949-2337A1B9C015),
	helpstring("FPCPhrase Class")
	]
	coclass FPCPhrase
	{
        [default]         interface IFPCPhrase;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(DD9C9205-602D-4D0C-8977-7A0A4DB5E6FC),
	helpstring("FPCEMailAddresses Class")
	]
	coclass FPCEMailAddresses
	{
        [default]         interface IFPCEMailAddresses;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(782F0036-E841-485D-9E17-134AA5445657),
	helpstring("FPCPhrases Class")
	]
	coclass FPCPhrases
	{
        [default]         interface IFPCPhrases;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(70E6D575-3D84-4E0A-9AD0-133485E26522),
	helpstring("FPCBlockedSenders Class")
	]
	coclass FPCBlockedSenders
	{
        [default]         interface IFPCBlockedSenders;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(49B578A1-72E4-4CFC-8004-F914397CAF4E),
	helpstring("FPCBlockedSender Class")
	]
	coclass FPCBlockedSender
	{
        [default]         interface IFPCBlockedSender;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(D1CC1763-375F-48F7-BCD5-AF281F0D161F),
	helpstring("FPCAddressSpace Class")
	]
	coclass FPCAddressSpace
	{
        [default]         interface IFPCAddressSpace;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(E4533356-DAC0-4CD7-8D48-93F19146588C),
	helpstring("FPCAddressSpaces Class")
	]
	coclass FPCAddressSpaces
	{
        [default]         interface IFPCAddressSpaces;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(2FC8C58E-BEE5-4520-A9E6-4798F119567F),
	helpstring("FPCSmtpAuthenticationSettings Class")
	]
	coclass FPCSmtpAuthenticationSettings
	{
        [default]         interface IFPCSmtpAuthenticationSettings;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(287B0AAA-155B-4D41-9F80-F13F76F85BC5),
	helpstring("FPCSmtpRouteAuthenticationSettings Class")
	]
	coclass FPCSmtpRouteAuthenticationSettings
	{
        [default]         interface IFPCSmtpRouteAuthenticationSettings;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(C6C4BFA6-529D-4F78-8E37-A8AB1E059AA2),
	helpstring("FPCSmtpRoute Class")
	]
	coclass FPCSmtpRoute
	{
        [default]         interface IFPCSmtpRoute;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(614785C9-E395-4CDC-8D26-8DDBBACBA560),
	helpstring("FPCSmtpRoutes Class")
	]
	coclass FPCSmtpRoutes
	{
        [default]         interface IFPCSmtpRoutes;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(970fe06e-c340-4a29-aec0-909f9d0ea1ad),
	helpstring("FPCMailAntispamFilterLists Class")
	]
	coclass FPCMailAntispamFilterLists
	{
        [default]         interface IFPCMailAntispamFilterLists;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(c2225c70-fb10-4ec2-9413-6f6842a55a5b),
	helpstring("FPCMailAntispamFilterList Class")
	]
	coclass FPCMailAntispamFilterList
	{
        [default]         interface IFPCMailAntispamFilterList;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(64d05c60-c71d-4dd9-8c8a-a87935e0a478),
	helpstring("")
	]
	coclass FPCSecurityAssessmentSharing
	{
        [default]         interface IFPCSecurityAssessmentSharing;
	};

	[
	noncreatable,
	uuid(4a521d72-5460-405b-a99f-290415f1af52),
	helpstring("FPCMailAntispamFilterStrings Class")
	]
	coclass FPCMailAntispamFilterStrings
	{
        [default]         interface IFPCMailAntispamFilterStrings;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(670b9615-0d63-4a84-bcb7-7ad8b9976f6d),
	helpstring("FPCMailAntispamFilterFileTypes Class")
	]
	coclass FPCMailAntispamFilterFileTypes
	{
        [default]         interface IFPCMailAntispamFilterFileTypes;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(1305769D-31FD-41b9-8498-5FC043F140F4),
	helpstring("FPCRestrictedPorts Class")
	]
	coclass FPCRestrictedPorts
	{
        [default]         interface IFPCRestrictedPorts;
		[default, source] dispinterface IFPCPersistSink;
	};

	[
	noncreatable,
	uuid(C7CE3B8C-D715-42eb-ACA9-12E2DA50547A),
	helpstring("FPCRestrictedPortsRange Class")
	]
	coclass FPCRestrictedPortsRange
	{
        [default]         interface IFPCRestrictedPortsRange;
	};

	[
	helpcontext(_isa_fpcchangetracking_object), noncreatable,
	uuid(1237b676-b917-4eeb-97ab-18999b18411d),
	helpstring("FPCChangeTracking Class")
	]
	coclass FPCChangeTracking
	{
        [default]         interface IFPCChangeTracking;
	};

	[
	helpcontext(_isa_fpcipv6settings_object), noncreatable,
	uuid(D4180FC7-23C1-4450-AA2B-CD1275CDC6E7),
	helpstring("FPCIPv6Settings Class")
	]
	coclass FPCIPv6Settings
	{
        [default]         interface IFPCIPv6Settings;
	};



    [
    uuid(54DBE2E6-EBAB-455A-87E1-63AD6E1BC1DF),
    helpcontext(_isa_fpclogentry_object),
    helpstring("FPCLogEntry Class"),
    noncreatable
    ]
    coclass FPCLogEntry
    {
        [default]         interface IFPCLogEntry;
                          interface IFPCEELogEntry;
                          interface IFPCLogEntry2;
                          interface IFPCLogEntry3;
                          interface IFPCLogEntry4;
    };

}
